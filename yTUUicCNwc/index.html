<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Max Maya python">
<meta name="description" content="个人学习博客">
<meta name="theme-color" content="#000">
<title>想见山海</title>
<link rel="shortcut icon" href="/favicon.ico?v=1693996745021">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/atom-one-dark.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>想见山海</span>
            </a>  
          
        </div>
        
          <p class="subtitle">Keep stduying</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> 归档
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> 标签
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/post/about" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout  pisces">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">WJC</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>目前主要学习方向是C++和Python</p>
      
        <p> 在3D建模相关工作实习，所以也有部分建模和图形学的学习内容</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">73</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">43</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  

  



</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'pisces';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box tag-line box-shadow-wrapper">
          <section class="section tags-section posts-expand bg-color">
            <div class="padding-wrapper">
  <div class="tag-timeline-box">
    <div class="tag-timeline-wrapper">
      <div class="tag-timeline-title">
        <h2>
          智能指针
          <small class="language" data-lan="tag">标签</small>
        </h2>
      </div>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="https://wjcsw.github.io/nBjC6ymmW/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              11-06
              <small>[C++学习笔记] 动态内存</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </div>
  </div>
</div>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      
    </div>
  </footer>
  
    
        <div class="pisces back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "true";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/BBZegAhYY/"" data-c="
          &lt;h2 id=&#34;材质&#34;&gt;材质&lt;/h2&gt;
&lt;p&gt;不同的物体对光的反射效果也不同，这里用材质来描述这种性质。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-GLSL&#34;&gt;struct Material {
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
}; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;材质的定义是与光照模型的定义相对应的，按照之前使用的冯氏光照模型，物体颜色的组成主要有四个部分：环境光照、漫反射光照，镜面光照以及反光度。根据上述规则可以定义出对应该模型的材质的结构体。&lt;/p&gt;
&lt;p&gt;实际实践中，环境光照一般都取与反射光照相同的颜色，因此可以不用添加，如果你希望的话，也可以保留。而为了更加精细的对物体的每个片段单独设置颜色，可以使用漫反射纹理贴图与镜面反射纹理贴图来进行控制，替代直接使用分量全局执行。&lt;/p&gt;
&lt;p&gt;镜面反射纹理贴图是一个专门用于镜面高光的纹理贴图。它是一个黑白的（如果你想得话也可以是彩色的）纹理，来定义物体每部分的镜面光强度。在镜面反射纹理贴图中，一个像素越「白」，物体的镜面光分量就会越亮。如图所示是一个镜面反射纹理贴图：&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1693489139613.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用Photoshop或Gimp之类的工具，将漫反射纹理转换为镜面光纹理还是比较容易的，只需要剪切掉一些部分，将图像转换为黑白的，并增加亮度/对比度就好了。&lt;/p&gt;
&lt;p&gt;因此，进一步可以将材料结构体定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-GLSL&#34;&gt;struct Material {
    sampler2D diffuse;
    sampler2D specular;
    float shininess;
}; 
in vec2 TexCoords;
uniform Material material;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里使用纹理的方式与之前基本完全相同。而由于这里还需要纹理坐标，因此和之前的类似，还需要传入纹理坐标。&lt;/p&gt;
&lt;p&gt;接着，从CPU程序中通过uniform将材质传入。注意，从外面传结构体时，需要对结构体的每个变量单独传值。具体实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;shader.SetUniform1i(&amp;quot;material.specular&amp;quot;, 1);
shader.SetUniform1f(&amp;quot;material.shininess&amp;quot;, 25.0f);
shader.SetUniform1i(&amp;quot;material.diffuse&amp;quot;, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;光源&#34;&gt;光源&lt;/h2&gt;
&lt;p&gt;影响物体表现的除了物体本身，当然还有光源的情况。同样的，对应的光源属性也有四个，用于控制这四种光照对物体的影响。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-GLSL&#34;&gt;struct Light {
    vec3 position;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

uniform Light light;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里将其定义为向量形式即可，因为这里光源本身可以视作是一个整体。&lt;/p&gt;
&lt;p&gt;同样，将对应值通过uniform传入即可。&lt;/p&gt;
&lt;p&gt;那么，根据上面定义好的物理材质和光源属性，就可以得到对应的光照情况下的物体了。基本上就是在之前的光照模型的基础上稍加改动，将固定值改为了传入的材料和光源属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-GLSL&#34;&gt;void main()
{
    vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords));

    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(LightPos - FragPos);

    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));

    vec3 viewDir = normalize(-FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));

    vec3 result = ambient + diffuse + specular;
    FragColor = vec4(result, 1.0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加入了上述结构后，可以使得程序显示出一个更加真实的光照情况。最终效果如下：&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1693489110512.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1] https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/03%20Hello%20Window/&lt;/p&gt;
">[OpenGL入门教程] 11. 材质与光照贴图</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/kcs6-FlyI/"" data-c="
          &lt;p&gt;在此前的博客中，使用的一直是预定义好的固定颜色或者纹理来渲染图形的。接下来，将进一步改造片段着色器部分，为其添加光照效果。&lt;/p&gt;
&lt;h2 id=&#34;颜色的构成&#34;&gt;颜色的构成&lt;/h2&gt;
&lt;p&gt;在现实生活中看到某一物体的颜色并不是这个物体真正拥有的颜色，而是它所反射的颜色。换句话说，那些不能被物体所吸收的颜色才是我们能够感知到的物体的颜色。例如，如果我们将白光照在一个蓝色的玩具上，这个蓝色的玩具会吸收白光中除了蓝色以外的所有子颜色，不被吸收的蓝色光被反射到眼中，让这个玩具看起来是蓝色的。&lt;/p&gt;
&lt;p&gt;在计算机中有几种表示颜色的系统，不过一如既往的，这里使用RGB向量来表示颜色。&lt;/p&gt;
&lt;p&gt;这些颜色反射的定律被直接地运用在图形领域。在OpenGL中创建一个光源时，会给光源一个颜色。光源的颜色与物体的颜色值相乘，所得到的就是这个物体所反射的颜色（也就是我们所感知到的颜色）。&lt;/p&gt;
&lt;h2 id=&#34;冯氏光照模型&#34;&gt;冯氏光照模型&lt;/h2&gt;
&lt;p&gt;现实世界的光照是极其复杂的，而且会受到诸多因素的影响，因此OpenGL的光照使用的是简化的模型，对现实的情况进行近似，并且效果上也比较近似。其中一个模型被称为冯氏光照模型(Phong Lighting Model)。冯氏光照模型的主要结构由3个分量组成：环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环境光照：可以认为是背景光照，很小的一个亮度值。物体几乎永远不会是完全黑暗的，为了模拟这个，会使用一个环境光照常量，它永远会给物体一些颜色。&lt;/li&gt;
&lt;li&gt;漫反射光照：模拟光源对物体的方向性影响，它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。&lt;/li&gt;
&lt;li&gt;镜面光照：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;环境光照&#34;&gt;环境光照&lt;/h3&gt;
&lt;p&gt;环境光照的实现非常简单，直接通过一个环境光照因子乘上光的颜色即可&lt;/p&gt;
&lt;p&gt;这里使用一个很小的常量（光照）颜色，添加到物体片段的最终颜色中，这样子的话即便场景中没有直接的光源也能看起来存在有一些发散的光。&lt;/p&gt;
&lt;p&gt;在片段着色器中对颜色进行简单的额外处理即可。注意，要将光的颜色和物体颜色通过&lt;code&gt;uniform&lt;/code&gt;传进去。为了简单起见，这里使用的是白光光源，即颜色向量为(1.0f, 1.0f, 1.0f)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-GLSL&#34;&gt;......
uniform vec3 objectColor;
uniform vec3 lightColor;

void main()
{
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;

    vec3 result = ambient * objectColor;
    FragColor = vec4(result, 1.0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;漫反射光照&#34;&gt;漫反射光照&lt;/h3&gt;
&lt;p&gt;环境光照本身提供的只是很微弱的影响，但是漫反射光照就能开始对物体产生显著的视觉影响了。漫反射光照使物体上与光线方向越接近的片段能从光源处获得更多的亮度。&lt;/p&gt;
&lt;p&gt;为了计算漫反射光照，需要测量这个光线是以什么角度接触到这个片段的。如果光线垂直于物体表面，这束光对物体的影响会最大化（也就是更亮）。而为了测量光线和片段的角度，需要使用一个叫做&lt;strong&gt;法向量&lt;/strong&gt;的东西，它是垂直于片段表面的一个向量。当两个向量的夹角为90度的时候，点乘会变为0。这同样适用于θ，θ越大，光对片段颜色的影响就应该越小。&lt;/p&gt;
&lt;p&gt;注意，为了（只）得到两个向量夹角的余弦值，使用的是单位向量（长度为1的向量），所以需要确保所有的向量都是标准化的，否则点乘返回的就不仅仅是余弦值了。&lt;/p&gt;
&lt;p&gt;具体而言，计算漫反射光照需要法向量和光线方向。将这两个向量进行点乘，用于计算光源对当前片段实际的漫反射影响。结果值再乘以光的颜色，就得到了漫反射分量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;法向量：一个垂直于顶点表面的向量。&lt;/li&gt;
&lt;li&gt;光线方向：作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，需要光的位置向量和片段的位置向量，对其进行相减即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单起见，由于使用的是正方体，这里将法线向量直接定义在顶点属性中。更改顶点数组，并设置对应的uniform。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;float vertices[] = {
    -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
     0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
     0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
     0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
    -0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,

    -0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,
     0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,
    -0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,

    -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f,  0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f, -0.5f,  0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,

     0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,
     0.5f,  0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
     0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
     0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
     0.5f, -0.5f,  0.5f,  1.0f,  0.0f,  0.0f,
     0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,

    -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,
     0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,
     0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
     0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,

    -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,
     0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,
     0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
     0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
    -0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
    -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f
};

glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3*sizeof(float)));
glEnableVertexAttribArray(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后更改顶点着色器和片段着色器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-GLSL&#34;&gt;#shader vertex
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
out vec3 Normal;
out vec3 FragPos;  

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    Normal = mat3(transpose(inverse(view * model))) * aNormal;
    FragPos = vec3(view * model * vec4(aPos, 1.0));
}

#shader fragment
#version 330 core

in vec3 FragPos;
in vec3 Normal;

uniform vec3 objectColor;
uniform vec3 lightColor;

void main()
{
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;

    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);

    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;

    vec3 result = (ambient + diffuse) * objectColor;
    FragColor = vec4(result, 1.0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先，一般而言，都是在观察空间进行光照计算。观察空间计算的优势是，观察者的位置总是在(0, 0, 0)，所以已经零成本地拿到了观察者的位置。所以需要需要将所有相关的向量也用观察矩阵进行变换（不要忘记也修改法线矩阵），即全部乘上&lt;code&gt;view&lt;/code&gt;矩阵（当然，在此之前需要先变换到世界矩阵，即乘&lt;code&gt;model&lt;/code&gt;矩阵）。&lt;/p&gt;
&lt;p&gt;法向量只是一个方向向量，不能表达空间中的特定位置。同时，法向量没有齐次坐标（顶点位置中的&lt;code&gt;w&lt;/code&gt;分量）。这意味着，位移不应该影响到法向量。对于法向量，只希望对它实施缩放和旋转变换。&lt;/p&gt;
&lt;p&gt;如果模型矩阵执行了不等比缩放，顶点的改变会导致法向量不再垂直于表面了。因此，不能直接用模型矩阵来变换法向量。每当应用一个不等比缩放时（注意：等比缩放不会破坏法线，因为法线的方向没被改变，仅仅改变了法线的长度，而这很容易通过标准化来修复），法向量就不会再垂直于对应的表面了，这样光照就会被破坏。&lt;/p&gt;
&lt;p&gt;因此，需要使用专门的法线矩阵，它通过一些线性代数的操作移除了对法向量错误缩放的影响。&lt;/p&gt;
&lt;p&gt;在顶点着色器中，可以使用&lt;code&gt;inverse&lt;/code&gt;和&lt;code&gt;transpose&lt;/code&gt;函数自己生成这个法线矩阵。注意还要把被处理过的矩阵强制转换为3×3矩阵，来保证它失去了位移属性以及能够乘以&lt;code&gt;vec3&lt;/code&gt;的法向量。&lt;/p&gt;
&lt;p&gt;因为计算需要一个顶点位置，可以通过把顶点位置属性乘以模型矩阵（不是观察和投影矩阵）来把它变换到世界空间坐标，接着再变换到观察空间。将这个坐标输出到片段着色器中。&lt;/p&gt;
&lt;p&gt;在片段着色器中，需要做的第一件事是计算光源和片段位置之间的方向向量。光的方向向量是光源位置向量与片段位置向量之间的向量差。为了确保所有相关向量最后都转换为单位向量，所以把法线和最终的方向向量都进行了标准化。&lt;/p&gt;
&lt;p&gt;接着，对norm和lightDir向量进行点乘，计算光源对当前片段实际的漫反射影响。结果值再乘以光的颜色，得到漫反射分量。&lt;/p&gt;
&lt;p&gt;最后把这个值加到结果上即可。&lt;/p&gt;
&lt;h3 id=&#34;镜面光照&#34;&gt;镜面光照&lt;/h3&gt;
&lt;p&gt;和漫反射光照一样，镜面光照也决定于光的方向向量和物体的法向量，但是它也决定于观察方向，例如玩家是从什么方向看向这个片段的。镜面光照决定于表面的反射特性。如果把物体表面设想为一面镜子，那么镜面光照最强的地方就是看到表面上反射光的地方。&lt;/p&gt;
&lt;p&gt;可以通过根据法向量翻折入射光的方向来计算反射向量。然后计算反射向量与观察方向的角度差，它们之间夹角越小，镜面光的作用就越大。由此产生的效果就是，在看向在入射光在表面的反射方向时，会看到一点高光。&lt;/p&gt;
&lt;p&gt;观察向量是计算镜面光照时需要的一个额外变量，可以使用观察者的位置和片段的位置来计算它，将其直接相减即可。&lt;/p&gt;
&lt;p&gt;由于之前已经变换到观察空间进行光照计算，因此，观察者的坐标直接为(0,0,0)。&lt;/p&gt;
&lt;p&gt;对应的，在片段着色器中添加代码计算镜面光照。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-GLSL&#34;&gt;float specularStrength = 0.5;
vec3 viewDir = normalize(-FragPos);
vec3 reflectDir = reflect(-lightDir, norm);
float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
vec3 specular = specularStrength * spec * lightColor;

vec3 result = (ambient + diffuse + specular) * objectColor;
FragColor = vec4(result, 1.0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;specularStrength&lt;/code&gt;代表镜面强度，这里给镜面高光一个中等亮度颜色，让它不要产生过度的影响。&lt;/p&gt;
&lt;p&gt;下一步，计算视线方向向量，和对应的沿着法线轴的反射向量。需要注意的是这里对&lt;code&gt;lightDir&lt;/code&gt;向量进行了取反。&lt;code&gt;reflect&lt;/code&gt;函数要求第一个向量是从光源指向片段位置的向量，但是&lt;code&gt;lightDir&lt;/code&gt;当前正好相反，是从片段指向光源的，所以需要取反。第二个参数要求是一个法向量，所以提供的是已标准化的&lt;code&gt;norm&lt;/code&gt;向量。&lt;/p&gt;
&lt;p&gt;最后，计算镜面反射分量并加到最终结果中。先计算视线方向与反射方向的点乘，并确保它不是负值，然后取它的32次幂。这个32是高光的反光度(Shininess)。一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小，并且越亮。&lt;/p&gt;
&lt;h2 id=&#34;最终效果&#34;&gt;最终效果&lt;/h2&gt;
&lt;p&gt;首先，创建一个光源，为了方便起见，直接使用立方体作为光源，然后将其创建在原立方体的上方位置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glm::vec3 lightPos(1.2f, 1.0f, 2.0f);

glm::mat4 lightmodel;
lightmodel = glm::mat4();
lightmodel = glm::translate(lightmodel, lightPos);
lightmodel = glm::scale(lightmodel, glm::vec3(0.2f));

unsigned int VBO, VAO, lightVAO;
glGenVertexArrays(1, &amp;amp;lightVAO);
glBindVertexArray(lightVAO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，还需在game循环中绑定并绘制光源：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glBindVertexArray(lightVAO);
glDrawArrays(GL_TRIANGLES, 0, 36);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单的对图形的model矩阵进行改动，使其不断移动从而方便观察光照效果。&lt;/p&gt;
&lt;p&gt;最终效果如下：&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1693212974713.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1] https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/03%20Hello%20Window/&lt;/p&gt;
">[OpenGL入门教程] 10. 加入光照</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/oE7B7ZmLi/"" data-c="
          &lt;p&gt;在上一篇博客中提到了观察空间的概念，这是以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。&lt;/p&gt;
&lt;p&gt;为了移动摄像机的位置，我们是采取将整个场景按照反方向移动的办法。这样的方法比较简化，但是不太直观，并且如果我们想要更加精确的控制摄像机的位置，需要大量的设置。因此，可以将摄像机部分封装成一个类来进行控制。&lt;/p&gt;
&lt;h2 id=&#34;摄像机坐标系&#34;&gt;摄像机坐标系&lt;/h2&gt;
&lt;p&gt;要定义一个摄像机，需要它在世界空间中的位置、观察的方向、一个指向它右侧的向量以及一个指向它上方的向量。这实际上创建了一个三个单位轴相互垂直的、以摄像机的位置为原点的坐标系。&lt;/p&gt;
&lt;p&gt;摄像机位置很简单，就是希望摄像机处于的位置，用一个向量表示坐标即可。&lt;/p&gt;
&lt;p&gt;摄像机的方向指的是摄像机指向哪个方向。假设让摄像机指向场景原点：&lt;code&gt;(0, 0, 0)&lt;/code&gt;，那么用场景原点向量减去摄像机位置向量的结果就是摄像机的指向向量。注意，方向向量与摄像机实际指向的方向是正好相反的，因为是让场景方向移动来使产生移动摄像机的效果。&lt;/p&gt;
&lt;p&gt;右向量代表摄像机空间的x轴的正方向。为获取右向量需要先使用一个小技巧：先定义一个上向量。接下来把上向量和第二步得到的方向向量进行叉乘。两个向量叉乘的结果会同时垂直于两向量，因此会得到指向x轴正方向的那个向量（如果我们交换两个向量叉乘的顺序就会得到相反的指向x轴负方向的向量）&lt;/p&gt;
&lt;p&gt;最后把右向量和方向向量进行叉乘获取一个指向摄像机的正y轴向量。使用这些摄像机向量就可以使用&lt;code&gt;glm::lookAt&lt;/code&gt;创建一个&lt;code&gt;view&lt;/code&gt;矩阵。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glm::vec3 cameraPos   = glm::vec3(0.0f, 0.0f,  3.0f);
glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);
glm::vec3 cameraUp    = glm::vec3(0.0f, 1.0f,  0.0f);

view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cameraPos&lt;/code&gt;是摄像机位置，&lt;code&gt;cameraFront&lt;/code&gt;表示方向向量， &lt;code&gt;cameraUp&lt;/code&gt;表示向上的向量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;glm::LookAt&lt;/code&gt;函数需要一个位置、目标和上向量。目标是当前的位置加上我们刚刚定义的方向向量。这样能保证无论怎么移动，摄像机都会注视着目标方向。&lt;/p&gt;
&lt;h2 id=&#34;摄像机移动&#34;&gt;摄像机移动&lt;/h2&gt;
&lt;p&gt;在上面定义的基础上，通过键盘输入来改变这些向量，就可以实现移动摄像机的效果了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void processInput(GLFWwindow *window)
{
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
    glfwSetWindowShouldClose(window, true);

    float cameraSpeed =  2.5f * deltaTime; // adjust accordingly
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
        cameraPos += cameraSpeed * cameraFront;
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
        cameraPos -= cameraSpeed * cameraFront;
    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
        cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
        cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于每个电脑性能不同，会导致有些人可能会比其他人每秒绘制更多帧，也就是以更高的频率调用&lt;code&gt;processInput&lt;/code&gt;函数。结果就是，根据配置的不同，有些人可能移动很快，而有些人会移动很慢。&lt;/p&gt;
&lt;p&gt;为了保证程序在所有硬件上移动速度都一样，这里使用渲染时间来作为移动速度的基准。图形程序和游戏通常会跟踪一个时间差(Deltatime)变量，它储存了渲染上一帧所用的时间。&lt;/p&gt;
&lt;p&gt;这里将所有速度都去乘以&lt;code&gt;deltaTime&lt;/code&gt;值。如果&lt;code&gt;deltaTime&lt;/code&gt;很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。使用这种方法时，无论你的电脑快还是慢，摄像机的速度都会相应平衡，这样每个用户的体验就都一样了。&lt;/p&gt;
&lt;p&gt;可以通过两个全局变量&lt;code&gt;deltaTime&lt;/code&gt;和&lt;code&gt;lastFrame&lt;/code&gt;实现计算&lt;code&gt;deltaTime&lt;/code&gt;值，在循环中调用如下代码，每次记录并保存deltaTime。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;float currentFrame = glfwGetTime();
deltaTime = currentFrame - lastFrame;
lastFrame = currentFrame;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在处理键盘函数中，当按下WASD键的任意一个，摄像机的位置都会相应更新。&lt;/p&gt;
&lt;p&gt;如果向前或向后移动，就把位置向量加上或减去方向向量。&lt;/p&gt;
&lt;p&gt;如果向左右移动，使用叉乘来创建一个右向量，并沿着它相应移动就可以了。这里对右向量进行了标准化。如果没对这个向量进行标准化，最后的叉乘结果会根据&lt;code&gt;cameraFront&lt;/code&gt;变量返回大小不同的向量。这样就得根据摄像机的朝向不同加速或减速移动了，但如果进行了标准化移动就是匀速的。&lt;/p&gt;
&lt;p&gt;注意，为了使得这个函数发挥作用，应当在game循环中主动调用它。&lt;/p&gt;
&lt;h2 id=&#34;摄像机旋转&#34;&gt;摄像机旋转&lt;/h2&gt;
&lt;p&gt;为了能够改变视角，需要根据鼠标的输入改变cameraFront向量。这里，使用欧拉角来表示三维空间中的角度。&lt;/p&gt;
&lt;p&gt;欧拉角(Euler Angle)是可以表示3D空间中任何旋转的3个值，由莱昂哈德·欧拉(Leonhard Euler)在18世纪提出。一共有3种欧拉角：俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll)。每个欧拉角都有一个值来表示，把三个角结合起来就能够计算3D空间中任何的旋转向量。&lt;/p&gt;
&lt;p&gt;俯仰角是描述如何往上或往下看的角，偏航角表示往左和往右看的程度，滚转角代表如何翻滚摄像机。在这里，只使用俯仰角和偏航角，不去考虑反转。&lt;/p&gt;
&lt;p&gt;这两个角的计算并不复杂，这里不去介绍其数学知识，直接给出计算公式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;front.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw)); 
front.y = sin(glm::radians(pitch));
front.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着，通过鼠标（或手柄）移动获得这两个角度，水平的移动影响偏航角，竖直的移动影响俯仰角。原理很简单，储存上一帧鼠标的位置，在当前帧中我们当前计算鼠标位置与上一帧的位置相差多少。如果水平/竖直差别越大那么俯仰角或偏航角就改变越大，也就是摄像机需要移动更多的距离。&lt;/p&gt;
&lt;p&gt;首先，通过&lt;code&gt;glfwSetInputMode&lt;/code&gt;设置隐藏并捕捉光标位置。接着注册鼠标移动的回调函数，在这个函数中负责处理计算欧拉角并改变cameraFront向量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
glfwSetCursorPosCallback(window, mouse_callback);

void mouse_callback(GLFWwindow* window, double xpos, double ypos){
    if(firstMouse)
    {
        lastX = xpos;
        lastY = ypos;
        firstMouse = false;
    }

    float xoffset = xpos - lastX;
    float yoffset = lastY - ypos; 
    lastX = xpos;
    lastY = ypos;

    float sensitivity = 0.05;
    xoffset *= sensitivity;
    yoffset *= sensitivity;

    yaw   += xoffset;
    pitch += yoffset;

    if(pitch &amp;gt; 89.0f)
        pitch = 89.0f;
    if(pitch &amp;lt; -89.0f)
        pitch = -89.0f;

    glm::vec3 front;
    front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
    front.y = sin(glm::radians(pitch));
    front.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
    cameraFront = glm::normalize(front);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里使用了两个全局变量&lt;code&gt;lastX&lt;/code&gt;和&lt;code&gt;lastY&lt;/code&gt;来记录在程序中储存上一帧的鼠标位置。&lt;/p&gt;
&lt;p&gt;鼠标移动回调函数中，首先判断是否是第一次调用，获取初始位置。&lt;/p&gt;
&lt;p&gt;接着通过获取的鼠标位移来计算偏移角度，由于鼠标位移对应到角度中的值太大了，转向速度过快，因此为其添加一个灵敏度用于控制。&lt;/p&gt;
&lt;p&gt;最后改变欧拉角并使用改变后的欧拉角计算新的&lt;code&gt;cameraFront&lt;/code&gt;向量。&lt;/p&gt;
&lt;p&gt;注意，由于俯仰角在90度时视角会发生逆转，这里对其限制为-89到89的范围。这样能够保证用户只能看到天空或脚下，但是不能超越这个限制。&lt;/p&gt;
&lt;h2 id=&#34;摄像机缩放&#34;&gt;摄像机缩放&lt;/h2&gt;
&lt;p&gt;在之前的例子中介绍过视野或&lt;code&gt;fov&lt;/code&gt;定义了可以看到场景中多大的范围。当视野变小时，场景投影出来的空间就会减小，产生放大了的感觉。&lt;/p&gt;
&lt;p&gt;这里，按照一般使用鼠标滚轮来控制缩放。同样的，需要定义一个鼠标滚轮的回调函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glfwSetScrollCallback(window, scroll_callback);

void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
{
  if(fov &amp;gt;= 1.0f &amp;amp;&amp;amp; fov &amp;lt;= 90.0f)
    fov -= yoffset;
  if(fov &amp;lt;= 1.0f)
    fov = 1.0f;
  if(fov &amp;gt;= 90.0f)
    fov = 90.0f;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先，注册下鼠标滚轮的回调函数。&lt;/p&gt;
&lt;p&gt;这里使用一个全局变量&lt;code&gt;fov&lt;/code&gt;来记录视野范围。&lt;/p&gt;
&lt;p&gt;当滚动鼠标滚轮的时候，&lt;code&gt;yoffset&lt;/code&gt;值代表竖直滚动的大小。当&lt;code&gt;scroll_callback&lt;/code&gt;函数被调用后，改变全局变量&lt;code&gt;fov&lt;/code&gt;变量的内容。限制下缩放的范围以保证显示效果。&lt;/p&gt;
&lt;p&gt;相应的，在循环中设置每一帧的project矩阵：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;projection = glm::perspective(glm::radians(fov), 800.0f / 600.0f, 0.1f, 100.0f);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到这里，已经实现了所有的摄像机操作，获得了一个类似fps游戏中的摄像机了。&lt;/p&gt;
&lt;h2 id=&#34;封装成摄像机类&#34;&gt;封装成摄像机类&lt;/h2&gt;
&lt;p&gt;基本上而言，就是将上述的操作都抽象成接口，并将需要的数据定义成成员变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Camera.h
#pragma once

#include &amp;lt;glm/glm.hpp&amp;gt;
#include &amp;lt;glm/gtc/matrix_transform.hpp&amp;gt;
#include &amp;lt;glm/gtc/type_ptr.hpp&amp;gt;

#include &amp;lt;vector&amp;gt;

enum Camera_Movement {
    FORWARD,
    BACKWARD,
    LEFT,
    RIGHT
};
// Default camera values
const float YAW = -90.0f;
const float PITCH = 0.0f;
const float SPEED = 5.5f;
const float SENSITIVITY = 0.1f;
const float ZOOM = 45.0f;

class Camera
{
private:
    glm::vec3 Position;
    glm::vec3 Front;
    glm::vec3 Up;
    glm::vec3 Right;
    glm::vec3 WorldUp;

    // euler Angles
    float Yaw;
    float Pitch;
    // camera options
    float MovementSpeed;
    float MouseSensitivity;
    float Zoom;

    // calculates the front vector from the Camera&#39;s (updated) Euler Angles
    void updateCameraVectors();

public:

    Camera(glm::vec3 position = glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f), float yaw = YAW, float pitch = PITCH) : Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED), MouseSensitivity(SENSITIVITY), Zoom(ZOOM)
    {
        Position = position;
        WorldUp = up;
        Yaw = yaw;
        Pitch = pitch;
        updateCameraVectors();
    }
    // constructor with scalar values
    Camera(float posX, float posY, float posZ, float upX, float upY, float upZ, float yaw, float pitch) : Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED), MouseSensitivity(SENSITIVITY), Zoom(ZOOM)
    {
        Position = glm::vec3(posX, posY, posZ);
        WorldUp = glm::vec3(upX, upY, upZ);
        Yaw = yaw;
        Pitch = pitch;
        updateCameraVectors();
    }

    glm::mat4 GetViewMatrix();

    float Getzoom();

    void ProcessKeyboard(Camera_Movement direction, float deltaTime);
    
    void ProcessMouseMovement(float xoffset, float yoffset);

    void ProcessMouseScroll(float yoffset);
  
};


// Camera.cpp
#include &amp;quot;Camera.h&amp;quot;

void Camera::updateCameraVectors()
{
    // calculate the new Front vector
    glm::vec3 front;
    front.x = cos(glm::radians(Yaw)) * cos(glm::radians(Pitch));
    front.y = sin(glm::radians(Pitch));
    front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));
    Front = glm::normalize(front);
    // also re-calculate the Right and Up vector
    Right = glm::normalize(glm::cross(Front, WorldUp));  // normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement.
    Up = glm::normalize(glm::cross(Right, Front));
}

glm::mat4 Camera::GetViewMatrix()
{
    return glm::lookAt(Position, Position + Front, Up);
}

float Camera::Getzoom()
{
    return Zoom;
}

void Camera::ProcessKeyboard(Camera_Movement direction, float deltaTime)
{
    float velocity = MovementSpeed * deltaTime;
    if (direction == FORWARD)
        Position += Front * velocity;
    if (direction == BACKWARD)
        Position -= Front * velocity;
    if (direction == LEFT)
        Position -= Right * velocity;
    if (direction == RIGHT)
        Position += Right * velocity;
}

void Camera::ProcessMouseMovement(float xoffset, float yoffset)
{
    xoffset *= MouseSensitivity;
    yoffset *= MouseSensitivity;

    Yaw += xoffset;
    Pitch += yoffset;

    if (Pitch &amp;gt; 89.0f)
        Pitch = 89.0f;
    if (Pitch &amp;lt; -89.0f)
        Pitch = -89.0f;

    // update Front, Right and Up Vectors using the updated Euler angles
    updateCameraVectors();
}

void Camera::ProcessMouseScroll(float yoffset)
{
    Zoom -= (float)yoffset;
    if (Zoom &amp;lt; 1.0f)
        Zoom = 1.0f;
    if (Zoom &amp;gt; 90.0f)
        Zoom = 90.0f;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终效果如下：&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1693144963237.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1] https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/03%20Hello%20Window/&lt;/p&gt;
&lt;p&gt;[2] http://bit.ly/2lt7ccM&lt;/p&gt;
">[OpenGL入门教程] 9. 摄像机类</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/UQl_wdfkZ/"" data-c="
          &lt;p&gt;为了简化考虑，此前的图形都是2D的，现在我们要准备进入3D空间了。&lt;/p&gt;
&lt;p&gt;但是，在此之前，需要梳理下关于坐标空间的知识。&lt;/p&gt;
&lt;h2 id=&#34;坐标空间&#34;&gt;坐标空间&lt;/h2&gt;
&lt;p&gt;将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的。物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统。将物体的坐标变换到几个过渡坐标系的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易。比较重要的总共有5个不同的坐标系统：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部空间(或者称为物体空间)&lt;/li&gt;
&lt;li&gt;世界空间&lt;/li&gt;
&lt;li&gt;观察空间(或者称为视觉空间)&lt;/li&gt;
&lt;li&gt;裁剪空间&lt;/li&gt;
&lt;li&gt;屏幕空间&lt;br&gt;
这就是一个顶点在最终被转化为片段之前需要经历的所有不同状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。&lt;/p&gt;
&lt;p&gt;最开始，顶点坐标位于&lt;strong&gt;局部空间&lt;/strong&gt;，在这里它称为&lt;strong&gt;局部坐标&lt;/strong&gt;，接着它会变为&lt;strong&gt;世界坐标&lt;/strong&gt;，&lt;strong&gt;观察坐标&lt;/strong&gt;，&lt;strong&gt;裁剪坐标&lt;/strong&gt;，并最后以&lt;strong&gt;屏幕坐标&lt;/strong&gt;的形式结束：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。&lt;/li&gt;
&lt;li&gt;下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。&lt;/li&gt;
&lt;li&gt;接下来将世界坐标变换为观察空间坐标，&lt;strong&gt;使得每个坐标都是从摄像机或者说观察者的角度进行观察的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;坐标到达观察空间之后，需要将其投影到裁剪坐标。&lt;strong&gt;裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;最后，将裁剪坐标变换为屏幕坐标，这一步使用一个叫做&lt;strong&gt;视口变换&lt;/strong&gt;的过程。视口变换将位于-1.0到1.0范围的坐标变换到由&lt;code&gt;glViewport&lt;/code&gt;函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而为了将坐标从一个坐标系变换到另一个坐标系，需要用到几个变换矩阵，最重要的几个分别是：&lt;strong&gt;模型矩阵&lt;/strong&gt;、&lt;strong&gt;观察矩阵&lt;/strong&gt;以及&lt;strong&gt;投影矩阵&lt;/strong&gt;。从&lt;strong&gt;局部坐标到世界坐标&lt;/strong&gt;，通过&lt;strong&gt;模型矩阵&lt;/strong&gt;变换；从&lt;strong&gt;世界坐标到观察坐标&lt;/strong&gt;，通过&lt;strong&gt;观察矩阵&lt;/strong&gt;变换；从&lt;strong&gt;观察坐标到裁剪坐标&lt;/strong&gt;，通过&lt;strong&gt;投影矩阵&lt;/strong&gt;变换。&lt;/p&gt;
&lt;h3 id=&#34;局部坐标&#34;&gt;局部坐标&lt;/h3&gt;
&lt;p&gt;局部空间是指物体所在的坐标空间，即对象最开始所在的地方。你模型的所有顶点都是在局部空间中：它们相对于你的物体来说都是局部的。&lt;/p&gt;
&lt;p&gt;之前的例子中，一直使用的三角形的顶点是被设定在-0.5到0.5的坐标范围中，(0, 0)是它的原点。这些都是局部坐标。&lt;/p&gt;
&lt;h3 id=&#34;世界空间&#34;&gt;世界空间&lt;/h3&gt;
&lt;p&gt;世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。表示的是模型与模型之间的位置关系。该变换是由模型矩阵实现的。&lt;/p&gt;
&lt;p&gt;模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。&lt;/p&gt;
&lt;p&gt;可以将上一篇博客中最后使用的那个变换看作是一种模型矩阵。&lt;/p&gt;
&lt;h3 id=&#34;观察空间&#34;&gt;观察空间&lt;/h3&gt;
&lt;p&gt;观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。&lt;/p&gt;
&lt;p&gt;因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。&lt;/p&gt;
&lt;p&gt;这些组合在一起的变换通常存储在一个观察矩阵里，它被用来将世界坐标变换到观察空间。&lt;/p&gt;
&lt;h3 id=&#34;裁剪空间&#34;&gt;裁剪空间&lt;/h3&gt;
&lt;p&gt;在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。&lt;/p&gt;
&lt;p&gt;因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以正常来说会指定自己的坐标集并将它变换回标准化设备坐标系。&lt;/p&gt;
&lt;p&gt;为了将顶点坐标从观察变换到裁剪空间，需要定义一个投影矩阵，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。&lt;/p&gt;
&lt;p&gt;注意，如果只是图元（例如三角形）的一部分超出了裁剪体积，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。&lt;/p&gt;
&lt;p&gt;由投影矩阵创建的观察箱被称为平截头体，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到2D观察空间坐标）被称之为投影，因为使用投影矩阵能将3D坐标投影到很容易映射到2D的标准化设备坐标系中。&lt;/p&gt;
&lt;p&gt;一旦所有顶点被变换到裁剪空间，最终的操作——&lt;strong&gt;透视除法&lt;/strong&gt;将会执行，在这个过程中将位置向量的x，y，z分量分别除以向量的齐次w分量；&lt;strong&gt;透视除法是将4D裁剪空间坐标变换为3D标准化设备坐标的过程&lt;/strong&gt;。这一步会&lt;strong&gt;在每一个顶点着色器运行的最后被自动执行&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;正射投影&#34;&gt;正射投影&lt;/h4&gt;
&lt;p&gt;正射投影矩阵定义了一个类似立方体的平截头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定可见平截头体的宽、高和长度。&lt;/p&gt;
&lt;p&gt;在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体内的所有坐标将不会被裁剪掉。&lt;/p&gt;
&lt;p&gt;要创建一个正射投影矩阵，可以使用GLM的内置函数&lt;code&gt;glm::ortho&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的平截头体定义了可见的坐标，它由由宽、高、近平面和远平面所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。&lt;/p&gt;
&lt;p&gt;正射平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的w分量都没有进行改变；如果w分量等于1.0，透视除法则不会改变这个坐标。&lt;/p&gt;
&lt;p&gt;正射投影矩阵直接将坐标映射到2D平面中，即你的屏幕，但实际上一个直接的投影矩阵会产生不真实的结果，因为这个投影没有将透视(Perspective)考虑进去。所以还需要&lt;strong&gt;透视投影&lt;/strong&gt;矩阵来解决这个问题。&lt;/p&gt;
&lt;h4 id=&#34;透视投影&#34;&gt;透视投影&lt;/h4&gt;
&lt;p&gt;透视投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还修改了每个顶点坐标的&lt;code&gt;w&lt;/code&gt;值，从而使得离观察者越远的顶点坐标&lt;code&gt;w&lt;/code&gt;分量越大。被变换到裁剪空间的坐标都会在&lt;code&gt;-w&lt;/code&gt;到&lt;code&gt;w&lt;/code&gt;的范围之间（任何大于这个范围的坐标都会被裁剪掉）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;glm::perspective&lt;/code&gt;所做的其实就是创建了一个定义了可视空间的大平截头体，任何在这个平截头体以外的东西最后都不会出现在裁剪空间体积内，并且将会受到裁剪。一个透视平截头体可以被看作一个不均匀形状的箱子，在这个箱子内部的每个坐标都会被映射到裁剪空间上的一个点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数定义了fov的值，它表示的是视野(Field of View)，并且设置了观察空间的大小。如果想要一个真实的观察效果，它的值通常设置为45.0f。&lt;/li&gt;
&lt;li&gt;第二个参数设置了宽高比，由视口的宽除以高所得。&lt;/li&gt;
&lt;li&gt;第三和第四个参数设置了平截头体的近和远平面。通常设置近距离为0.1f，而远距离设为100.0f。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当使用正射投影时，每一个顶点坐标都会直接映射到裁剪空间中而不经过任何精细的透视除法（它仍然会进行透视除法，只是w分量没有被改变（它保持为1），因此没有起作用）。因为正射投影没有使用透视，远处的物体不会显得更小，所以产生奇怪的视觉效果。由于这个原因，正射投影主要用于二维渲染以及一些建筑或工程的程序，在这些场景中我们更希望顶点不会被透视所干扰。某些如 Blender 等进行三维建模的软件有时在建模时也会使用正射投影，因为它在各个维度下都更准确地描绘了每个物体。&lt;/p&gt;
&lt;h2 id=&#34;深度测试&#34;&gt;深度测试&lt;/h2&gt;
&lt;p&gt;OpenGL存储它的所有深度信息于一个Z缓冲中，也被称为深度缓冲。GLFW会自动为你生成这样一个缓冲（就像它也有一个颜色缓冲来存储输出图像的颜色）。&lt;/p&gt;
&lt;p&gt;深度值存储在每个片段里面（作为片段的z值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试，它是由OpenGL自动完成的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glEnable(GL_DEPTH_TEST);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过glEnable函数来开启深度测试。&lt;code&gt;glEnable&lt;/code&gt;和&lt;code&gt;glDisable&lt;/code&gt;函数允许我们启用或禁用某个OpenGL功能。这个功能会一直保持启用/禁用状态，直到另一个调用来禁用/启用它。&lt;/p&gt;
&lt;p&gt;这里通过指定&lt;code&gt;GL_DEPTH_TEST&lt;/code&gt;来开启深度测试。&lt;/p&gt;
&lt;p&gt;由于使用了深度测试，在每次渲染迭代之前也需要清除深度缓冲（否则前一帧的深度信息仍然保存在缓冲中）。就像清除颜色缓冲一样通过在glClear函数中指定&lt;code&gt;DEPTH_BUFFER_BIT&lt;/code&gt;位来清除深度缓冲：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3d绘图&#34;&gt;3D绘图&lt;/h2&gt;
&lt;p&gt;现在，知道了如何将3D坐标变换到2D空间，就可以开始真正的3D绘图了。&lt;/p&gt;
&lt;p&gt;首先，需要先定义一个3d物体，这里就以正方体为例，也就是把之前的面扩展成体了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;float vertices[] = {
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
     0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
    -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

    -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
};
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glm::mat4 model;
model = glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f));

glm::mat4 view;
// 注意，将矩阵向要进行移动场景的反方向移动。
view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));

glm::mat4 projection;
projection = glm::perspective(glm::radians(45.0f), screenWidth / screenHeight, 0.1f, 100.0f);

int Loc = glGetUniformLocation(ourShader.ID, &amp;quot;model&amp;quot;));
glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));
Loc = glGetUniformLocation(ourShader.ID, &amp;quot;projection&amp;quot;));
glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(projection));
Loc = glGetUniformLocation(ourShader.ID, &amp;quot;view&amp;quot;));
glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(view));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下一步创建一个模型矩阵。这个模型矩阵包含了位移、缩放与旋转操作，它们会被应用到所有物体的顶点上，以变换它们到全局的世界空间。这里定义了一个将其绕着x轴的旋转，使它看起来像放在地上一样。&lt;/p&gt;
&lt;p&gt;接下来需要创建一个观察矩阵。在场景里面稍微往后移动，以使得物体变成可见的（当在世界空间时，位于原点(0,0,0)）。将摄像机向后移动，和将整个场景向前移动是一样的。&lt;/p&gt;
&lt;p&gt;那么以相反于摄像机移动的方向移动整个场景，这就是观察矩阵所做的事。OpenGL是一个右手坐标系，所以是沿着z轴的正方向移动。这里通过将场景沿着z轴负方向平移来实现，它会给我们一种我们在往后移动的感觉。注意在标准化设备坐标系中OpenGL实际上使用的是左手坐标系（投影矩阵交换了左右手）。&lt;/p&gt;
&lt;p&gt;然后定义一个投影矩阵，这里声明了一个透视投影矩阵。&lt;/p&gt;
&lt;p&gt;接着，将定义好的变换作为uniform分别传入shader，并在shader代码中对应更改。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-GLSL&#34;&gt;uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    // 注意乘法要从右向左读
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后记得将绘图时的设置改为绘制数组，然后需要绘制36个顶点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;glDrawArrays(GL_TRIANGLES, 0, 36);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终效果如下：&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1693050952879.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1] https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/03%20Hello%20Window/&lt;/p&gt;
&lt;p&gt;[2] http://bit.ly/2lt7ccM&lt;/p&gt;
">[OpenGL入门教程] 8. 3D空间</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/S6nVvI07/"" data-c="
          &lt;p&gt;注意 如果无法理解向量，矩阵以及变换的概念，请先了解下简单的线性代数，对其有所了解即可&lt;/p&gt;
&lt;p&gt;OpenGL没有自带任何的矩阵和向量知识，但是我们可以使用已经做好了的数学库，专门为OpenGL量身定做的数学库，那就是GLM。&lt;/p&gt;
&lt;p&gt;GLM是OpenGL Mathematics的缩写，它是一个只有头文件的库，只需包含对应的头文件就行了，不用链接和编译。GLM可以在它们的网站上下载。把头文件的根目录复制到你的includes文件夹，然后你就可以使用这个库了。&lt;/p&gt;
&lt;p&gt;下载链接：https://github.com/g-truc/glm/releases/tag/0.9.8.5&lt;/p&gt;
&lt;h2 id=&#34;测试glm&#34;&gt;测试GLM&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;glm/glm.hpp&amp;gt;
#include &amp;lt;glm/gtc/matrix_transform.hpp&amp;gt;
#include &amp;lt;glm/gtc/type_ptr.hpp&amp;gt;

glm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f);
// 译注：下面就是矩阵初始化的一个例子，如果使用的是0.9.9及以上版本
// 下面这行代码就需要改为:
// glm::mat4 trans = glm::mat4(1.0f)
// 之后将不再进行提示
glm::mat4 trans;
trans = glm::translate(trans, glm::vec3(1.0f, 1.0f, 0.0f));
vec = trans * vec;
std::cout &amp;lt;&amp;lt; vec.x &amp;lt;&amp;lt; vec.y &amp;lt;&amp;lt; vec.z &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大多数需要的GLM的功能都可以从上面这3个头文件中找到&lt;/p&gt;
&lt;p&gt;这里先用GLM内建的向量类定义一个叫做&lt;code&gt;vec&lt;/code&gt;的向量作为将要被位移的向量，接下来定义一个&lt;code&gt;mat4&lt;/code&gt;类型的&lt;code&gt;trans&lt;/code&gt;，默认是一个4×4单位矩阵。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;glm::translate&lt;/code&gt;可以创建转化矩阵，第一个参数传入单位矩阵，第二个参数传入位移的向量。这里，传入了一个(1.0,1.0,0.0)的位移。&lt;/p&gt;
&lt;p&gt;最后把向量乘以位移矩阵并且输出最后的结果。&lt;/p&gt;
&lt;p&gt;自己口算可以知道，结果应该是(2,1,0)。&lt;/p&gt;
&lt;h2 id=&#34;对图形施加变化&#34;&gt;对图形施加变化&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glm::mat4 trans;
trans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0));
trans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5));

unsigned int transformLoc = glGetUniformLocation(ourShader.ID, &amp;quot;transform&amp;quot;);
glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(trans));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先，把图形在每个轴都缩放到0.5倍，然后沿z轴旋转90度。GLM希望它的角度是弧度制的(Radian)，所以要使用&lt;code&gt;glm::radians&lt;/code&gt;将角度转化为弧度。&lt;/p&gt;
&lt;p&gt;注意有纹理的那面矩形是在XY平面上的，所以需要把它绕着z轴旋转，即第三个参数。&lt;/p&gt;
&lt;p&gt;因为我们把这个矩阵传递给了GLM的每个函数，GLM会自动将矩阵相乘，返回的结果是一个包括了多个变换的变换矩阵。&lt;/p&gt;
&lt;p&gt;接着需要在主程序中添加一个uniform。首先查询uniform变量的地址，然后用有Matrix4fv后缀的glUniform函数把矩阵数据发送给着色器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数是uniform的位置值。&lt;/li&gt;
&lt;li&gt;第二个参数告诉OpenGL将要发送多少个矩阵，这里是1。&lt;/li&gt;
&lt;li&gt;第三个参数询问我们是否希望对传入矩阵进行转置，也就是说交换矩阵的行和列。OpenGL开发者通常使用一种内部矩阵布局，叫做列主序布局。GLM的默认布局就是列主序，所以并不需要转置矩阵，填GL_FALSE。&lt;/li&gt;
&lt;li&gt;最后一个参数是真正的矩阵数据，但是GLM并不是把它们的矩阵储存为OpenGL所希望接受的那种，因此要先用GLM的自带的函数value_ptr来变换这些数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-GLSL&#34;&gt;#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;

out vec2 TexCoord;

uniform mat4 transform;

void main()
{
    gl_Position = transform * vec4(aPos, 1.0f);
    TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应的，在shader代码中进行修改，引入转化矩阵，并将其左乘到坐标上。这样就可以完成一个缩放加旋转的变换了。&lt;/p&gt;
&lt;p&gt;进一步，可以在循环之中创建随时间变换的变换矩阵，从而使得图形可以旋转起来。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glm::mat4 trans;
trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));
trans = glm::rotate(trans, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终应该出现如下情况：&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1693038492275.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1] https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/03%20Hello%20Window/&lt;/p&gt;
&lt;p&gt;[2] http://bit.ly/2lt7ccM&lt;/p&gt;
">[OpenGL入门教程] 7. 使用GLM实现变换</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/zxSwANzNa/"" data-c="
          &lt;p&gt;纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节。可以理解为用一张带有图像的纸，覆盖包裹你的图形，这样你的图形看起来就有一个新的外表了。&lt;/p&gt;
&lt;p&gt;为了能够把纹理映射到图形上，需要指定图形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标，用来标明该从纹理图像的哪个部分采样（即采集片段颜色）。之后在图形的其它片段上进行片段插值。&lt;/p&gt;
&lt;h2 id=&#34;纹理坐标&#34;&gt;纹理坐标&lt;/h2&gt;
&lt;p&gt;纹理坐标在x和y轴上，范围为0到1之间（注意这里使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。&lt;/p&gt;
&lt;p&gt;纹理坐标看起来就像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;float texCoords[] = {
    0.0f, 0.0f, // 左下角
    1.0f, 0.0f, // 右下角
    0.5f, 1.0f // 上中
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里为三角形指定了3个纹理坐标点。三角形的左下角对应纹理的左下角，因此把三角形左下角顶点的纹理坐标设置为(0, 0)；三角形的上顶点对应于图片的上中位置所以把它的纹理坐标设置为(0.5, 1.0)；同理右下方的顶点设置为(1, 0)。&lt;/p&gt;
&lt;p&gt;只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。&lt;/p&gt;
&lt;p&gt;对纹理采样的解释非常宽松，它可以采用几种不同的插值方式。所以还需要告诉OpenGL该怎样对纹理采样。&lt;/p&gt;
&lt;h2 id=&#34;纹理环绕方式&#34;&gt;纹理环绕方式&lt;/h2&gt;
&lt;p&gt;纹理坐标的范围通常是从(0, 0)到(1, 1)，但是如果把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像，或者可以手动使用&lt;code&gt;glTexParameter*&lt;/code&gt;函数对单独的一个坐标轴设置（s、t、r（三维情况才有）它们和x、y、z是等价的）进行设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GL_REPEAT&lt;/code&gt;：         重复纹理图像。这也是对纹理的默认行为。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GL_MIRRORED_REPEAT&lt;/code&gt;：和&lt;code&gt;GL_REPEAT&lt;/code&gt;一样，但每次重复图片是镜像放置的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GL_CLAMP_TO_EDGE&lt;/code&gt;：  纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GL_CLAMP_TO_BORDER&lt;/code&gt;：超出的坐标为用户指定的边缘颜色。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;glTexParameter*&lt;/code&gt;的第一个参数指定了纹理目标；这里使用的是2D纹理，因此纹理目标是&lt;code&gt;GL_TEXTURE_2D&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第二个参数需要指定设置的选项与应用的纹理轴。这里打算配置的是&lt;code&gt;WRAP&lt;/code&gt;选项，并且分别指定S和T轴。&lt;/p&gt;
&lt;p&gt;最后一个参数需要传递一个环绕方式，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为&lt;code&gt;GL_MIRRORED_REPEAT&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果选择&lt;code&gt;GL_CLAMP_TO_BORDER&lt;/code&gt;选项，则还需要指定一个边缘的颜色。这需要使用&lt;code&gt;glTexParameter&lt;/code&gt;函数的&lt;code&gt;fv&lt;/code&gt;后缀形式，用&lt;code&gt;GL_TEXTURE_BORDER_COLOR&lt;/code&gt;作为它的选项，并且传递一个&lt;code&gt;float&lt;/code&gt;数组作为边缘的颜色值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;float borderColor[] = { 1.0f, 1.0f, 0.0f, 1.0f };
glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;纹理过滤&#34;&gt;纹理过滤&lt;/h2&gt;
&lt;p&gt;纹理坐标不依赖于分辨率，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素映射到纹理坐标。所谓纹理像素指的是图片概念中的像素点，注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。&lt;/p&gt;
&lt;p&gt;OpenGL也有对于纹理过滤的选项。纹理过滤有很多个选项，这里只介绍最重要的两种：&lt;code&gt;GL_NEAREST&lt;/code&gt;和&lt;code&gt;GL_LINEAR&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GL_NEAREST&lt;/code&gt;（也叫邻近过滤）是OpenGL默认的纹理过滤方式。当设置为&lt;code&gt;GL_NEAREST&lt;/code&gt;的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GL_LINEAR&lt;/code&gt;（也叫线性过滤）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大，返回的颜色是邻近像素的混合色。&lt;/p&gt;
&lt;p&gt;在一个很大的物体上应用一张低分辨率的纹理，&lt;code&gt;GL_NEAREST&lt;/code&gt;会产生颗粒状的图案，能够清晰看到组成纹理的像素，而&lt;code&gt;GL_LINEAR&lt;/code&gt;能够产生更平滑的图案，很难看出单个的纹理像素。&lt;code&gt;GL_LINEAR&lt;/code&gt;可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用&lt;code&gt;GL_NEAREST&lt;/code&gt;选项。&lt;/p&gt;
&lt;p&gt;当进行放大和缩小操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。使用&lt;code&gt;glTexParameter*&lt;/code&gt;函数为放大和缩小指定过滤方式。这和纹理环绕方式的设置差不多：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;多级渐远纹理&#34;&gt;多级渐远纹理&lt;/h2&gt;
&lt;p&gt;假设有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。&lt;/p&gt;
&lt;p&gt;由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。&lt;/p&gt;
&lt;p&gt;在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。&lt;/p&gt;
&lt;p&gt;OpenGL使用一种叫做&lt;strong&gt;多级渐远纹理&lt;/strong&gt;的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;glGenerateMipmaps&lt;/code&gt;函数来创建多级渐远纹理，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了。&lt;/p&gt;
&lt;p&gt;在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用&lt;code&gt;NEAREST&lt;/code&gt;和&lt;code&gt;LINEAR&lt;/code&gt;过滤&lt;br&gt;
。&lt;/p&gt;
&lt;p&gt;为了指定不同多级渐远纹理级别之间的过滤方式，可以使用下面四个选项中的一个代替原有的过滤方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GL_NEAREST_MIPMAP_NEAREST&lt;/code&gt;：使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GL_LINEAR_MIPMAP_NEAREST&lt;/code&gt;：使用最邻近的多级渐远纹理级别，并使用线性插值进行采样&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GL_NEAREST_MIPMAP_LINEAR&lt;/code&gt;：在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GL_LINEAR_MIPMAP_LINEAR&lt;/code&gt;：在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就像纹理过滤一样，可以使用&lt;code&gt;glTexParameteri&lt;/code&gt;将过滤方式设置为上面四种提到的方法之一。&lt;/p&gt;
&lt;p&gt;但是注意，一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个&lt;code&gt;GL_INVALID_ENUM&lt;/code&gt;错误代码。&lt;/p&gt;
&lt;h2 id=&#34;创建纹理&#34;&gt;创建纹理&lt;/h2&gt;
&lt;p&gt;上面介绍了这么多，终于可以到创建纹理的部分了。但是，在创建纹理之前，首先必须获取纹理。也就是说，如何将需要映射的2D图像加载进来呢？&lt;/p&gt;
&lt;h3 id=&#34;加载图片&#34;&gt;加载图片&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;stb_image.h&lt;/code&gt;是Sean Barrett的一个非常流行的单头文件图像加载库，它能够加载大部分流行的文件格式，并且能够很简单得整合到工程之中。下载地址：https://github.com/nothings/stb/blob/master/stb_image.h&lt;/p&gt;
&lt;p&gt;下载这一个头文件，将它加入工程，并另创建一个新的C++文件，通过定义STB_IMAGE_IMPLEMENTATION的宏定义，来启用它的静态版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define STB_IMAGE_IMPLEMENTATION
#include &amp;quot;stb_image.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过定义&lt;code&gt;STB_IMAGE_IMPLEMENTATION&lt;/code&gt;，预处理器会修改头文件，让其只包含相关的函数定义源码，等于是将这个头文件变为一个 &lt;code&gt;.cpp&lt;/code&gt; 文件了。&lt;/p&gt;
&lt;p&gt;接着在工程文件中引用该头文件，使用它的&lt;code&gt;stbi_load&lt;/code&gt;函数加载图片即可：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;stbi_set_flip_vertically_on_load(true);
int width, height, nrChannels;
unsigned char *data = stbi_load(&amp;quot;xx.jpg&amp;quot;, &amp;amp;width, &amp;amp;height, &amp;amp;nrChannels, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OpenGL要求y轴0.0坐标是在图片的底部的，但是图片的y轴0.0坐标通常在顶部。因此，一般而言，需要使用&lt;code&gt;stbi_set_flip_vertically_on_load&lt;/code&gt;对加载的图片进行反转。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stbi_load&lt;/code&gt;函数首先接受一个图像文件的位置作为输入。&lt;br&gt;
接下来它需要三个&lt;code&gt;int&lt;/code&gt;作为它的第二、第三和第四个参数，&lt;code&gt;stb_image.h&lt;/code&gt;将会用图像的宽度、高度和颜色通道的个数填充这三个变量。&lt;/p&gt;
&lt;h3 id=&#34;生成纹理&#34;&gt;生成纹理&lt;/h3&gt;
&lt;p&gt;和所有之前生成的OpenGL对象一样，纹理也是使用ID引用的。接着，绑定该纹理。然后使用载入的图片生成纹理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;unsigned int texture;
glGenTextures(1, &amp;amp;texture);
glBindTexture(GL_TEXTURE_2D, texture);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
glGenerateMipmap(GL_TEXTURE_2D);

stbi_image_free(data);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;glGenTextures&lt;/code&gt;函数首先需要输入生成纹理的数量，然后把它们储存在第二个参数的&lt;code&gt;unsigned int&lt;/code&gt;数组中（这里只有一个纹理）。&lt;/p&gt;
&lt;p&gt;图片纹理可以通过&lt;code&gt;glTexImage2D&lt;/code&gt;来生成，其参数如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数指定了纹理目标。设置为&lt;code&gt;GL_TEXTURE_2D&lt;/code&gt;意味着会生成与当前绑定的纹理对象在同一个目标上的纹理，因为目前操作的纹理对象就是&lt;code&gt;GL_TEXTURE_2D&lt;/code&gt;（任何绑定到&lt;code&gt;GL_TEXTURE_1D&lt;/code&gt;和&lt;code&gt;GL_TEXTURE_3D&lt;/code&gt;的纹理不会受到影响）。&lt;/li&gt;
&lt;li&gt;第二个参数为纹理指定多级渐远纹理的级别，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里填0，也就是基本级别。&lt;/li&gt;
&lt;li&gt;第三个参数告诉OpenGL希望把纹理储存为何种格式。这里的图像只有RGB值，因此把纹理储存为RGB值。&lt;/li&gt;
&lt;li&gt;第四个和第五个参数设置最终的纹理的宽度和高度。之前加载图像的时候储存了它们，所以使用对应的变量即可。&lt;/li&gt;
&lt;li&gt;下个参数应该总是被设为0（历史遗留的问题）。&lt;/li&gt;
&lt;li&gt;第七第八个参数定义了源图的格式和数据类型。这里使用RGB值加载这个图像，并把它们储存为char(byte)数组。&lt;/li&gt;
&lt;li&gt;最后一个参数是真正的图像数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当调用&lt;code&gt;glTexImage2D&lt;/code&gt;时，当前绑定的纹理对象就会被附加上纹理图像。然而，目前只有基本级别(Base-level)的纹理图像被加载了，如果要使用多级渐远纹理，必须手动设置所有不同的图像（不断递增第二个参数）。或者，直接在生成纹理之后调用&lt;code&gt;glGenerateMipmap&lt;/code&gt;。这会为当前绑定的纹理自动生成所有需要的多级渐远纹理。&lt;/p&gt;
&lt;p&gt;最后调用&lt;code&gt;stbi_image_free&lt;/code&gt;释放内存。&lt;/p&gt;
&lt;h3 id=&#34;应用纹理&#34;&gt;应用纹理&lt;/h3&gt;
&lt;p&gt;这里，准备使用一个矩形来展示纹理，因此需要更新一下顶点数组。采用两个三角形的来拼出一个正方形。&lt;/p&gt;
&lt;p&gt;同时，还需要指定纹理坐标，因此，还需要添加额外的属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;float vertices[] = {
//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -
     0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f,   // 右上
     0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f,   // 右下
    -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f,   // 左下
    -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f    // 左上
};

glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
glEnableVertexAttribArray(2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着改动着色器代码来接受纹理坐标：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-GLSL&#34;&gt;#shader vertex
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aColor;
layout (location = 2) in vec2 aTexCoord;

out vec3 ourColor;
out vec2 TexCoord;

void main()
{
    gl_Position = vec4(aPos, 1.0);
    ourColor = aColor;
    TexCoord = aTexCoord;
}

#shader fragment
#version 330 core
out vec4 FragColor;

in vec3 ourColor;
in vec2 TexCoord;

uniform sampler2D ourTexture;

void main()
{
    FragColor = texture(ourTexture, TexCoord);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;顶点着色器接受顶点坐标为一个顶点属性，并把坐标传给片段着色器。片段着色器接着把&lt;code&gt;TexCoord&lt;/code&gt;作为输入变量。&lt;/p&gt;
&lt;p&gt;GLSL有一个供纹理对象使用的内建数据类型，叫做采样器(Sampler)，它以纹理类型作为后缀，比如&lt;code&gt;sampler1D&lt;/code&gt;、&lt;code&gt;sampler3D&lt;/code&gt;，或在例子中的&lt;code&gt;sampler2D&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通过声明一个uniform sampler2D把一个纹理添加到片段着色器中，注意要把纹理赋值给这个uniform。默认情况下，OpenGL会激活纹理单元0，因此只有一个纹理时可以不设置。&lt;/p&gt;
&lt;p&gt;用GLSL内建的texture函数来采样纹理的颜色，它第一个参数是纹理采样器，第二个参数是对应的纹理坐标。texture函数会使用之前设置的纹理参数对相应的颜色值进行采样。这个片段着色器的输出就是纹理的（插值）纹理坐标上的(过滤后的)颜色。&lt;/p&gt;
&lt;p&gt;最后在调用glDrawElements之前绑定纹理，它会自动把纹理赋值给片段着色器的采样器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glBindTexture(GL_TEXTURE_2D, texture);
glBindVertexArray(VAO);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置完成，该图形应该显示如下：&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1692696339440.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;纹理单元&#34;&gt;纹理单元&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;glUniform1i&lt;/code&gt;可以给纹理采样器分配一个位置值，这样的话能够在一个片段着色器中设置多个纹理。&lt;/p&gt;
&lt;p&gt;一个纹理的位置值通常称为一个纹理单元。一个纹理的默认纹理单元是0，它是默认的激活纹理单元。&lt;/p&gt;
&lt;p&gt;纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器可以一次绑定多个纹理，只要首先激活对应的纹理单元。&lt;/p&gt;
&lt;p&gt;就像&lt;code&gt;glBindTexture&lt;/code&gt;一样，可以使用&lt;code&gt;glActiveTexture&lt;/code&gt;激活纹理单元，传入需要使用的纹理单元。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glActiveTexture(GL_TEXTURE0); // 在绑定纹理之前先激活纹理单元
glBindTexture(GL_TEXTURE_2D, texture);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;激活纹理单元之后，接下来的&lt;code&gt;glBindTexture&lt;/code&gt;函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元&lt;code&gt;GL_TEXTURE0&lt;/code&gt;默认总是被激活，所以在前面的例子里使用&lt;code&gt;glBindTexture&lt;/code&gt;的时候，无需激活任何纹理单元。&lt;/p&gt;
&lt;p&gt;OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从&lt;code&gt;GL_TEXTURE0&lt;/code&gt;到&lt;code&gt;GL_TEXTRUE15&lt;/code&gt;。&lt;strong&gt;它们都是按顺序定义的&lt;/strong&gt;，所以也可以通过&lt;code&gt;GL_TEXTURE0 + 8&lt;/code&gt;的方式获得&lt;code&gt;GL_TEXTURE8&lt;/code&gt;，这在需要循环一些纹理单元的时候会很有用。&lt;/p&gt;
&lt;p&gt;同样的，使用多个纹理时也需要定义多个uniform来接受。使用两个纹理的shaer代码如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-GLSL&#34;&gt;#version 330 core
...

uniform sampler2D texture1;
uniform sampler2D texture2;

void main()
{
    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终输出颜色现在是两个纹理的结合。GLSL内建的mix函数需要接受两个值作为参数，并对它们根据第三个参数进行线性插值。第三个参数代表第一个值的权重。&lt;/p&gt;
&lt;p&gt;为了使用第二个纹理（以及第一个），必须改变一点渲染流程，先绑定两个纹理到对应的纹理单元，然后&lt;strong&gt;定义哪个uniform采样器对应哪个纹理单元&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, texture1);
glActiveTexture(GL_TEXTURE1);
glBindTexture(GL_TEXTURE_2D, texture2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过使用glUniform1i设置每个采样器的方式告诉OpenGL每个着色器采样器属于哪个纹理单元。&lt;/p&gt;
&lt;p&gt;只需要设置一次即可，所以这个会放在渲染循环的前面:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glUniform1i(ourShader.GetUniformLocation(&amp;quot;texture1&amp;quot;), 0); // 手动设置
ourShader.SetUniform1i(&amp;quot;texture2&amp;quot;, 1); // 或者使用着色器类设置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过使用glUniform1i设置采样器，保证了每个uniform采样器对应着正确的纹理单元。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1] https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/03%20Hello%20Window/&lt;/p&gt;
&lt;p&gt;[2] http://bit.ly/2lt7ccM&lt;/p&gt;
">[OpenGL入门教程] 6. 添加纹理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/GoNtnobuG/"" data-c="
          &lt;p&gt;上一篇博客中，已经将着色器部分的代码抽象成了类，这使得主程序部分精简了许多，并且也更加便于管理和改动。这里，进一步将剩余的OpenGL的代码进行抽象，全部封装成类。&lt;/p&gt;
&lt;h2 id=&#34;顶点缓冲区类&#34;&gt;顶点缓冲区类&lt;/h2&gt;
&lt;p&gt;顶点缓冲区的类设计很简单，就是单纯的创建缓冲区和绑定。下面直接展示代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// VertexBuff.h
#pragma once

class VertexBuff
{
private:
	unsigned int m_RendererID;
public:
	VertexBuff(const void* data, unsigned int size);
	~VertexBuff();

	void Bind() const;
	void Unbind() const;
};


// VertexBuff.cpp
#include &amp;quot;VertexBuff.h&amp;quot;
#include &amp;quot;renderer.h&amp;quot;


VertexBuff::VertexBuff(const void* data, unsigned int size):m_RendererID(0)
{
    GLCall(glGenBuffers(1, &amp;amp;m_RendererID));
    GLCall(glBindBuffer(GL_ARRAY_BUFFER, m_RendererID));
    GLCall(glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW));
}

VertexBuff::~VertexBuff()
{
    GLCall(glDeleteBuffers(1, &amp;amp;m_RendererID));
}

void VertexBuff::Bind() const
{
    GLCall(glBindBuffer(GL_ARRAY_BUFFER, m_RendererID));
}

void VertexBuff::Unbind() const
{
    GLCall(glBindBuffer(GL_ARRAY_BUFFER, 0));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在构造函数中，调用之前主函数的构建代码来创建缓冲区，析构时自动删除，从而避免了我们的手动操作。&lt;/p&gt;
&lt;h2 id=&#34;索引缓冲区类&#34;&gt;索引缓冲区类&lt;/h2&gt;
&lt;p&gt;索引缓冲区类的设计与顶点缓冲区差不多，唯一的区别是顶点缓冲区直接传入顶点数据的大小，而索引缓冲区传入的是索引的个数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// IndexBuff.h
#pragma once
#include &amp;lt;iostream&amp;gt;

class IndexBuff
{
private:
	unsigned int m_RendererID;
	unsigned int m_Count;
public:
	IndexBuff(const unsigned int* data, unsigned int count);
	~IndexBuff();

	void Bind() const;
	void Unbind() const;

	unsigned int GetCount() const{
		return m_Count;
	}
};

// IndexBuff.cpp
#include &amp;quot;IndexBuff.h&amp;quot;
#include &amp;quot;renderer.h&amp;quot;


IndexBuff::IndexBuff(const unsigned int* data, unsigned int count):m_Count(count), m_RendererID(0)
{
    ASSERT(sizeof(GLuint) == sizeof(unsigned int));
    GLCall(glGenBuffers(1, &amp;amp;m_RendererID));
    GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_RendererID));
    GLCall(glBufferData(GL_ELEMENT_ARRAY_BUFFER, count * sizeof(unsigned int), data, GL_STATIC_DRAW));
}

IndexBuff::~IndexBuff()
{
    GLCall(glDeleteBuffers(1, &amp;amp;m_RendererID));
}

void IndexBuff::Bind() const
{
    GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_RendererID));
}

void IndexBuff::Unbind() const
{
    GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;顶点布局类&#34;&gt;顶点布局类&lt;/h2&gt;
&lt;p&gt;考虑到顶点数组类型必须指定其布局才能使用，因此，在创建顶点数组类之前，先创建一个顶点布局类用于指定布局。&lt;/p&gt;
&lt;p&gt;这个类比较简单，出于方便考虑，直接将定义写在了头文件中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#pragma once
#include &amp;lt;vector&amp;gt;
#include &amp;quot;renderer.h&amp;quot;
#include &amp;lt;GL/glew.h&amp;gt;

struct VertexBuffElement
{
	unsigned int type;
	unsigned int count;
	unsigned char normalized;

	VertexBuffElement(unsigned int type,unsigned int count, unsigned char normalized):type(type),count(count),normalized(normalized){}

	static unsigned int GetSizeOfType(unsigned int type) {
		switch (type)
		{
		case GL_FLOAT:			return 4;
		case GL_UNSIGNED_INT:	return 4;
		case GL_UNSIGNED_BYTE:	return 1;
		}
		ASSERT(false);
		return 0;
	}
};

class VertexBuffLayout {
private:
	std::vector&amp;lt;VertexBuffElement&amp;gt; m_Elements;
	unsigned int m_Stride;
public:
	VertexBuffLayout() :m_Stride(0){};

	template&amp;lt;typename T&amp;gt;
	void push(unsigned int count)
	{
		//static_assert(true,&amp;quot;1&amp;quot;);
	}

	template&amp;lt;&amp;gt;
	void push&amp;lt;float&amp;gt;(unsigned int count)
	{
		m_Elements.push_back({ GL_FLOAT,count,GL_FALSE });
		m_Stride += VertexBuffElement::GetSizeOfType(GL_FLOAT) * count;
	}

	template&amp;lt;&amp;gt;
	void push&amp;lt;unsigned int&amp;gt;(unsigned int count)
	{
		m_Elements.push_back({ GL_UNSIGNED_INT,count,GL_FALSE });
		m_Stride += VertexBuffElement::GetSizeOfType(GL_UNSIGNED_INT) * count;
	}

	template&amp;lt;&amp;gt;
	void push&amp;lt;unsigned char&amp;gt;(unsigned int count)
	{
		m_Elements.push_back({ GL_UNSIGNED_BYTE,count,GL_TRUE });
		m_Stride += VertexBuffElement::GetSizeOfType(GL_UNSIGNED_BYTE) * count;
	}

	unsigned int GetStride() const {
		return m_Stride;
	}

	const std::vector&amp;lt;VertexBuffElement&amp;gt;&amp;amp; GetElements() const {
		return m_Elements;
	}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个头文件中，首先创建了&lt;code&gt;VertexBuffElement&lt;/code&gt;类用于表示顶点属性，主要包括顶点属性的类型，元素个数以及是否进行归一化。&lt;/p&gt;
&lt;p&gt;接着创建布局类，布局类中用一个&lt;code&gt;vector&lt;/code&gt;储存所有的顶点属性，并使用一个变量记录步长。&lt;/p&gt;
&lt;p&gt;然后定义了插入布局的方法，为了统一地使用这种方法，将其定义为了函数模板，并为其实例化。每次添加属性时，同时累加步长。&lt;/p&gt;
&lt;p&gt;为了使用方便，还定义了接口对外返回步长和属性。&lt;/p&gt;
&lt;h2 id=&#34;顶点数组对象类&#34;&gt;顶点数组对象类&lt;/h2&gt;
&lt;p&gt;顶点数组对象主要负责构建一个顶点数组对象，并提供设置新的属性的功能即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// VertexArray.h
#pragma once
#include &amp;quot;VertexBuff.h&amp;quot;

class VertexBuffLayout;

class VertexArray{
private:
	unsigned int m_RendererID;
public:
	VertexArray();
	~VertexArray();

	void AddBuffer(const VertexBuff&amp;amp; vb, const VertexBuffLayout&amp;amp; layout);

	void Bind() const;
	void Unbind() const;
};

// VertexArray.cpp
#include &amp;quot;VertexArray.h&amp;quot;
#include &amp;quot;VertexBuffLayout.h&amp;quot;
#include &amp;quot;renderer.h&amp;quot;


VertexArray::VertexArray()
{
	GLCall(glGenVertexArrays(1, &amp;amp;m_RendererID));
	
}

VertexArray::~VertexArray()
{
	GLCall(glDeleteVertexArrays(1, &amp;amp;m_RendererID));
}

void VertexArray::AddBuffer(const VertexBuff&amp;amp; vb, const VertexBuffLayout&amp;amp; layout)
{
	Bind();
	vb.Bind();
	const auto&amp;amp; elements = layout.GetElements();
	unsigned int offset = 0;
	for (unsigned int i = 0; i &amp;lt; elements.size(); ++i) {
		const auto&amp;amp; e = elements[i];
		GLCall(glEnableVertexAttribArray(i));
		GLCall(glVertexAttribPointer(i, e.count, e.type, e.normalized , layout.GetStride(), (const void *)offset));
		offset += e.count * VertexBuffElement::GetSizeOfType(e.type);
	}
}

void VertexArray::Bind() const
{
	GLCall(glBindVertexArray(m_RendererID));
}

void VertexArray::Unbind() const
{
	GLCall(glBindVertexArray(0));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;AddBuffer&lt;/code&gt;中，依次取出布局中设置好的属性，设置属性指针并启用，然后附加对应偏移量，避免了手工执行的繁琐，也更不容易出错。&lt;/p&gt;
&lt;p&gt;其余部分与主程序中一致，直接拿过来用即可。&lt;/p&gt;
&lt;h2 id=&#34;渲染器类&#34;&gt;渲染器类&lt;/h2&gt;
&lt;p&gt;最后，将这些所有执行部分抽象成一个渲染器，它负责完成所有的OpenGL工作，渲染出对应图形，从而将整个过程封装起来。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// renderer.h
#pragma once

#include &amp;lt;GL/glew.h&amp;gt;
#include &amp;quot;VertexArray.h&amp;quot;
#include &amp;quot;IndexBuff.h&amp;quot;
#include &amp;quot;Shader.h&amp;quot;

#define ASSERT(x) if(!(x)) __debugbreak();
#define GLCall(x) GLClearError();\
        x;\
        ASSERT(GLPrintError(#x,__FILE__,__LINE__))

void GLClearError();

bool GLPrintError(const char* func_name, const char* file, int line); 

class Renderer {
public:
    void draw(const VertexArray&amp;amp; va, const IndexBuff&amp;amp; ib, const Shader &amp;amp;shader) const;
    void clear() const;
};

// renderer.cpp
#include &amp;quot;renderer.h&amp;quot;

#include &amp;lt;iostream&amp;gt;

void GLClearError() {
    while (glGetError() != GL_NO_ERROR);  //GL_NO_ERROR = 0
}

bool GLPrintError(const char* func_name, const char* file, int line) {
    while (GLenum error = glGetError()) {  //因为 GL_NO_ERROR = 0， 故循环可以写成这个形式
        std::cout &amp;lt;&amp;lt; &amp;quot;[OPENGL Error] (&amp;quot; &amp;lt;&amp;lt; error &amp;lt;&amp;lt; &amp;quot;): &amp;quot; &amp;lt;&amp;lt; func_name &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; file &amp;lt;&amp;lt; &amp;quot;:&amp;quot; &amp;lt;&amp;lt; line &amp;lt;&amp;lt; std::endl;
        return false;
    }
    return true;
}

void Renderer::draw(const VertexArray&amp;amp; va, const IndexBuff&amp;amp; ib, const Shader&amp;amp; shader) const
{
    shader.Bind();
    va.Bind();
    ib.Bind();
    GLCall(glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_INT, nullptr));
}

void Renderer::clear() const
{
    glClearColor(0.1f, 0.2f, 0.3f, 1.0f);
    GLCall(glClear(GL_COLOR_BUFFER_BIT));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里渲染器目前只负责调用前面构造好的类，绑定好并执行绘画，以及负责清除上次的画面。&lt;/p&gt;
&lt;p&gt;到这，已经将所有的OpenGL代码统一封装成类了，后续使用只需要调用这些封装好的类即可。当然，后续随着功能的增多，这些类也还会扩展，但是大体结构是这样的。&lt;/p&gt;
&lt;p&gt;这样抽象以后，目前主程序的代码已经非常精简了。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1] https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/03%20Hello%20Window/&lt;/p&gt;
&lt;p&gt;[2] http://bit.ly/2lt7ccM&lt;/p&gt;
">[OpenGL入门教程] 5. 统一进行类封装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/o_5GuAA5l/"" data-c="
          &lt;p&gt;着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。&lt;/p&gt;
&lt;p&gt;从基本意义上来说，着色器只是一种把输入转化为输出的程序。&lt;/p&gt;
&lt;h2 id=&#34;着色器结构&#34;&gt;着色器结构&lt;/h2&gt;
&lt;p&gt;一个典型的着色器有下面的结构：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-GLSL&#34;&gt;#version version_number
in type in_variable;
in type in_variable_2;

out type out_variable;

uniform type uniform_1;

int main()
{
  // 处理输入并进行一些图形操作
  ...
  // 输出处理过的结果到输出变量
  out_variable_name = stuff_we_processed;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;着色器的开头总是要声明版本，接着是输入和输出变量、&lt;code&gt;uniform&lt;/code&gt;和&lt;code&gt;main&lt;/code&gt;函数。每个着色器的入口点都是&lt;code&gt;main&lt;/code&gt;函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;uniform&lt;/code&gt;是一种从CPU中的应用向GPU中的着色器发送数据的方式，但&lt;code&gt;uniform&lt;/code&gt;和顶点属性有些不同。首先，&lt;code&gt;uniform&lt;/code&gt;是全局的，意味着&lt;code&gt;uniform&lt;/code&gt;变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把&lt;code&gt;uniform&lt;/code&gt;值设置成什么，&lt;code&gt;uniform&lt;/code&gt;会一直保存它们的数据，直到它们被重置或更新。&lt;/p&gt;
&lt;p&gt;可以在一个着色器中添加&lt;code&gt;uniform&lt;/code&gt;关键字至类型和变量名前来声明一个GLSL的&lt;code&gt;uniform&lt;/code&gt;。接着就可以在着色器中使用新声明的&lt;code&gt;uniform&lt;/code&gt;了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-GLSL&#34;&gt;#version 330 core
out vec4 FragColor;

uniform vec4 ourColor; 

void main()
{
    FragColor = ourColor;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里在片段着色器中声明了一个&lt;code&gt;uniform&lt;/code&gt;是&lt;code&gt;vec4&lt;/code&gt;类型的&lt;code&gt;ourColor&lt;/code&gt;，并把片段着色器的输出颜色设置为uniform值的内容。&lt;/p&gt;
&lt;p&gt;因为&lt;code&gt;uniform&lt;/code&gt;是全局变量，可以在任何着色器中定义它们，而无需通过顶点着色器作为中介。顶点着色器中不需要这个&lt;code&gt;uniform&lt;/code&gt;，所以不用在那里定义它。&lt;/p&gt;
&lt;p&gt;为了向这个&lt;code&gt;uniform&lt;/code&gt;中传递数据，需要在CPU程序中获取到该属性的索引，然后更新其值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int vertexColorLocation = glGetUniformLocation(shaderProgram, &amp;quot;ourColor&amp;quot;);
glUseProgram(shaderProgram);
glUniform4f(vertexColorLocation, 0.0f, 0.5f, 0.0f, 1.0f);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;glGetUniformLocation&lt;/code&gt;可以查询&lt;code&gt;uniform&lt;/code&gt;的位置值。为查询函数提供着色器程序和&lt;code&gt;uniform&lt;/code&gt;的名字。如果&lt;code&gt;glGetUniformLocation&lt;/code&gt;返回&lt;code&gt;-1&lt;/code&gt;就代表没有找到这个位置值。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;glUniform4f&lt;/code&gt;函数可以设置vec4的float类型的&lt;code&gt;uniform&lt;/code&gt;值。类似的也有&lt;code&gt;glUniform2i&lt;/code&gt;对应vec2的int数组的&lt;code&gt;uniform&lt;/code&gt;等。注意，查询&lt;code&gt;uniform&lt;/code&gt;地址不要求你之前使用过着色器程序，但是更新一个&lt;code&gt;uniform&lt;/code&gt;之前你必须先使用程序（调用&lt;code&gt;glUseProgram&lt;/code&gt;），因为它是在当前激活的着色器程序中设置&lt;code&gt;uniform&lt;/code&gt;的。&lt;/p&gt;
&lt;h3 id=&#34;向量&#34;&gt;向量&lt;/h3&gt;
&lt;p&gt;在顶点着色器中，每个输入变量也叫&lt;strong&gt;顶点属性&lt;/strong&gt;(Vertex Attribute)。我们能声明的&lt;strong&gt;顶点属性&lt;/strong&gt;是有上限的，它一般由硬件来决定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OpenGL确保至少有16个包含4分量的顶点属性可用&lt;/strong&gt;，但是有些硬件或许允许更多的顶点属性，可以通过&lt;code&gt;glGetIntegerv&lt;/code&gt;函数查询&lt;code&gt;GL_MAX_VERTEX_ATTRIBS&lt;/code&gt;来获取具体的上限。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;amp;nrAttributes);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GLSL中包含C等其它语言大部分的默认基础数据类型：&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;double&lt;/code&gt;、&lt;code&gt;uint&lt;/code&gt;和&lt;code&gt;bool&lt;/code&gt;,，以及两种容器类型向量(Vector)和矩阵(Matrix)。&lt;/p&gt;
&lt;p&gt;GLSL中的向量是一个可以包含有2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。默认的&lt;code&gt;vecn&lt;/code&gt;表示包含&lt;code&gt;n&lt;/code&gt;个&lt;code&gt;float&lt;/code&gt;分量的默认向量，对应的有&lt;code&gt;bvecn&lt;/code&gt;表示包含&lt;code&gt;n&lt;/code&gt;个&lt;code&gt;bool&lt;/code&gt;分量的向量，&lt;code&gt;ivecn&lt;/code&gt;表示包含&lt;code&gt;n&lt;/code&gt;个&lt;code&gt;int&lt;/code&gt;分量的向量等。可以分别使用&lt;code&gt;.x&lt;/code&gt;、&lt;code&gt;.y&lt;/code&gt;、&lt;code&gt;.z&lt;/code&gt;和&lt;code&gt;.w&lt;/code&gt;来获取它们的第1、2、3、4个分量。&lt;/p&gt;
&lt;h3 id=&#34;输入输出&#34;&gt;输入输出&lt;/h3&gt;
&lt;p&gt;GLSL定义了&lt;code&gt;in&lt;/code&gt;和&lt;code&gt;out&lt;/code&gt;关键字，每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。所以，如果打算从一个着色器向另一个着色器发送数据，&lt;strong&gt;必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入&lt;/strong&gt;。&lt;strong&gt;当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起&lt;/strong&gt;，它们之间就能发送数据了（这是在链接程序对象时完成的）。&lt;/p&gt;
&lt;p&gt;顶点着色器的输入特殊在，它从顶点数据中直接接收输入。为了定义顶点数据该如何管理，使用&lt;code&gt;location&lt;/code&gt;这一元数据指定输入变量，这样才可以在CPU上配置顶点属性。例如前面使用过的&lt;code&gt;layout (location = 0)&lt;/code&gt;，顶点着色器需要为它的输入提供一个额外的&lt;code&gt;layout&lt;/code&gt;标识。&lt;/p&gt;
&lt;p&gt;而片段着色器需要一个&lt;code&gt;vec4&lt;/code&gt;颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。如果在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。&lt;/p&gt;
&lt;h2 id=&#34;编写着色器类&#34;&gt;编写着色器类&lt;/h2&gt;
&lt;p&gt;有了上面的了解，目前已经可以成功地通过着色器来构建我们的图形了。但是每次更改都要改动一大堆代码，它们分布在整个程序中，每次相当麻烦。并且，目前的程序是以字符串形式写在程序里的，这显然是不符合需求的，应该改为从文件中读取。&lt;/p&gt;
&lt;p&gt;基于这些需求，可以将着色器部分抽象成一个类，对外提供这些接口，从而便于管理和改动。&lt;/p&gt;
&lt;p&gt;下面是着色器类的头文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#pragma once
#include &amp;lt;string&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;GL/glew.h&amp;gt;
#include &amp;lt;fstream&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;unordered_map&amp;gt;

struct ShaderProgramSource
{
	std::string VertexSource;
	std::string FragmentSource;
};

class Shader
{
private:
	unsigned int m_RendererID;
	std::string m_file;
	std::unordered_map&amp;lt;std::string, int&amp;gt; m_location_memory;

	int GetUniformLocation(const std::string&amp;amp; name);
	ShaderProgramSource ParseShader();
	unsigned int compile_shader(const std::string&amp;amp; source, unsigned int type);
	unsigned int create_shader(const std::string&amp;amp; vertexShader, const std::string&amp;amp; fragmentShader);
public:
	Shader(const std::string&amp;amp; filename);
	~Shader();

	void Bind() const;
	void Unbind() const;

	// set uniforms
	void SetUniform4f(const std::string&amp;amp; name, float v0, float v1, float v2, float v3);

	void SetUniform1i(const std::string&amp;amp; name, int value);

	void SetUniform1f(const std::string&amp;amp; name, float value);

};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先着色器类需要储存着色器程序的ID，它的构造器需要顶点和片段着色器源代码的文件路径，这样我们就可以把源码的文本文件储存在硬盘上了。其次，为了方便调试，这里将文件名也作为变量储存了。&lt;/p&gt;
&lt;p&gt;然后是如何读取和设置程序，这里将顶点着色器和片段着色器内容放在同一个文件中，因此需要一个额外的解析工作。其余部分与之前类似，将其放进函数中即可。为了方便起见，提供了设置Uniform的方法和绑定解绑的方法。&lt;/p&gt;
&lt;p&gt;下面是具体的实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;quot;Shader.h&amp;quot;
#include &amp;quot;renderer.h&amp;quot;

int Shader::GetUniformLocation(const std::string&amp;amp; name)
{
    if (m_location_memory.find(name) != m_location_memory.end()) {
        return m_location_memory[name];
    }
    GLCall(int location = glGetUniformLocation(m_RendererID, name.c_str()));
    m_location_memory[name] = location;
	return location;
}

Shader::Shader(const std::string&amp;amp; filename):m_file(filename),m_RendererID (0)
{
    GLCall(ShaderProgramSource source = ParseShader());
    m_RendererID = create_shader(source.VertexSource, source.FragmentSource);
}

Shader::~Shader()
{
    GLCall(glDeleteProgram(m_RendererID));
}


void Shader::Bind() const
{
    GLCall(glUseProgram(m_RendererID));
}

void Shader::Unbind() const
{
    GLCall(glUseProgram(0));
}

ShaderProgramSource Shader::ParseShader()
{
    std::ifstream file(m_file);

    enum class ShaderType
    {
        NONE = -1, VERTEX = 0, FRAGMENT = 1
    };
    std::stringstream ss[2];
    std::string line;
    ShaderType type = ShaderType::NONE;
    while (getline(file, line)) {
        if (line.find(&amp;quot;#shader&amp;quot;) != std::string::npos)
        {
            if (line.find(&amp;quot;vertex&amp;quot;) != std::string::npos)
            {
                type = ShaderType::VERTEX;
            }
            else if (line.find(&amp;quot;fragment&amp;quot;) != std::string::npos)
            {
                type = ShaderType::FRAGMENT;
            }
        }
        else {
            ss[(int)type] &amp;lt;&amp;lt; line &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
    }
    return { ss[0].str(),ss[1].str() };
}

void Shader::SetUniform4f(const std::string&amp;amp; name, float v0, float v1, float v2, float v3)
{
    int location = GetUniformLocation(name);
    ASSERT(location != -1);
    GLCall(glUniform4f(location, v0, v1, v2, v3));
}

void Shader::SetUniform1i(const std::string&amp;amp; name, int value)
{
    int location = GetUniformLocation(name);
    ASSERT(location != -1);
    GLCall(glUniform1i(location, value));
}

void Shader::SetUniform1f(const std::string&amp;amp; name, float value)
{
    int location = GetUniformLocation(name);
    ASSERT(location != -1);
    GLCall(glUniform1f(location, value));
}

unsigned int Shader::compile_shader(const std::string&amp;amp; source, unsigned int type)
{
    unsigned int id = glCreateShader(type);
    const char* src = source.c_str();

    glShaderSource(id, 1, &amp;amp;src, nullptr);
    glCompileShader(id);

    int result;
    glGetShaderiv(id, GL_COMPILE_STATUS, &amp;amp;result);
    if (result == GL_FALSE)
    {
        int length;
        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &amp;amp;length);
        char* message = (char*)alloca(sizeof(char) * (length));
        glGetShaderInfoLog(id, length, &amp;amp;length, message);
        std::cout &amp;lt;&amp;lt; (type == GL_VERTEX_SHADER ? &amp;quot;Vertex&amp;quot; : &amp;quot;&amp;quot;) &amp;lt;&amp;lt; &amp;quot; shader编译失败&amp;quot; &amp;lt;&amp;lt; std::endl;
        std::cout &amp;lt;&amp;lt; message &amp;lt;&amp;lt; std::endl;
        glDeleteShader(id);
        return 0;
    }

    return id;
}

unsigned int Shader::create_shader(const std::string&amp;amp; vertexShader, const std::string&amp;amp; fragmentShader)
{
    unsigned int program = glCreateProgram();
    unsigned int vs = compile_shader(vertexShader, GL_VERTEX_SHADER);
    unsigned int fs = compile_shader(fragmentShader, GL_FRAGMENT_SHADER);

    glAttachShader(program, vs);
    glAttachShader(program, fs);

    glLinkProgram(program);

    glValidateProgram(program);

    glDeleteShader(vs);
    glDeleteShader(fs);

    return program;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个renderer.h是自定义的一个头文件，中定义了一个错误检测的宏定义&lt;code&gt;GLCall&lt;/code&gt;，其功能就是如果某个函数运行出错就会打印错误码和行号。如果不使用的话，直接去掉即可。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1] https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/03%20Hello%20Window/&lt;/p&gt;
&lt;p&gt;[2] http://bit.ly/2lt7ccM&lt;/p&gt;
">[OpenGL入门教程] 4. 构造着色器类</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/pHN2a_SYA/"" data-c="
          &lt;h2 id=&#34;图形渲染管线&#34;&gt;图形渲染管线&lt;/h2&gt;
&lt;p&gt;在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。&lt;/p&gt;
&lt;p&gt;3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线管理的。&lt;br&gt;
图形渲染管线（Graphics Pipeline，大多译为管线），实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。&lt;/p&gt;
&lt;p&gt;图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。&lt;/p&gt;
&lt;p&gt;请注意，2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。&lt;/p&gt;
&lt;p&gt;图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。在GPU中执行，用于处理数据的程序叫做&lt;strong&gt;着色器&lt;/strong&gt;(Shader)。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, &lt;strong&gt;GLSL&lt;/strong&gt;)写成的。&lt;/p&gt;
&lt;p&gt;图形渲染管线包含很多部分，每个部分都将在转换顶点数据到最终像素这一过程中处理各自特定的阶段。具体流程如下图所示。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1692337953809.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶点数据：顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何想用的数据。这是绘图前需要准备好的。&lt;/li&gt;
&lt;li&gt;顶点着色器：图形渲染管线的第一个部分，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理。&lt;/li&gt;
&lt;li&gt;图元装配：将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状。图元装配阶段的输出会传递给几何着色器。&lt;/li&gt;
&lt;li&gt;几何着色器：几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。上图中，它生成了另一个三角形。几何着色器的输出会被传入光栅化阶段。&lt;/li&gt;
&lt;li&gt;光栅化：它会把图元映射为最终屏幕上相应的像素，生成供片段着色器使用的片段。&lt;/li&gt;
&lt;li&gt;片段着色器：其主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。在片段着色器运行之前会执行裁切。裁切会丢弃超出视图以外的所有像素，用来提升执行效率。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。&lt;/li&gt;
&lt;li&gt;Alpha测试和混合：在所有对应颜色值确定以后，最终的对象将会被传到Alpha测试和混合阶段。该阶段检测片段的对应的深度（和模板(Stencil)）值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于大多数场合，我们只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。&lt;/p&gt;
&lt;h2 id=&#34;顶点数据&#34;&gt;顶点数据&lt;/h2&gt;
&lt;p&gt;OpenGL是一个3D图形库，所以在OpenGL中我们指定的所有坐标都是3D坐标（x、y和z）。&lt;/p&gt;
&lt;p&gt;OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它。所有在这个范围内的坐标叫做标准化设备坐标，此范围内的坐标最终显示在屏幕上，而在这个范围以外的坐标则不会显示。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;float vertices[] = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里构造了一个&lt;code&gt;float&lt;/code&gt;数组，以标准化设备坐标的形式对应指定了三个顶点的3D位置。&lt;/p&gt;
&lt;p&gt;为了构造一个2D的三角形，这里的每个顶点的&lt;code&gt;z&lt;/code&gt;坐标都设置为&lt;code&gt;0&lt;/code&gt;，保证深度一致，从而绘制一个2D图形。&lt;/p&gt;
&lt;p&gt;通过使用由&lt;code&gt;glViewport&lt;/code&gt;函数提供的数据，进行&lt;strong&gt;视口变换&lt;/strong&gt;，&lt;strong&gt;标准化设备坐标&lt;/strong&gt;会变换为&lt;strong&gt;屏幕空间坐标&lt;/strong&gt;。所得的&lt;strong&gt;屏幕空间坐标&lt;/strong&gt;又会被变换为&lt;strong&gt;片段&lt;/strong&gt;输入到&lt;strong&gt;片段着色器中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;与通常的屏幕坐标不同，标准化设备坐标中y轴正方向为向上，(0, 0)坐标是这个图像的中心，而不是左上角。&lt;/p&gt;
&lt;h2 id=&#34;顶点缓冲对象&#34;&gt;顶点缓冲对象&lt;/h2&gt;
&lt;p&gt;定义这样的顶点数据以后，把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。顶点着色器会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。&lt;/p&gt;
&lt;p&gt;通过顶点缓冲对象(Vertex Buffer Objects, VBO)可以管理这个内存，它会在GPU内存（显存）中储存大量顶点。&lt;strong&gt;使用这些缓冲对象的好处是可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次&lt;/strong&gt;。从CPU把数据发送到显卡相对较慢，所以只要可能都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;unsigned int VBO;
glGenBuffers(1, &amp;amp;VBO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);  
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基本上而言，使用openGL对象都需要为其绑定一个独一无二的ID。在这里，通过&lt;code&gt;glGenBuffers&lt;/code&gt;函数和一个缓冲ID来生成一个&lt;code&gt;VBO&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;OpenGL有很多缓冲对象类型，顶点缓冲对象的缓冲类型是&lt;code&gt;GL_ARRAY_BUFFER&lt;/code&gt;。OpenGL允许同时绑定多个缓冲，只要它们是不同的缓冲类型。使用&lt;code&gt;glBindBuffer&lt;/code&gt;函数把新创建的缓冲绑定到&lt;code&gt;GL_ARRAY_BUFFER&lt;/code&gt;目标上。&lt;/p&gt;
&lt;p&gt;绑定完成后，使用的任何在GL_ARRAY_BUFFER目标上的缓冲调用都会用来配置当前绑定的缓冲(VBO)。&lt;/p&gt;
&lt;p&gt;然后调用&lt;code&gt;glBufferData&lt;/code&gt;函数，它会把之前定义的顶点数据复制到缓冲的内存中。&lt;code&gt;glBufferData&lt;/code&gt;是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到&lt;code&gt;GL_ARRAY_BUFFER&lt;/code&gt;目标上。&lt;/li&gt;
&lt;li&gt;第二个参数指定传输数据的大小(以字节为单位)；用一个简单的&lt;code&gt;sizeof&lt;/code&gt;计算出顶点数据大小就行。&lt;/li&gt;
&lt;li&gt;第三个参数是希望发送的实际数据。&lt;/li&gt;
&lt;li&gt;第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GL_STATIC_DRAW&lt;/code&gt; ：数据不会或几乎不会改变。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GL_DYNAMIC_DRAW&lt;/code&gt;：数据会被改变很多。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GL_STREAM_DRAW&lt;/code&gt; ：数据每次绘制时都会改变。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，绘制的是一个静态的三角形，每次渲染调用时都保持原样，所以它的使用类型最好是&lt;code&gt;GL_STATIC_DRAW&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是&lt;code&gt;GL_DYNAMIC_DRAW&lt;/code&gt;或&lt;code&gt;GL_STREAM_DRAW&lt;/code&gt;，这样就能确保显卡把数据放在能够高速写入的内存部分。&lt;/p&gt;
&lt;h2 id=&#34;顶点着色器&#34;&gt;顶点着色器&lt;/h2&gt;
&lt;p&gt;顶点着色器(Vertex Shader)是几个可编程着色器中的一个。如果打算做渲染的话，现代OpenGL需要至少设置一个顶点着色器和一个片段着色器。&lt;/p&gt;
&lt;p&gt;下面给出一个简单的顶点着色器的源代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-GLSL&#34;&gt;#version 330 core
layout (location = 0) in vec3 aPos;

void main()
{
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GLSL看起来很像C语言。每个着色器都起始于一个版本声明。GLSL版本号和OpenGL的版本是匹配的（比如说GLSL 420版本对应于OpenGL 4.2）。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;in&lt;/code&gt;关键字，可以在顶点着色器中声明所有的输入顶点属性。现在只关心位置数据，所以只需要一个顶点属性。&lt;/p&gt;
&lt;p&gt;GLSL有一个向量数据类型，它包含1到4个&lt;code&gt;float&lt;/code&gt;分量，包含的数量可以从它的后缀数字看出来。&lt;/p&gt;
&lt;p&gt;由于每个顶点都有一个3D坐标，就创建一个&lt;code&gt;vec3&lt;/code&gt;输入变量&lt;code&gt;aPos&lt;/code&gt;。通过&lt;code&gt;layout (location = 0)&lt;/code&gt;设定了输入变量的位置值。&lt;/p&gt;
&lt;p&gt;在GLSL中一个向量有最多4个分量，每个分量值都代表空间中的一个坐标，它们可以通过&lt;code&gt;vec.x&lt;/code&gt;、&lt;code&gt;vec.y&lt;/code&gt;、&lt;code&gt;vec.z&lt;/code&gt;和&lt;code&gt;vec.w&lt;/code&gt;来获取。注意&lt;code&gt;vec.w&lt;/code&gt;分量不是用作表达空间中的位置的，而是用在所谓透视除法上。&lt;/p&gt;
&lt;p&gt;为了设置顶点着色器的输出，必须把位置数据赋值给预定义的gl_Position变量，它在幕后是vec4类型的。&lt;/p&gt;
&lt;p&gt;在main函数的最后，&lt;code&gt;gl_Position&lt;/code&gt;设置的值会成为该顶点着色器的输出。&lt;/p&gt;
&lt;p&gt;由于输入是一个3分量的向量，必须把它转换为4分量的。这里把把&lt;code&gt;vec3&lt;/code&gt;的数据作为&lt;code&gt;vec4&lt;/code&gt;构造器的参数，同时把&lt;code&gt;w&lt;/code&gt;分量设置为&lt;code&gt;1.0f&lt;/code&gt;来完成这一任务。&lt;/p&gt;
&lt;p&gt;这里我们对输入数据什么都没有处理就把它传到着色器的输出了，因为这里的数据是定义好的标准化设备坐标。而在真实的程序里输入数据通常都不是标准化设备坐标，所以必须先把它们转换至OpenGL的可视区域内。&lt;/p&gt;
&lt;h2 id=&#34;片段着色器&#34;&gt;片段着色器&lt;/h2&gt;
&lt;p&gt;片段着色器所做的是计算像素最后的颜色输出。&lt;/p&gt;
&lt;p&gt;在计算机图形中颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量，通常缩写为RGBA。&lt;/p&gt;
&lt;p&gt;当在OpenGL或GLSL中定义一个颜色的时候，把颜色每个分量的强度设置在0.0到1.0之间。&lt;/p&gt;
&lt;p&gt;比如说设置红为1.0f，绿为1.0f，会得到两个颜色的混合色，即黄色。&lt;/p&gt;
&lt;p&gt;这三种颜色分量的不同调配可以生成超过1600万种不同的颜色。&lt;/p&gt;
&lt;p&gt;下面给出片段着色器的示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-GLSL&#34;&gt;#version 330 core
out vec4 FragColor;

void main()
{
    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;片段着色器只需要一个输出变量，这个变量是一个4分量向量，它表示的是最终的输出颜色，应该自己将其计算出来。&lt;/p&gt;
&lt;p&gt;声明输出变量可以使用&lt;code&gt;out&lt;/code&gt;关键字，这里我们命名为&lt;code&gt;FragColor&lt;/code&gt;。然后将一个橘黄色的&lt;code&gt;vec4&lt;/code&gt;赋值给颜色输出。&lt;/p&gt;
&lt;h2 id=&#34;编译着色器&#34;&gt;编译着色器&lt;/h2&gt;
&lt;p&gt;在这里，为了简单起见，先暂时将源代码直接以字符串形式储存直接存储在代码。&lt;/p&gt;
&lt;p&gt;为了能够让OpenGL使用着色器，必须在运行时动态编译它的源代码。编译方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;const char *vertexShaderSource = &amp;quot;#version 330 core\n&amp;quot;
    &amp;quot;layout (location = 0) in vec3 aPos;\n&amp;quot;
    &amp;quot;void main()\n&amp;quot;
    &amp;quot;{\n&amp;quot;
    &amp;quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&amp;quot;
    &amp;quot;}\0&amp;quot;;

const char *fragmentShaderSource = &amp;quot;#version 330 core\n&amp;quot;
    &amp;quot;out vec4 FragColor;\n&amp;quot;
    &amp;quot;void main()\n&amp;quot;
    &amp;quot;{\n&amp;quot;
    &amp;quot;   FragColor = vec4(1.0f, 0.1f, 0.1f, 1.0f);\n&amp;quot;
    &amp;quot;}\0&amp;quot;;

unsigned int vertexShader;
vertexShader = glCreateShader(GL_VERTEX_SHADER);

unsigned int fragmentShader;
fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);

glShaderSource(vertexShader, 1, &amp;amp;vertexShaderSource, NULL);
glCompileShader(vertexShader);

glShaderSource(fragmentShader, 1, &amp;amp;fragmentShaderSource, NULL);
glCompileShader(fragmentShader);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先创建一个着色器对象，注意还是用ID来引用的。用unsigned int储存这个顶点着色器，然后用glCreateShader创建这个着色器。&lt;/p&gt;
&lt;p&gt;把需要创建的着色器类型以参数形式提供给&lt;code&gt;glCreateShader&lt;/code&gt;。创建一个顶点着色器传递的参数是&lt;code&gt;GL_VERTEX_SHADER&lt;/code&gt;，创建片段着色器时使用&lt;code&gt;GL_FRAGMENT_SHADER&lt;/code&gt;作为着色器类型。&lt;/p&gt;
&lt;p&gt;接着把这个着色器源码附加到着色器对象上，然后编译它。&lt;br&gt;
&lt;code&gt;glShaderSource&lt;/code&gt;函数把要编译的着色器对象作为第一个参数。第二个参数指定了传递的源码字符串数量，这里只有一个。第三个参数是顶点着色器真正的源码，第四个参数设置为&lt;code&gt;NULL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;检测编译时错误可以通过以下代码来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int  success;
char infoLog[512];
glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;amp;success);

if(!success)
{
    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
    std::cout &amp;lt;&amp;lt; &amp;quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&amp;quot; &amp;lt;&amp;lt; infoLog &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先定义一个整型变量来表示是否成功编译，还定义了一个储存错误消息（如果有的话）的容器。&lt;br&gt;
然后用&lt;code&gt;glGetShaderiv&lt;/code&gt;检查是否编译成功。如果编译失败，用&lt;code&gt;glGetShaderInfoLog&lt;/code&gt;获取错误消息，然后打印它。&lt;/p&gt;
&lt;p&gt;如果编译的时候没有检测到任何错误，着色器就被编译成功了。&lt;/p&gt;
&lt;h2 id=&#34;链接着色器&#34;&gt;链接着色器&lt;/h2&gt;
&lt;p&gt;着色器程序对象是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器，必须把它们链接为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。&lt;/p&gt;
&lt;p&gt;已激活着色器程序的着色器将在发送渲染调用的时候被使用。&lt;/p&gt;
&lt;p&gt;当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，会得到一个连接错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;unsigned int shaderProgram;
shaderProgram = glCreateProgram();
glAttachShader(shaderProgram, vertexShader);
glAttachShader(shaderProgram, fragmentShader);
glLinkProgram(shaderProgram);
glUseProgram(shaderProgram);

glDeleteShader(vertexShader);
glDeleteShader(fragmentShader);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;glCreateProgram&lt;/code&gt;函数创建一个程序，并返回新创建程序对象的ID引用。&lt;/p&gt;
&lt;p&gt;接着把之前编译的着色器附加到程序对象上，然后用&lt;code&gt;glLinkProgram&lt;/code&gt;链接它们。&lt;/p&gt;
&lt;p&gt;链接完成后得到的结果就是一个程序对象，下一步可以调用&lt;code&gt;glUseProgram&lt;/code&gt;函数，用刚创建的程序对象作为它的参数，以激活这个程序对象。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;glUseProgram&lt;/code&gt;函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器）了。&lt;/p&gt;
&lt;p&gt;最后使用&lt;code&gt;glDeleteShader&lt;/code&gt;删除原来的着色器对象，因为已经绑定到着色器程序中了。&lt;/p&gt;
&lt;p&gt;就像着色器的编译一样，也可以检测链接着色器程序是否失败，并获取相应的日志。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;amp;success);
if(!success) {
    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果链接的时候没有检测到任何错误，着色器就被链接成功了。&lt;/p&gt;
&lt;p&gt;现在，我们已经把输入顶点数据发送给了GPU，并指示了GPU如何在顶点和片段着色器中处理它。但是OpenGL还不知道它该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉OpenGL怎么做。&lt;/p&gt;
&lt;h2 id=&#34;链接顶点属性&#34;&gt;链接顶点属性&lt;/h2&gt;
&lt;p&gt;顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，它还的确意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以，我们必须在渲染前指定OpenGL该如何解释顶点数据。&lt;/p&gt;
&lt;p&gt;顶点数据应当被解析为如下形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位置数据被储存为32位（4字节）浮点值。&lt;/li&gt;
&lt;li&gt;每个位置包含3个这样的值。&lt;/li&gt;
&lt;li&gt;在这3个值之间没有空隙（或其他值）。&lt;/li&gt;
&lt;li&gt;数据中第一个值在缓冲开始的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了这些信息我们就可以使用&lt;code&gt;glVertexAttribPointer&lt;/code&gt;函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）。&lt;/p&gt;
&lt;p&gt;每个顶点属性从一个&lt;code&gt;VBO&lt;/code&gt;管理的内存中获得它的数据，而具体是从哪个&lt;code&gt;VBO&lt;/code&gt;（程序中可以有多个VBO）获取则是通过在调用&lt;code&gt;glVertexAttribPointer&lt;/code&gt;时绑定到&lt;code&gt;GL_ARRAY_BUFFER&lt;/code&gt;的&lt;code&gt;VBO&lt;/code&gt;决定的。&lt;/p&gt;
&lt;p&gt;由于在调用&lt;code&gt;glVertexAttribPointer&lt;/code&gt;之前绑定的是先前定义的&lt;code&gt;VBO&lt;/code&gt;对象，顶点属性&lt;code&gt;0&lt;/code&gt;现在会链接到它的顶点数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;glVertexAttribPointer函数的参数非常多，所以我会逐一介绍它们：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数指定我们要配置的顶点属性。在顶点着色器中使用了&lt;code&gt;layout(location = 0)&lt;/code&gt;定义了&lt;code&gt;position&lt;/code&gt;顶点属性的位置值吗，它可以把顶点属性的位置值设置为0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入0。&lt;/li&gt;
&lt;li&gt;第二个参数指定顶点属性的大小。顶点属性是一个&lt;code&gt;vec3&lt;/code&gt;，它由3个值组成，所以大小是3。&lt;/li&gt;
&lt;li&gt;第三个参数指定数据的类型，这里是&lt;code&gt;GL_FLOAT&lt;/code&gt;(GLSL中&lt;code&gt;vec*&lt;/code&gt;都是由浮点数值组成的)。&lt;/li&gt;
&lt;li&gt;第四个参数定义我们是否希望数据被标准化。如果我们设置为&lt;code&gt;GL_TRUE&lt;/code&gt;，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为&lt;code&gt;GL_FALSE&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;第五个参数叫做步长，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个float之后，我们把步长设置为&lt;code&gt;3 * sizeof(float)&lt;/code&gt;。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔（这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。&lt;/li&gt;
&lt;li&gt;最后一个参数的类型是&lt;code&gt;void*&lt;/code&gt;，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量。由于位置数据在数组的开头，所以这里是0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后使用&lt;code&gt;glEnableVertexAttribArray&lt;/code&gt;，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。&lt;/p&gt;
&lt;h2 id=&#34;顶点数组&#34;&gt;顶点数组&lt;/h2&gt;
&lt;p&gt;目前而言，已经完成了绘制前的设置。每次绘制一个物体的时候，都需要重复如下流程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 0. 复制顶点数组到缓冲中供OpenGL使用
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 1. 设置顶点属性指针
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
// 2. 当我们渲染一个物体时要使用着色器程序
glUseProgram(shaderProgram);
// 3. 绘制物体
someOpenGLFunctionThatDraws();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，如果有超过5个顶点属性，上百个不同物体甚至更多的话，绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事。&lt;/p&gt;
&lt;p&gt;顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。&lt;/p&gt;
&lt;p&gt;OpenGL的&lt;strong&gt;核心模式&lt;/strong&gt;要求我们使用VAO，所以它知道该如何处理顶点输入。如果绑定VAO失败，OpenGL会拒绝绘制任何东西。&lt;/p&gt;
&lt;p&gt;一个顶点数组对象会储存以下这些内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;glEnableVertexAttribArray&lt;/code&gt;和&lt;code&gt;glDisableVertexAttribArray&lt;/code&gt;的调用。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;glVertexAttribPointer&lt;/code&gt;设置的顶点属性配置。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;glVertexAttribPointer&lt;/code&gt;调用与顶点属性关联的顶点缓冲对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;unsigned int VAO;
glGenVertexArrays(1, &amp;amp;VAO);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个&lt;code&gt;VAO&lt;/code&gt;和创建一个&lt;code&gt;VBO&lt;/code&gt;很类似，要想使用&lt;code&gt;VAO&lt;/code&gt;，要做的只是使用&lt;code&gt;glBindVertexArray&lt;/code&gt;绑定&lt;code&gt;VAO&lt;/code&gt;。从绑定之后起，我们应该绑定和配置对应的&lt;code&gt;VBO&lt;/code&gt;和属性指针，之后解绑&lt;code&gt;VAO&lt;/code&gt;供之后使用。&lt;/p&gt;
&lt;p&gt;当拥有&lt;code&gt;VAO&lt;/code&gt;后，想要绘制一个物体时，只要在绘制物体前简单地把&lt;code&gt;VAO&lt;/code&gt;绑定到希望使用的设定上就行了。其流程如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..
// 1. 绑定VAO
glBindVertexArray(VAO);
// 2. 把顶点数组复制到缓冲中供OpenGL使用
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 3. 设置顶点属性指针
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);

[...]

// ..:: 绘制代码（渲染循环中） :: ..
// 4. 绘制物体
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
someOpenGLFunctionThatDraws();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般当你打算绘制多个物体时，你首先要生成/配置所有的VAO（和必须的VBO及属性指针），然后储存它们供后面使用。当打算绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO。&lt;/p&gt;
&lt;h2 id=&#34;绘制一个三角形&#34;&gt;绘制一个三角形&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glUseProgram(shaderProgram);
glBindVertexArray(VAO);
glDrawArrays(GL_TRIANGLES, 0, 3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;glDrawArrays&lt;/code&gt;函数第一个参数是打算绘制的OpenGL图元的类型。由于希望绘制的是一个三角形，这里传递&lt;code&gt;GL_TRIANGLES&lt;/code&gt;给它。第二个参数指定了顶点数组的起始索引，这里填0。最后一个参数指定打算绘制多少个顶点，这里是3（只从数据中渲染一个三角形，它只有3个顶点长）。&lt;/p&gt;
&lt;p&gt;最后给出完整代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;GL/glew.h&amp;gt;
#include &amp;lt;GLFW/glfw3.h&amp;gt;
#include &amp;lt;iostream&amp;gt;

const unsigned int SCR_WIDTH = 800;
const unsigned int SCR_HEIGHT = 600;

// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly
// ---------------------------------------------------------------------------------------------------------
void processInput(GLFWwindow* window)
{
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
}

// glfw: whenever the window size changed (by OS or user resize) this callback function executes
// ---------------------------------------------------------------------------------------------
void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    // make sure the viewport matches the new window dimensions; note that width and 
    // height will be significantly larger than specified on retina displays.
    glViewport(0, 0, width, height);
}

int main()
{
    // glfw: initialize and configure
    // ------------------------------
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif

    // glfw window creation
    // --------------------
    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &amp;quot;FirstOpenGL&amp;quot;, NULL, NULL);
    if (window == NULL)
    {
        std::cout &amp;lt;&amp;lt; &amp;quot;Failed to create GLFW window&amp;quot; &amp;lt;&amp;lt; std::endl;
        glfwTerminate();
        return -1;
    }

    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    if (glewInit() != GLEW_OK)
           std::cout &amp;lt;&amp;lt; &amp;quot;error&amp;quot; &amp;lt;&amp;lt; std::endl;
    // build and compile our shader program
    // -----------------------------------

    const char* vertexShaderSource = &amp;quot;#version 330 core\n&amp;quot;
    &amp;quot;layout (location = 0) in vec3 aPos;\n&amp;quot;
    &amp;quot;void main()\n&amp;quot;
    &amp;quot;{\n&amp;quot;
    &amp;quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&amp;quot;
    &amp;quot;}\0&amp;quot;;

    const char* fragmentShaderSource = &amp;quot;#version 330 core\n&amp;quot;
    &amp;quot;out vec4 FragColor;\n&amp;quot;
    &amp;quot;void main()\n&amp;quot;
    &amp;quot;{\n&amp;quot;
    &amp;quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&amp;quot;
    &amp;quot;}\n\0&amp;quot;;

    // vertex shader
    unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &amp;amp;vertexShaderSource, NULL);
    glCompileShader(vertexShader);
    // check for shader compile errors
    int success;
    char infoLog[512];
    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;amp;success);
    if (!success)
    {
        glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
        std::cout &amp;lt;&amp;lt; &amp;quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&amp;quot; &amp;lt;&amp;lt; infoLog &amp;lt;&amp;lt; std::endl;
    }
    // fragment shader
    unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &amp;amp;fragmentShaderSource, NULL);
    glCompileShader(fragmentShader); 
    // check for shader compile errors
    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;amp;success);
    if (!success)
    {
        glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
        std::cout &amp;lt;&amp;lt; &amp;quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&amp;quot; &amp;lt;&amp;lt; infoLog &amp;lt;&amp;lt; std::endl;
    }
    // link shaders
    unsigned int shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);
    // check for linking errors
    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;amp;success);
    if (!success) {
        glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
        std::cout &amp;lt;&amp;lt; &amp;quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&amp;quot; &amp;lt;&amp;lt; infoLog &amp;lt;&amp;lt; std::endl;
    }
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    // set up vertex data (and buffer(s)) and configure vertex attributes
    // ------------------------------------------------------------------
    float vertices[] = {
        -0.5f, -0.5f, 0.0f, // left  
         0.5f, -0.5f, 0.0f, // right 
         0.0f,  0.5f, 0.0f  // top   
    };

    unsigned int VBO, VAO;
    glGenVertexArrays(1, &amp;amp;VAO);
    glGenBuffers(1, &amp;amp;VBO);
    // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).
    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    // note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute&#39;s bound vertex buffer object so afterwards we can safely unbind
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    // You can unbind the VAO afterwards so other VAO calls won&#39;t accidentally modify this VAO, but this rarely happens. Modifying other
    // VAOs requires a call to glBindVertexArray anyways so we generally don&#39;t unbind VAOs (nor VBOs) when it&#39;s not directly necessary.
    glBindVertexArray(0);


    // uncomment this call to draw in wireframe polygons.
    //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

    // render loop
    // -----------
    while (!glfwWindowShouldClose(window))
    {
        // input
        // -----
        processInput(window);

        // render
        // ------
        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        // draw our first triangle
        glUseProgram(shaderProgram);
        glBindVertexArray(VAO); // seeing as we only have a single VAO there&#39;s no need to bind it every time, but we&#39;ll do so to keep things a bit more organized
        glDrawArrays(GL_TRIANGLES, 0, 3);
        // glBindVertexArray(0); // no need to unbind it every time 

        // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
        // -------------------------------------------------------------------------------
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    // optional: de-allocate all resources once they&#39;ve outlived their purpose:
    // ------------------------------------------------------------------------
    glDeleteVertexArrays(1, &amp;amp;VAO);
    glDeleteBuffers(1, &amp;amp;VBO);
    glDeleteProgram(shaderProgram);

    // glfw: terminate, clearing all previously allocated GLFW resources.
    // ------------------------------------------------------------------
    glfwTerminate();
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终结果应该显示如下图形&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1692337984534.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;元素缓冲区&#34;&gt;元素缓冲区&lt;/h2&gt;
&lt;p&gt;假设不再绘制一个三角形而是绘制一个矩形，那么可以通过绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）。这会生成下面的顶点的集合：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;float vertices[] = {
    // 第一个三角形
    0.5f, 0.5f, 0.0f,   // 右上角
    0.5f, -0.5f, 0.0f,  // 右下角
    -0.5f, 0.5f, 0.0f,  // 左上角
    // 第二个三角形
    0.5f, -0.5f, 0.0f,  // 右下角
    -0.5f, -0.5f, 0.0f, // 左下角
    -0.5f, 0.5f, 0.0f   // 左上角
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不难发现，里面存在着顶点的重复。而当顶点和图形数目增多时，这种重复带来的浪费是难以忍受的。&lt;/p&gt;
&lt;p&gt;更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子只要储存4个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。这就是元素缓冲区（EBO）对象的工作方式。&lt;/p&gt;
&lt;p&gt;EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储 OpenGL 用来决定要绘制哪些顶点的索引。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;float vertices[] = {
    0.5f, 0.5f, 0.0f,   // 右上角
    0.5f, -0.5f, 0.0f,  // 右下角
    -0.5f, -0.5f, 0.0f, // 左下角
    -0.5f, 0.5f, 0.0f   // 左上角
};

unsigned int indices[] = {
    // 注意索引从0开始! 
    // 此例的索引(0,1,2,3)就是顶点数组vertices的下标，
    // 这样可以由下标代表顶点组合成矩形

    0, 1, 3, // 第一个三角形
    1, 2, 3  // 第二个三角形
};

unsigned int EBO;
glGenBuffers(1, &amp;amp;EBO);
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当使用索引的时候，只定义4个顶点，而不是6个。同时，需要定义出绘制出矩形所需的索引数组。&lt;/p&gt;
&lt;p&gt;与VBO类似，先绑定EBO然后用&lt;code&gt;glBufferData&lt;/code&gt;把索引复制到缓冲里，只不过这次把缓冲的类型定义为&lt;code&gt;GL_ELEMENT_ARRAY_BUFFER&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后一件要做的事是用&lt;code&gt;glDrawElements&lt;/code&gt;来替换&lt;code&gt;glDrawArrays&lt;/code&gt;函数，表示要从索引缓冲区渲染三角形。使用&lt;code&gt;glDrawElements&lt;/code&gt;时，会使用当前绑定的索引缓冲对象中的索引进行绘制。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;glDrawElements&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数指定了绘制的模式，这个和&lt;code&gt;glDrawArrays&lt;/code&gt;的一样。&lt;/li&gt;
&lt;li&gt;第二个参数是我们打算绘制顶点的个数，这里填6，也就是说一共需要绘制6个顶点。&lt;/li&gt;
&lt;li&gt;第三个参数是索引的类型，这里是&lt;code&gt;GL_UNSIGNED_INT&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;最后一个参数指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），在这里填写0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在绑定VAO时，绑定的最后一个元素缓冲区对象存储为VAO的元素缓冲区对象。然后，绑定到VAO也会自动绑定该EBO。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1] https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/03%20Hello%20Window/&lt;/p&gt;
&lt;p&gt;[2] http://bit.ly/2lt7ccM&lt;/p&gt;
">[OpenGL入门教程] 3. 从绘制简单图形开始</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/45ZILRP0V/"" data-c="
          &lt;p&gt;为了显示图形，首先要做的就是创建一个OpenGL上下文(Context)和一个用于显示的窗口。然而，这些操作在每个系统上都是不一样的，OpenGL有目的地从这些操作抽象(Abstract)出去。这意味着我们必须自己处理创建窗口，定义OpenGL上下文以及处理用户输入。&lt;/p&gt;
&lt;p&gt;我们可以使用一部分库来提供给我们一个窗口和上下文用来渲染。最流行的几个库有&lt;strong&gt;GLUT&lt;/strong&gt;，&lt;strong&gt;SDL&lt;/strong&gt;，&lt;strong&gt;SFML&lt;/strong&gt;和&lt;strong&gt;GLFW&lt;/strong&gt;。这里使用&lt;strong&gt;GLFW&lt;/strong&gt;，并使用Microsoft Visual Studio 2022作为IDE。当然，使用别的IDE或者老版本也是类似的操作。&lt;/p&gt;
&lt;h2 id=&#34;glfw-下载&#34;&gt;GLFW 下载&lt;/h2&gt;
&lt;p&gt;GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文，定义窗口参数以及处理用户输入。&lt;/p&gt;
&lt;p&gt;GLFW可以从它官方网站的&lt;a href=&#34;https://www.glfw.org/download.html&#34;&gt;下载页&lt;/a&gt;上获取。GLFW已经有针对Visual Studio 的预编译的二进制版本和相应的头文件，也可以下载源代码包自己编译。如果是为了完成一个完整的大项目，应该下载源代码包编译源码获得。但是，这里仅仅只介绍最基本的入门，为了简单起见，直接下载预编译的二进制版本和相应的头文件即可。&lt;/p&gt;
&lt;h2 id=&#34;创建工程&#34;&gt;创建工程&lt;/h2&gt;
&lt;p&gt;首先，打开Visual Studio，创建一个新的项目。如果VS提供了多个选项，选择Visual C++，然后选择Empty Project(空项目)&lt;/p&gt;
&lt;p&gt;为了使程序使用GLFW，我们需要把GLFW库链接(Link)进工程。这可以通过在链接器的设置里指定我们要使用&lt;code&gt;glfw3.lib&lt;/code&gt;来完成，但是由于我们将第三方库放在另外的目录中，我们的工程还不知道在哪寻找这个文件。于是我们还需要将放第三方库的目录添加进设置。&lt;/p&gt;
&lt;p&gt;要添加这些目录（需要VS搜索库和include文件的地方），我们首先进入&lt;strong&gt;Project Properties&lt;/strong&gt;(工程属性，在解决方案窗口里右键项目)，然后选择&lt;strong&gt;VC++ Directories&lt;/strong&gt;(VC++ 目录)选项卡。分别在&lt;code&gt;Include Directories&lt;/code&gt;与&lt;code&gt;Library Directories&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后需要在&lt;strong&gt;Linker&lt;/strong&gt;(链接器)选项卡里的&lt;strong&gt;Input&lt;/strong&gt;(输入)选项卡里添加&lt;code&gt;glfw3.lib&lt;/code&gt;这个文件，加到&lt;strong&gt;Additional Dependencies&lt;/strong&gt;(附加依赖项)字段中。&lt;/p&gt;
&lt;p&gt;如果是Windows平台，&lt;strong&gt;opengl32.lib&lt;/strong&gt;已经包含在Microsoft SDK里了，它在Visual Studio安装的时候就默认安装了。由于这里用的是VS编译器，并且是在Windows操作系统上，我们只需将&lt;strong&gt;opengl32.lib&lt;/strong&gt;添加进连接器设置里就行了。&lt;/p&gt;
&lt;p&gt;如果是在Linux下需要链接&lt;strong&gt;libGL.so&lt;/strong&gt;库文件，这需要添加&lt;code&gt;-lGL&lt;/code&gt;到链接器设置中。如果找不到这个库可能需要安装Mesa，NVidia或AMD的开发包，这部分因平台而异。&lt;/p&gt;
&lt;p&gt;因为OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。可以通过使用&lt;strong&gt;GLEW&lt;/strong&gt;来获得这些函数地址。&lt;/p&gt;
&lt;p&gt;GLEW是OpenGL Extension Wrangler Library的缩写，类似地，GLEW可以从这里下载，同样可以选择下载二进制版本，如果目标平台列在上面的话，或者下载源码编译。接着，使用GLEW的静态版本&lt;strong&gt;glew32s.lib&lt;/strong&gt;（注意这里的“s”），将库文件添加到你的库目录，将include内容添加到你的include目录。接下来，在VS的链接器选项里加上&lt;strong&gt;glew32s.lib&lt;/strong&gt;。注意GLFW3（默认）也是编译成了一个静态库。&lt;/p&gt;
&lt;p&gt;为了静态链接GLEW，必须在包含GLEW头文件之前定义预处理器宏&lt;code&gt;GLEW_STATIC&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define GLEW_STATIC
#include &amp;lt;GL/glew.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果使用动态链接，那么可以省略这个宏。但是记住使用动态链接的话你需要拷贝一份.DLL文件到应用程序目录。&lt;/p&gt;
&lt;h2 id=&#34;简单测试用例&#34;&gt;简单测试用例&lt;/h2&gt;
&lt;p&gt;测试下能不能让GLFW正常工作。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define GLEW_STATIC
#include &amp;lt;GL/glew.h&amp;gt;
// GLFW
#include &amp;lt;GLFW/glfw3.h&amp;gt;

int main()
{
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);

    GLFWwindow* window = glfwCreateWindow(800, 600, &amp;quot;FirstOpenGL&amp;quot;, nullptr, nullptr);
    if (window == nullptr)
    {
        std::cout &amp;lt;&amp;lt; &amp;quot;Failed to create GLFW window&amp;quot; &amp;lt;&amp;lt; std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);

    glewExperimental = GL_TRUE;
    if (glewInit() != GLEW_OK)
    {
        std::cout &amp;lt;&amp;lt; &amp;quot;Failed to initialize GLEW&amp;quot; &amp;lt;&amp;lt; std::endl;
        return -1;
    }

    while(!glfwWindowShouldClose(window))
    {
        glfwPollEvents();
        glfwSwapBuffers(window);
    }

    glfwTerminate();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先，新建一个&lt;code&gt;.cpp&lt;/code&gt;文件，然后定义&lt;code&gt;GLEW_STATIC&lt;/code&gt;宏，这是因为使用的是GLEW静态的链接库。&lt;/p&gt;
&lt;p&gt;接下来创建main函数，在这个函数中将会实例化GLFW窗口。&lt;/p&gt;
&lt;p&gt;在main函数中调用&lt;code&gt;glfwInit&lt;/code&gt;函数来初始化GLFW，然后使用&lt;code&gt;glfwWindowHint&lt;/code&gt;函数来配置GLFW。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;glfwWindowHint&lt;/code&gt;函数的第一个参数代表选项的名称，可以从很多以&lt;code&gt;GLFW_&lt;/code&gt;开头的枚举值中选择；&lt;br&gt;
第二个参数接受一个整形，用来设置这个选项的值。该函数的所有的选项以及对应的值都可以在 GLFW’s window handling 这篇文档中找到。如果现在编译你的cpp文件得到了大量的 &lt;code&gt;undefined reference&lt;/code&gt; (未定义的引用)错误，这说明你并未顺利地链接GLFW库。&lt;/p&gt;
&lt;p&gt;接下来我们创建一个窗口对象，这个窗口对象存放了所有和窗口相关的数据&lt;/p&gt;
&lt;p&gt;&lt;code&gt;glfwCreateWindow&lt;/code&gt;函数需要窗口的宽和高作为它的前两个参数；第三个参数表示这个窗口的名称（标题）；最后两个参数暂时忽略，先设置为空指针就行。它的返回值&lt;code&gt;GLFWwindow&lt;/code&gt;对象的指针会在其他的GLFW操作中使用到。创建完窗口就可以通知GLFW将窗口的上下文设置为当前线程的主上下文了。&lt;/p&gt;
&lt;p&gt;然后初始化GLEW用于获取OpenGL的函数指针。注意，在初始化GLEW之前设置&lt;code&gt;glewExperimental&lt;/code&gt;变量的值为&lt;code&gt;GL_TRUE&lt;/code&gt;，这样做能让GLEW在管理OpenGL的函数指针时更多地使用现代化的技术，如果把它设置为&lt;code&gt;GL_FALSE&lt;/code&gt;的话可能会在使用OpenGL的&lt;strong&gt;核心模式&lt;/strong&gt;时出现一些问题。&lt;/p&gt;
&lt;p&gt;为了循环绘制图形，需要在程序中添加一个while循环，可以把它称之为游戏循环(Game Loop)，它能在我们让GLFW退出前一直保持运行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;glfwWindowShouldClose&lt;/code&gt;函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话该函数返回true然后游戏循环便结束了，之后为我们就可以关闭应用程序了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;glfwPollEvents&lt;/code&gt;函数检查有没有触发什么事件（比如键盘输入、鼠标移动等），然后调用对应的回调函数（可以通过回调方法手动设置）。我们一般在游戏循环的开始调用事件处理函数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;glfwSwapBuffers&lt;/code&gt;函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用&lt;strong&gt;双缓冲&lt;/strong&gt;渲染窗口应用程序。&lt;/p&gt;
&lt;p&gt;前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。&lt;/p&gt;
&lt;p&gt;最后，调用&lt;code&gt;glfwTerminate&lt;/code&gt;清理所有的资源并正确地退出应用程序。&lt;/p&gt;
&lt;p&gt;如果没有问题的话，运行程序应该可以看到一个黑色的窗口显示。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1] https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/03%20Hello%20Window/&lt;/p&gt;
&lt;p&gt;[2] http://bit.ly/2lt7ccM&lt;/p&gt;
">[OpenGL入门教程] 2. 创建工程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/qSyqeer6g/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;OpenGL一般被认为是一个API(Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数。然而，OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范(Specification)&lt;/p&gt;
&lt;p&gt;OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定（注：这里开发者是指编写OpenGL库的人）。因为OpenGL规范并没有规定实现的细节，具体的OpenGL库允许使用不同的实现，只要其功能和结果与规范相匹配（亦即，作为用户不会感受到功能上的差异）。&lt;/p&gt;
&lt;p&gt;实际的OpenGL库的开发者通常是显卡的生产商。你购买的显卡所支持的OpenGL版本都为这个系列的显卡专门开发的。当你使用Apple系统的时候，OpenGL库是由Apple自身维护的。在Linux下，有显卡生产商提供的OpenGL库，也有一些爱好者改编的版本。这也意味着任何时候OpenGL库表现的行为与规范规定的不一致时，基本都是库的开发者留下的bug。由于OpenGL的大多数实现都是由显卡厂商编写的，当产生一个bug时通常可以通过升级显卡驱动来解决。这些驱动会包括你的显卡能支持的最新版本的OpenGL，这也是为什么总是建议你偶尔更新一下显卡驱动。&lt;/p&gt;
&lt;p&gt;所有版本的OpenGL规范文档都被公开的寄存在Khronos那里。如果想深入到OpenGL的细节（只关心函数功能的描述而不是函数的实现），这是个很好的选择。如果你想知道每个函数具体的运作方式，这个规范也是一个很棒的参考。&lt;/p&gt;
&lt;h2 id=&#34;核心模式与立即渲染模式&#34;&gt;核心模式与立即渲染模式&lt;/h2&gt;
&lt;p&gt;早期的OpenGL使用&lt;strong&gt;立即渲染模式&lt;/strong&gt;（Immediate mode，也就是&lt;strong&gt;固定渲染管线&lt;/strong&gt;），这个模式下绘制图形很方便。这个模式下OpenGL的大多数功能都被库隐藏起来，开发者很少能控制OpenGL如何进行计算的自由。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;立即渲染模式&lt;/strong&gt;确实容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，推出&lt;strong&gt;核心模式&lt;/strong&gt;(Core-profile)，这个模式完全移除了旧的特性。&lt;/p&gt;
&lt;p&gt;当使用OpenGL的&lt;strong&gt;核心模式&lt;/strong&gt;时，OpenGL迫使我们使用现代的函数。&lt;strong&gt;立即渲染模式&lt;/strong&gt;从OpenGL实际运作中抽象掉了很多细节，因而它易于学习的同时，也很难去把握OpenGL具体是如何运作的。现代函数要求使用者真正理解OpenGL和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程。&lt;/p&gt;
&lt;p&gt;所有OpenGL的更高的版本都是在3.3的基础上，引入了额外的功能，并没有改动核心架构。但是，当使用新版本的OpenGL特性时，只有新一代的显卡能够支持你的应用程序。这也是为什么大多数开发者基于较低版本的OpenGL编写程序，并只提供选项启用新版本的特性。&lt;/p&gt;
&lt;h2 id=&#34;扩展&#34;&gt;扩展&lt;/h2&gt;
&lt;p&gt;OpenGL的一大特性就是对扩展(Extension)的支持，当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。如果一个程序在支持这个扩展的显卡上运行，开发者可以使用这个扩展提供的一些更先进更有效的图形功能。&lt;/p&gt;
&lt;p&gt;通过这种方式，开发者不必等待一个新的OpenGL规范面世，就可以使用这些新的渲染特性了，只需要简单地检查一下显卡是否支持此扩展。通常，当一个扩展非常流行或者非常有用的时候，它将最终成为未来的OpenGL规范的一部分。&lt;/p&gt;
&lt;h2 id=&#34;opengl的运作方式&#34;&gt;OpenGL的运作方式&lt;/h2&gt;
&lt;p&gt;OpenGL本质上是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为&lt;strong&gt;OpenGL上下文&lt;/strong&gt;(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。&lt;/p&gt;
&lt;p&gt;假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。&lt;/p&gt;
&lt;p&gt;OpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。由于C的一些语言结构不易被翻译到其它的高级语言，因此OpenGL开发的时候引入了一些抽象层。“对象(Object)”就是其中一个。&lt;/p&gt;
&lt;p&gt;在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集。&lt;/p&gt;
&lt;p&gt;使用OpenGL时，建议使用OpenGL定义的基元类型。比如使用&lt;code&gt;float&lt;/code&gt;时我们加上前缀&lt;code&gt;GL&lt;/code&gt;（因此写作&lt;code&gt;GLfloat&lt;/code&gt;）。&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;uint&lt;/code&gt;、&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;bool&lt;/code&gt;等等也类似。OpenGL定义的这些&lt;code&gt;GL&lt;/code&gt;基元类型的内存布局是与平台无关的，而int等基元类型在不同操作系统上可能有不同的内存布局。使用GL基元类型可以保证你的程序在不同的平台上工作一致。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1] https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/03%20Hello%20Window/&lt;/p&gt;
&lt;p&gt;[2] http://bit.ly/2lt7ccM&lt;/p&gt;
">[OpenGL入门教程] 1. OpenGL介绍</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/tiu-ywk-p/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Pyinstaller&lt;/code&gt;是一个用于将Python程序打包成可执行文件的工具。它可以将Python程序打包成单个可执行文件，无需安装Python解释器和第三方库，方便程序的分发和部署。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Pyinstaller&lt;/code&gt;支持Windows、Linux和MacOS等多个平台，可以将Python程序打包成对应平台的可执行文件。打包完成后的可执行文件可以直接在对应平台使用，无需安装任何环境或者依赖。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Pyinstaller&lt;/code&gt;的使用非常简单，只需要在命令行中执行&lt;code&gt;Pyinstaller&lt;/code&gt;命令，并指定要打包的Python程序的入口文件即可。&lt;code&gt;Pyinstaller&lt;/code&gt;会自动分析程序的依赖关系，并将所有依赖的模块和库打包到可执行文件中。&lt;/p&gt;
&lt;p&gt;打包完成后，可以在&lt;code&gt;dist&lt;/code&gt;目录下找到生成的可执行文件。&lt;/p&gt;
&lt;p&gt;除了将Python程序打包成可执行文件外，&lt;code&gt;Pyinstaller&lt;/code&gt;还支持许多高级功能，如自定义打包选项、添加图标、加密代码等。这些功能可以通过在命令行中指定参数或创建配置文件来实现。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Pyinstaller&lt;/code&gt;的优点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单易用：&lt;code&gt;Pyinstaller&lt;/code&gt;的使用非常简单，只需要执行一个命令即可将Python程序打包成可执行文件。&lt;/li&gt;
&lt;li&gt;跨平台支持：&lt;code&gt;Pyinstaller&lt;/code&gt;支持多个平台，可以将Python程序打包成对应平台的可执行文件。&lt;/li&gt;
&lt;li&gt;自动化打包：&lt;code&gt;Pyinstaller&lt;/code&gt;会自动分析程序的依赖关系，并将所有依赖的模块和库打包到可执行文件中。&lt;/li&gt;
&lt;li&gt;高级功能：&lt;code&gt;Pyinstaller&lt;/code&gt;支持许多高级功能，如自定义打包选项、添加图标、加密代码等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Pyinstaller&lt;/code&gt;的缺点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包后文件较大：由于&lt;code&gt;Pyinstaller&lt;/code&gt;会将所有依赖的模块和库打包到可执行文件中，因此打包后的文件较大。&lt;/li&gt;
&lt;li&gt;不支持所有第三方库：&lt;code&gt;Pyinstaller&lt;/code&gt;并不支持所有第三方库，有些库可能需要手动配置才能正确打包。&lt;/li&gt;
&lt;li&gt;可执行文件可能被反编译：由于可执行文件中包含了程序的源代码，因此可能会被反编译，导致代码泄露。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是，总的来说，Pyinstaller是一个非常好用的工具，方便程序的分发和部署。下面介绍它的使用方法。&lt;/p&gt;
&lt;h2 id=&#34;使用方法&#34;&gt;使用方法&lt;/h2&gt;
&lt;p&gt;下面是一些常用的Pyinstaller参数和选项及其含义，我根据使用频率将其分为了两级。&lt;/p&gt;
&lt;h3 id=&#34;高频参数&#34;&gt;高频参数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-h&lt;/code&gt;：显示帮助信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-F&lt;/code&gt;：将Python程序打包成单个可执行文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-D&lt;/code&gt;：将Python程序打包成多个文件，包括可执行文件和依赖的模块和库。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w&lt;/code&gt;/&lt;code&gt;--windowed&lt;/code&gt;：使用窗口模式，不显示命令行窗口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt;/&lt;code&gt;--console&lt;/code&gt;：使用控制台模式，显示命令行窗口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt;/&lt;code&gt;--name&lt;/code&gt;：指定生成的可执行文件的名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt;/&lt;code&gt;--icon&lt;/code&gt;：指定可执行文件的图标。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--add-data&lt;/code&gt;：指定需要打包的数据文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--add-binary&lt;/code&gt;：指定需要打包的二进制文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt;：指定Python模块的搜索路径。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-y&lt;/code&gt;：自动覆盖输出目录中的现有文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--clean&lt;/code&gt;：在打包之前清除缓存和临时文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--distpath&lt;/code&gt;：指定输出目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--workpath&lt;/code&gt;：指定工作目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--specpath&lt;/code&gt;：指定&lt;code&gt;.spec&lt;/code&gt;文件的输出目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;低频参数&#34;&gt;低频参数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt;：生成一个控制台程序，但不显示Python解释器的输出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt;：显示详细的输出信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--hidden-import&lt;/code&gt;：指定需要导入的隐藏模块。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--additional-hooks-dir&lt;/code&gt;：指定额外的钩子目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--exclude-module&lt;/code&gt;：指定不需要打包的模块。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--key&lt;/code&gt;：指定加密代码的密钥。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--upx-dir&lt;/code&gt;：指定UPX压缩工具的路径。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--upx-exclude&lt;/code&gt;：指定不需要压缩的文件类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--upx-compress-level&lt;/code&gt;：指定UPX压缩级别。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--log-level&lt;/code&gt;：指定日志输出级别。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--runtime-tmpdir&lt;/code&gt;：指定运行时临时目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--debug&lt;/code&gt;：生成调试信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--strip&lt;/code&gt;：去除调试信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--noconfirm&lt;/code&gt;：不显示确认提示。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;用例&#34;&gt;用例&lt;/h3&gt;
&lt;p&gt;这里给出一些常见的用法便于理解和使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pyinstaller -F myprogram.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PyInstaller&lt;/code&gt;会将&lt;code&gt;myprogram.py&lt;/code&gt;文件打包成单个可执行文件，并将所有依赖的模块和库打包到可执行文件中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pyinstaller -F --distpath=./dist --icon=myicon.ico myprogram.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PyInstaller&lt;/code&gt;会将&lt;code&gt;myprogram.py&lt;/code&gt;文件打包成单个可执行文件，并将所有依赖的模块和库打包到可执行文件中。生成的可执行文件将保存在&lt;code&gt;./dist&lt;/code&gt;目录下，并使用&lt;code&gt;myicon.ico&lt;/code&gt;作为图标。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pyinstaller -D --add-data &amp;quot;data.txt;.&amp;quot; myprogram.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;-D&lt;/code&gt;参数可以将Python程序打包为多个文件，使用&lt;code&gt;--add-data&lt;/code&gt;参数指定需要打包的数据文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--add-data&lt;/code&gt;参数的格式是&lt;code&gt;&amp;quot;源文件;目标目录&amp;quot;&lt;/code&gt;，其中源文件是要打包的文件路径，目标目录是打包后文件中的目标路径。&lt;/p&gt;
&lt;p&gt;在示例中，将&lt;code&gt;data.txt&lt;/code&gt;文件打包，并指定目标目录为当前目录（&lt;code&gt;.&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;打包完成后，可以在生成的可执行文件所在的目录中找到&lt;code&gt;data.txt&lt;/code&gt;文件。在程序运行时，可以使用相对路径或绝对路径来访问该数据文件。&lt;/p&gt;
&lt;p&gt;请注意，&lt;code&gt;--add-data&lt;/code&gt;参数可以多次使用，以添加多个数据文件。每个数据文件都需要指定源文件和目标目录。&lt;/p&gt;
">[Python] pyinstaller--将python程序打包为不依赖于本机环境的独立可执行文件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/TQnKduscP/"" data-c="
          &lt;p&gt;这篇博客对应于上一篇博客：&lt;a href=&#34;https://wjcsw.github.io/yUgU6O2CS/&#34;&gt;[Python] 从FBX文件中读取数据&lt;/a&gt;，介绍如何将获得的UV数据写入到3ds MAX中的模型中。&lt;/p&gt;
&lt;p&gt;首先，必须要知道的一个重要常识是，3ds Max中的索引大部分都是从1开始的，与Python不同，使用时必须注意到这点去转换索引。&lt;/p&gt;
&lt;h3 id=&#34;1-获取要写入的模型&#34;&gt;1. 获取要写入的模型&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;getNodeByName&lt;/code&gt;接口就可以直接根据模型名称获取到需要写入的模型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 引入Max的python库
from pymxs import runtime as rt

triObj = rt.getNodeByName(fbxMeshName) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于模型类型poly和mesh类型的接口不一致，为了方便起见，可以通过类型判断，用一个变量统一地使用接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;rt_convert = rt.polyop
nodecls = rt.classOf(triObj)
if str(nodecls) == &amp;quot;Editable_mesh&amp;quot;:
    rt_convert = rt.meshop
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-添加通道&#34;&gt;2. 添加通道&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;defaultMapFaces&lt;/code&gt;方法可以新建一个初始化好的新通道，并使用&lt;code&gt;channelInfo.NameChannel&lt;/code&gt;来为通道命名&lt;/p&gt;
&lt;p&gt;注意 使用这种方法获得的新通道不是修改器形式&lt;/p&gt;
&lt;p&gt;为了可以更好的控制 我们可以通过&lt;code&gt;channelInfo.AddChannel&lt;/code&gt;方法来新建一个通道 再使用&lt;code&gt;defaultMapFaces&lt;/code&gt;方法进行初始化 这样新通道就是以修改器形式展示的了&lt;/p&gt;
&lt;p&gt;可以访问节点的修改器属性&lt;code&gt;triObj.modifiers[0].name&lt;/code&gt;为该修改器命名 以更好的理解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;rt.channelInfo.AddChannel(oriObj)
rt_convert.defaultMapFaces(triObj, uv_num + 1) # 初始化通道
rt.channelInfo.NameChannel(triObj, 3, uv_num + 1, &amp;quot;new&amp;quot;) # 为新通道命名
triObj.modifiers[0].name = &amp;quot;AutoUV - Add EmptyUV&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-设置通道&#34;&gt;3. 设置通道&lt;/h3&gt;
&lt;p&gt;这里的&lt;code&gt;UVCount&lt;/code&gt;表示UV面的大小数组，&lt;code&gt;UVValue&lt;/code&gt;是UV顶点数组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;uvWriteChannel = 2
nfaces = len(UVCount)
nverts = int(len(UVValue) / 2)

rt_convert.setMapSupport(triObj, uvWriteChannel, True)
rt_convert.setNumMapVerts(triObj, uvWriteChannel, nverts)
rt_convert.setNumMapFaces(triObj, uvWriteChannel, nfaces)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;SetMapSupport()&lt;/code&gt;设置 UV 映射支持启用2号通道， 使用&lt;code&gt;SetNumMapVerts() &lt;/code&gt;设置UV 映射的顶点数，使用 &lt;code&gt;SetNumMapFaces()&lt;/code&gt; 设置UV 映射的面数&lt;/p&gt;
&lt;h3 id=&#34;4-设置顶点&#34;&gt;4. 设置顶点&lt;/h3&gt;
&lt;p&gt;3ds Max中的顶点类型为&lt;code&gt;Point3&lt;/code&gt;类型，由于UV数据为二维坐标，这里将获取到顶点分别设置为&lt;code&gt;Point3&lt;/code&gt;的x和y，将z设置为0&lt;br&gt;
接着遍历所有顶点 使用&lt;code&gt;setMapVert&lt;/code&gt;方法设置每个顶点的坐标&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# faces
for vert in range(nverts):
    UVVert = rt.Point3(UVValue[2 * vert], UVValue[2 * vert + 1], 0)
    rt_convert.setMapVert(triObj, uvWriteChannel, vert + 1, UVVert)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-设置面&#34;&gt;5. 设置面&lt;/h3&gt;
&lt;p&gt;由于不同的类型会导致对应模型面数组的不一致，因此这里通过类型判断分别设置了面数组的类型&lt;br&gt;
接着遍历每个面，构成对应的面的顶点序号数组，最后使用&lt;code&gt;setMapFace&lt;/code&gt;方法将面数据写入3ds Max中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;faceIndex = -1
for face in range(nfaces):
    if str(triObjcls) == &amp;quot;Editable_mesh&amp;quot;:
        faceVertex = rt_convert.getMapFace(triObj, uvWriteChannel, face + 1)
    else:
        faceVertex = rt.Array()
    for d in range(UVCount[face]):
        faceIndex += 1
        if str(triObjcls) == &amp;quot;Editable_mesh&amp;quot;:
            faceVertex[d] = UVIndex[faceIndex] + 1
        else:
            rt.append(faceVertex, UVIndex[faceIndex] + 1)

    rt_convert.setMapFace(triObj, uvWriteChannel, face + 1, faceVertex)
&lt;/code&gt;&lt;/pre&gt;
">[Python] 向3ds Max中写入UV数据</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/pNfQqR9zT/"" data-c="
          &lt;h2 id=&#34;工具&#34;&gt;工具&lt;/h2&gt;
&lt;p&gt;本文使用python语言进行的GUI开发，这里使用的模块是&lt;code&gt;QT.py&lt;/code&gt;，它可以以统一的API使用不同的GUI工具包，具体介绍可见&lt;a href=&#34;https://wjcsw.github.io/pNfQqR9zT/&#34;&gt;QT、PyQt、Pyside、QT.py之间的关系和区别&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;ui组件&#34;&gt;UI组件&lt;/h2&gt;
&lt;p&gt;这些GUI组件类是Qt库中常用的组件，可以用于创建各种类型的GUI应用程序。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;QWidget&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;QWidget&lt;/code&gt;是Qt库中所有GUI组件的基类，也可以用于创建窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;QHBoxLayout&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;水平布局类，用于在水平方向上排列GUI组件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;QVBoxLayout&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;垂直布局类，用于在垂直方向上排列GUI组件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;QGroupBox&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;组框类，用于创建一个带有标题的组框，可以将其他GUI组件放在组框中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;QLabel&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;标签类，用于显示文本或图像。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;QToolButton&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;工具按钮类，用于创建一个带有图标和文本的按钮。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;QPushButton&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;普通按钮类，用于创建一个带有文本的按钮。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;QComboBox&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;组合框类，用于创建一个下拉列表框，可以选择其中的一个选项。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;QProgressBar&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;进度条类，用于显示进度条。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;QSpinBox&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;微调框类，用于创建一个微调框，允许用户输入整数，或者通过上下按键递增或者递减。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;QSlider&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;滑动条类，用于创建一个滑动条，可以通过滑动条选择一个数字。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;QCheckBox&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;复选框类，用于创建一个复选框，可以选择或取消选择一个选项。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;QSizePolicy&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;大小策略类，用于设置GUI组件的大小策略，例如最小大小、最大大小、扩展大小等。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;用法介绍&#34;&gt;用法介绍&lt;/h2&gt;
&lt;h3 id=&#34;qapplication&#34;&gt;QApplication&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys
from Qt import QtWidgets, QtCore


class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setWindowTitle(&amp;quot;simple test&amp;quot;)
        self.setGeometry(1800, 100, 385, 672)
        self.show()


if __name__ == &#39;__main__&#39;:
    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow()

    sys.exit(app.exec_())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1687684043559.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里首先定义了一个简单的类，继承了&lt;code&gt;QtWidgets.QMainWindow&lt;/code&gt;。然后在其初始化函数中调用父类的初始化，以及自定义的初始化函数&lt;code&gt;initUI()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;initUI()&lt;/code&gt;中，调用&lt;code&gt;setWindowTitle&lt;/code&gt;创建应用程序的标题，&lt;code&gt;setGeometry&lt;/code&gt;用于设置窗口的大小位置，四个参数依次为窗口的横坐标，纵坐标，宽，高。调用&lt;code&gt;show&lt;/code&gt;让窗口显示。&lt;/p&gt;
&lt;p&gt;这里通过&lt;code&gt;Qt.py&lt;/code&gt;模块的&lt;code&gt;QtWidgets&lt;/code&gt;来创建一个Qt应用。&lt;code&gt;QApplication&lt;/code&gt;专为&lt;code&gt;QGuiApplication&lt;/code&gt;提供基于&lt;code&gt;QWidget&lt;/code&gt;的应用程序所需的一些功能。不管你有多少个窗口，都有且仅有一个&lt;code&gt;QApplication&lt;/code&gt;对象来管理它们。&lt;/p&gt;
&lt;p&gt;对于基于非&lt;code&gt;QWidget&lt;/code&gt;的Qt应用程序，请改用&lt;code&gt;QGuiApplication&lt;/code&gt;，因为它不依赖于&lt;code&gt;QtWidgets&lt;/code&gt;库。&lt;/p&gt;
&lt;p&gt;在创建一个&lt;code&gt;QApplication&lt;/code&gt;的实例，需要传入一个参数，一般为&lt;code&gt;sys.argv&lt;/code&gt; 或一个空列表&lt;code&gt;[]&lt;/code&gt;。这个参数的作用是在应用程序启动时将任何配置设置传递给Qt。&lt;/p&gt;
&lt;p&gt;在启动时传递&lt;code&gt;sys.argv&lt;/code&gt;到&lt;code&gt;QApplication&lt;/code&gt;允许你从命令行中定制Qt的行为。如果你不想或者不需要向Qt传递命令行参数，你可以跳过传递&lt;code&gt;sys.argv&lt;/code&gt;，使用空列表&lt;code&gt;[]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当你的应用程序启动时，&lt;code&gt;sys.argv&lt;/code&gt;包含用于启动应用程序的参数。如果你从命令行启动一个Python应用程序，&lt;code&gt;sys.argv&lt;/code&gt;将包含你的Python脚本文件的名字作为第一个条目。而跟在启动程序的命令末尾添加的任何内容都会被附加到&lt;code&gt;sys.argv&lt;/code&gt;上。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;python test.py --info --test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样启动程序中获取到的&lt;code&gt;sys.argv&lt;/code&gt;就是&lt;code&gt;[&#39;test.py&#39;,&#39;--info&#39;,&#39;--test&#39;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意，在命令行中参数是以空格分割的, 所以任何用空格分隔的东西都会被当作一个新的参数。如果要传递包含空格的参数，需要用引号将其包起来。&lt;/p&gt;
&lt;p&gt;Qt程序启动的常见参数包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--platform&lt;/code&gt; &lt;em&gt;platformName&lt;/em&gt;[:options] 指定Qt平台抽象（QPA）插件。这覆盖了QT_QPA_PLATFORM环境变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--platformpluginpath&lt;/code&gt; &lt;em&gt;path&lt;/em&gt;  指定平台插件的路径。这覆盖了QT_QPA_PLATFORM_PLUGIN_PATH环境变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--platformtheme&lt;/code&gt; &lt;em&gt;theme&lt;/em&gt;  指定平台的主题。这将覆盖QT_QPA_PLATFORMTHEME环境变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--qwindowicon&lt;/code&gt;  &lt;em&gt;icon&lt;/em&gt;  设置一个窗口的默认图标。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--qwindowgeometry&lt;/code&gt;  &lt;em&gt;geometry&lt;/em&gt;  为主窗口指定一个几何图形，应该像&lt;code&gt;100x100+50+50&lt;/code&gt;那样传递。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--qwindowtitle&lt;/code&gt; &lt;em&gt;title&lt;/em&gt;  设置第一个窗口的标题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面&lt;code&gt;app.exec_()&lt;/code&gt;的作用是运行主循环，必须调用&lt;code&gt;QApplication&lt;/code&gt;对象的&lt;code&gt;exec_()&lt;/code&gt;或&lt;code&gt;exec()&lt;/code&gt;才能开始事件处理，调用该方法进入程序的主循环直到调用&lt;code&gt;exit()&lt;/code&gt;结束。主事件循环从窗口系统接收事件，并将其分派给应用程序小部件。该方法结束时返回一个状态码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sys.exit(n)&lt;/code&gt;的作用是退出应用程序并返回状态码n到父进程。&lt;/p&gt;
&lt;p&gt;Python 3之前，&lt;code&gt;exec&lt;/code&gt;是一个保留的关键字，所以Qt开发人员在其中添加了下划线。所以对于Python 3的Qt，两个exec函数是相同的。对于较旧的Qt，只有&lt;code&gt;exec_()&lt;/code&gt;可用。&lt;/p&gt;
&lt;p&gt;注意 &lt;code&gt;show&lt;/code&gt;方法并不是直接让窗口显示，本质上可以将其理解为界定窗口在何时弹出的“声明”，解释器读取到这里，Qt程序还没有启动，只是确定了一旦启动，应该在“这个时候”弹出这个窗口，真正让程序启动的是exec函数。&lt;/p&gt;
&lt;h3 id=&#34;qgroupbox&#34;&gt;QGroupBox&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;self.global_group = QtWidgets.QGroupBox(self)
self.global_group.setGeometry(QtCore.QRect(0, 40, 380, 350))
self.global_group.setTitle(&amp;quot;全局&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;QGroupBox&lt;/code&gt;类提供带有标题的组框框架。一个组框提供一个框架，一个标题，一个快捷键，并在其内部显示其他各种小部件。快捷键用于将键盘焦点移到组框的子窗口小部件之一。&lt;/p&gt;
&lt;p&gt;这里通过&lt;code&gt;setGeometry&lt;/code&gt;设置组框的大小和位置，调用&lt;code&gt;setTitle&lt;/code&gt;设置组框的标题。默认标题位置在左上，也可以通过&lt;code&gt;setAlignment&lt;/code&gt;来设置标题对齐方式。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1687684124415.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;qtoolbutton&#34;&gt;QToolButton&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;help_button = QtWidgets.QToolButton(self)
help_button.setGeometry(QtCore.QRect(320, 7, 30, 31))
help_button.setIcon(QtGui.QIcon(&amp;quot;help.png&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;QAbstractButton&lt;/code&gt;类为抽象类，不能实例化，必须由其他的按钮类继承&lt;code&gt;QAbstractButton&lt;/code&gt;类，来实现不同的功能和表现形式，常见的按钮&lt;code&gt;QPushButton&lt;/code&gt;，&lt;code&gt;QToolButton&lt;/code&gt;，&lt;code&gt;QRadioButton&lt;/code&gt;和&lt;code&gt;QCheckBox&lt;/code&gt;这些按钮均继承自QAbstractButton类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QToolButton&lt;/code&gt;类让我们可以快速地实现命令和选项按钮，它通常用在&lt;code&gt;QToolBar&lt;/code&gt;中。相比于普通的命令按钮&lt;code&gt;QPushButton&lt;/code&gt;，工具按钮通常不显示文本，只显示图标。&lt;/p&gt;
&lt;p&gt;这里通过调用&lt;code&gt;setIcon&lt;/code&gt;来设置按钮显示的图标，图标通过&lt;code&gt;QtGui.QIcon&lt;/code&gt;类创建。当然，也可以通过&lt;code&gt;setText&lt;/code&gt;来设置按钮显示文本。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1687684185037.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;qlabel&#34;&gt;QLabel&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Component_label = QtWidgets.QLabel(self)
Component_label.setGeometry(QtCore.QRect(20, 7, 100, 30))
Component_label.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)
Component_label.setText(&amp;quot;右下对齐&amp;quot;)
Component_label.setAlignment(QtCore.Qt.AlignBottom | QtCore.Qt.AlignRight)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1687684231543.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;QLabel&lt;/code&gt;是QT界面中的标签类，它从&lt;code&gt;QFrame&lt;/code&gt;下继承，&lt;code&gt;QLabel&lt;/code&gt;类代表标签，它是一个用于显示文本或图像的窗口部件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QLabel&lt;/code&gt;对象的显示内容可以包括纯文本，富文本，图像，动画，数字类型，当使用任何方法改变内容时，任何先前的内容都被清除。你可以通过属性获取或修改内容,主要如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;text()：获取显示的文本
setText()：设置纯文本和富文本内容
pixmap()：获取显示的图像 
setPixmap(QPixmap pixmap)：设置显示的图像
setNum(num)：设置显示的文本为代表数字num的字符串
setMovie(QMovie mov)：设置显示的动画
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：当在&lt;code&gt;QLabel&lt;/code&gt;中使用&lt;code&gt;setText()&lt;/code&gt;设置文本内容的时候，因为&lt;code&gt;QLabel&lt;/code&gt;会尝试猜测它是将文本显示为纯文本还是作为HTML 4标记的一部分的富文本。想明确地显示文本格式，请调用&lt;code&gt;setTextFormat()&lt;/code&gt;，例如如果您希望文本是纯文本格式，但无法控制文本源（显示从Web上加载的数据时等情况）。&lt;/p&gt;
&lt;p&gt;默认情况下，标签显示左对齐、垂直居中的文本和图像。&lt;code&gt;QLabel&lt;/code&gt;的外观可以通过多种方式进行调整和微调。&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;setFrameStyle&lt;/code&gt;来指定标签的样式，上面就指定了一个凹陷面板的样式。&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;setAlignment()&lt;/code&gt;和&lt;code&gt;setIndent()&lt;/code&gt;来调整&lt;code&gt;QLabel&lt;/code&gt;小部件区域内的对齐方式和缩进值。对于文本内容，还可以使用&lt;code&gt;setwordpwrap()&lt;/code&gt;指定沿单词边界换行。&lt;/p&gt;
&lt;p&gt;Qt中的组件对齐方式取值如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;1）Qt.AlignLeft:：水平方向靠左。
2）Qt.AlignRight：水平方向靠右。
3）Qt.AlignHCenter：水平方向居中。
4）Qt.AlignJustify：水平方向调整间距两端对齐。
5）Qt.AlignTop：垂直方向靠上。
6）Qt.AlignButton：垂直方向靠下。
7）Qt.AlignVCenter：垂直方向居中。
8）Qt.AlignCenter：等价于 Qt.AlignHCenter | Qt.AlignVCenter。
其中一个水平方向的取值和一个垂直方向的取值可以用 “|” 的方式组合起来以同时指定两个方向的对齐方式。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;qspinbox&#34;&gt;QSpinBox&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;newComponent = QtWidgets.QSpinBox(self.global_widget)
newComponent.setMinimum(0)
newComponent.setMaximum(100)
newComponent.setValue(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1687684267735.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;QSpinBox&lt;/code&gt;类用于整数的显示和输入，一般显示十进制数，也可以显示二进制、十六进制的数，而且可以在显示框中增加前缀或后缀。&lt;/p&gt;
&lt;p&gt;如果要显示浮点数，使用&lt;code&gt;QDoubleSpinBox&lt;/code&gt;用于浮点数的显示和输入，可以设置显示小数位数，也可以设置显示的前缀和后缀。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QSpinBox&lt;/code&gt;和&lt;code&gt;QDoubleSpinBox&lt;/code&gt;都是&lt;code&gt;QAbstractSpinBox&lt;/code&gt;的子类，具有大多数相同的属性，只是参数类型不同，通过属性的对应set方法就可以为其设置各项属性的值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QSpinBox&lt;/code&gt;的默认数值范围是0-99，默认每次变化步数1，用户可以通过设置属性自行修改范围和步数。&lt;/p&gt;
&lt;p&gt;常用的属性包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;prefix&lt;/strong&gt;：数字显示的前缀，例如“E”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;suffix&lt;/strong&gt;：数字显示的后缀，例如“cm”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;minimum&lt;/strong&gt;：数值范围的最小值，如 0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;maximum&lt;/strong&gt;：数值范围的最大值，如 255&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;singlestep&lt;/strong&gt;：单击右侧上下调整按钮时的单步改变值，如设置为 1，或 0.1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;：当前显示的值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;displaylntegerBase&lt;/strong&gt;：QSpinBox 特有属性，显示整数使用的进制，例如 2 就表示二进制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;decimals&lt;/strong&gt;：QDoubleSpinBox 特有属性，显示数值的小数位数，例如 2 就显示两位小数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;qcombobox&#34;&gt;QComboBox&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;newComponent = QtWidgets.QComboBox(self.global_widget)
newComponent.addItems([&amp;quot;选项1&amp;quot;, &amp;quot;选项2&amp;quot;])
newComponent.addItem(&amp;quot;选项3&amp;quot;)
newComponent.addItem(QtGui.QIcon(&amp;quot;help.png&amp;quot;), &amp;quot;选项4&amp;quot;)
newComponent.setCurrentIndex(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1687684289258.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;QComboBox&lt;/code&gt;是下拉列表框组件类，它提供一个下拉列表供用户选择，也可以直接当作一个&lt;code&gt;QLineEdit&lt;/code&gt;用作输入。&lt;code&gt;QComboBox&lt;/code&gt;除了显示可见下拉列表外，每个项（item，或称列表项）还可以关联一个&lt;code&gt;QVariant&lt;/code&gt;类型的变量，用于存储一些不可见数据。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;addItems&lt;/code&gt;可以一次性添加列表中的选项作为下拉框的选项。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;addItem&lt;/code&gt;可以添加一个新的下拉框选项，第一个参数为图标时，添加带图标的项，否则添加不带图标的项。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setCurrentIndex()&lt;/code&gt;用于指定当前默认显示的选项序号，注意序号从0开始。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;currentlndex()&lt;/code&gt;返回当前选择的选项序号，&lt;code&gt;currentText()&lt;/code&gt;返回当前选择项的文字，&lt;code&gt;currentData()&lt;/code&gt;返回当前选择项关联的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setView(QAbstractItemView)&lt;/code&gt;设置&lt;code&gt;QComboBox&lt;/code&gt;下拉框的样式，可以是列表、树、表格等格式。&lt;/p&gt;
&lt;h3 id=&#34;qcheckbox&#34;&gt;QCheckBox&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;newComponent = QtWidgets.QCheckBox(self.global_widget)
newComponent.setChecked(False)


newComponent_1 = QtWidgets.QCheckBox(self.global_widget)
newComponent_1.setTristate(True)
newComponent.setCheckState(QtCore.Qt.PartiallyChecked)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1687684305506.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;QCheckBox&lt;/code&gt; 是 Qt 里的复选框控件，一般来说复选框通常用于表示可以启用或禁用的应用程序中的功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QCheckBox&lt;/code&gt;继承自&lt;code&gt;QAbstractButton&lt;/code&gt;，它提供了一个带文本标签的复选框。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QCheckBox&lt;/code&gt;（复选框）和&lt;code&gt;QRadioButton&lt;/code&gt;（单选框）都是选项按钮。这是因为它们都可以在开（选中）或者关（未选中）之间切换。区别是对用户选择的限制：单选框定义了“多选一”的选择，而复选框提供的是“多选多”的选择。&lt;/p&gt;
&lt;p&gt;只要复选框被选中或者清除，都会发射一个&lt;code&gt;stateChanged()&lt;/code&gt;信号。如果想在复选框状态改变的时候触发一个行为，请连接这个信号，可以使用&lt;code&gt;isChecked()&lt;/code&gt;来查询复选框是否被选中。&lt;/p&gt;
&lt;p&gt;除了常用的选中和未选中两个状态，&lt;code&gt;QCheckBox&lt;/code&gt;还可选地提供了第三种状态（半选）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QCheckBox&lt;/code&gt;类中常用方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;setChecked()：设置复选框的状态，设置为True表示选中，False表示取消选中的复选框
setText()：设置复选框的显示文本
text()：返回复选框的显示文本
isChecked()：检查复选框是否被选中
setTriState()：设置复选框为一个三态复选框
setCheckState()：设置三态复选框的状态
CheckState()：获取当前三态复选框的状态
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;三态复选框的三种状态如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;Qt.Checked：值为2，表示组件没有被选中（默认）
Qt.PartiallyChecked：值为1，表示组件被半选中
Qt.Unchecked：值为0，表示组件被选中
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;qslider&#34;&gt;QSlider&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;newComponent = QtWidgets.QSlider(self.global_widget)
newComponent.setMinimum(1)
newComponent.setMaximum(100)
newComponent.setValue(50)
newComponent.setOrientation(QtCore.Qt.Horizontal)

sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
sizePolicy.setHorizontalStretch(0)
sizePolicy.setVerticalStretch(0)
sizePolicy.setHeightForWidth(newComponent.sizePolicy().hasHeightForWidth())
newComponent.setSizePolicy(sizePolicy)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1687684344601.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;QSlider&lt;/code&gt;控件提供一个垂直或者水平的滑动条，滑动条是一个用于控制有界值典型的控件，它允许用户沿水平或者垂直方向在某一范围内移动滑块，并将滑块所在的位置转换为一个合法范围内的整数值。&lt;/p&gt;
&lt;p&gt;这种方式比输入数字或者使用&lt;code&gt;QSpinBox&lt;/code&gt;（计数器）更加自然，在槽函数中对滑块所在位置的处理相当于从整数之间的最小值和最高值进行取值。&lt;/p&gt;
&lt;p&gt;滑块条控件可以以垂直或者水平的方式显示，通过&lt;code&gt;setOrientation&lt;/code&gt;来控制显示方向，可选的取值为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;Qt.Horizontal 水平显示
Qt.Vertical   垂直显示
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作为一个获取整数输入的控件，它与&lt;code&gt;QSpinBox&lt;/code&gt;之间有着不少相似的属性。常见的&lt;code&gt;QSlider&lt;/code&gt;类属性设置方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;setMinimum()：设置滑动条控件的最小值
setMaximum()：设置滑动条控件的最大值
setSingleStep()：设置滑动条控件的步长
setValue()：设置滑动条控件的值
value()：获取滑动条控件的值
setTickInterval()：设置刻度间隔
setTickPosition()：设置刻度标记的位置，可以输入一个枚举值，这个枚举值指定刻度线想当与滑块和用户操作的位置。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;刻度标记位置位置的可选取值以及含义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;QSlider.NoTicks：不绘制任何刻度线
QSlider.TicksBothSides：在滑块的两侧绘制刻度线
QSlider.TicksAbove：在滑块的（水平）上方绘制刻度线
QSlider.TicksBelow：在滑块的（水平）下方绘制刻度线
QSlider.TicksLeft：在滑块的（垂直）左侧绘制刻度线
QSlider.TicksRight：在滑块的（垂直）右侧绘制刻度线
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;QSlider类中的常用信号包括：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;valueChanged：当滑块的值发生改变时发射此信号，此信号是最常用的
sliderPressed：当用户按下滑块时发射此信号
sliderMoved：当用户拖动滑块时发射此信号
sliderReleased：当用户释放滑块时发射此信号
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;QSizePolicy&lt;/code&gt;是用于描述水平或垂直布局调整的属性。&lt;code&gt;setHorizontalPolicy()&lt;/code&gt;确定水平调整级别，&lt;code&gt;setVerticalPolicy()&lt;/code&gt;确定垂直调整级别，也可以创建时一次性设置两个布局策略。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QSizePolicy&lt;/code&gt;的大小策略可选取值及含义如下：&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1687684380292.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里使用sizePolicy来控制silder的长度和位置，因为在默认情况下，它会紧挨着上个控件的位置开始。&lt;/p&gt;
&lt;h3 id=&#34;qpushbutton&#34;&gt;QPushButton&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;default_para = QtWidgets.QPushButton(self)
default_para.setGeometry(QtCore.QRect(10, 400, 91, 23))
default_para.setText(&amp;quot;恢复默认参数&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1687685825123.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;QPushButton&lt;/code&gt;小部件提供了一个命令按钮。按钮或命令按钮可能是任何图形用户界面中最常用的小部件。按下（或者单击）按钮以命令计算机执行某个操作。&lt;/p&gt;
&lt;p&gt;一个命令按钮是矩形的，通常显示一个描述其动作的文本标签，还可以选择一个小图标。&lt;/p&gt;
&lt;p&gt;显示内容可以使用构造函数在创建时就设置，也稍后使用&lt;code&gt;setText()&lt;/code&gt;和&lt;code&gt;setIcon()&lt;/code&gt;设置和更改。&lt;/p&gt;
&lt;p&gt;如果该按钮被禁用，文本和图标的外观与GUI风格相关，以使按钮看起来“禁用”。&lt;/p&gt;
&lt;p&gt;当按钮被鼠标，空格键或键盘快捷键激活时，按钮发出&lt;code&gt;clicked()&lt;/code&gt;信号。连接到这个信号来执行按钮的动作。按钮也提供其他较少使用的信号，例如&lt;code&gt;pressed()&lt;/code&gt;和&lt;code&gt;released()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QPushButton&lt;/code&gt;类中的常用方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;setCheckable()：设置按钮是否已经被选中，如果设置True，则表示按钮将保持已点击和释放状态
toggle()：在按钮状态之间进行切换
setIcon()：设置按钮上的图标
setEnabled()：设置按钮是否可以使用，当设置为False时，按钮变成不可用状态，点击它不会发射信号
isChecked()：返回按钮的状态，返回值为True或者False
setDefault()：设置按钮的默认状态
setText()：设置按钮的显示文本
text()：返回按钮的显示文本
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过按钮名字能为&lt;code&gt;QPushButton&lt;/code&gt;设置快捷键，比如名字为‘&amp;amp;Download’的按键，它的快捷键是‘Alt+D’。&lt;/p&gt;
&lt;p&gt;快捷键规则是;想要实现快捷键为“Alt+D”，那么按钮的名字里需要有D这个字母，并且在D的前面加上“&amp;amp;”。一般来说，我们用首字母设置快捷键，而且在按钮显示时“&amp;amp;”不会显示出来，如果想显示该字符，那么需要转义使用。&lt;/p&gt;
&lt;h3 id=&#34;qprogressbar&#34;&gt;QProgressBar&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;progressBar = QtWidgets.QProgressBar(self)
progressBar.setGeometry(QtCore.QRect(10, 430, 350, 23))
progressBar.setValue(10)
progressBar.setStyleSheet(&amp;quot;QProgressBar { border: 2px solid grey; border-radius: 5px; color: rgb(20,20,20);  background-color: #FFFFFF; text-align: center;}QProgressBar::chunk {background-color: rgb(100,200,200); border-radius: 10px; margin: 0.1px;  width: 1px;}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1687685836102.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;QProgressBar&lt;/code&gt;控件提供了水平或者垂直的进度条，它以动画的形式显示程序的处理进度。 可以通过设置属性来设置进度条的最小值、最大值和当前值显示进度，最小值和最大值默认分别为0和99。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QPushButton&lt;/code&gt;类中的常用方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;setRange()：设置进度条的取值范围(最小值和最大值)
setMinimum()：设置进度条的最小值
setFont():设置文本字体
setMaximum()：设置进度条的最大值
setValue()：设置进度条的值
reset()：让进度条重新回到开始位置
setOrientation()：设置进度条方向(水平: Qt.Horizontal, 垂直: Qt.Vertical)
setTextVisible()：设置进度条的文本是否可见
setTextDirection()：设置文本方向，只对垂直进度条有效
setInvertedAppearance()：设置进度条的方向(True/False:正反方向)
setFormat()：设置文本字符串的格式(%p, 百分比显示,这是默认情况, %v: 当前进度, %m :总步数)
setStyleSheet()：设置进度条的样式，需要一定的样式基础。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;qvboxlayoutqhboxlayout&#34;&gt;QVBoxLayout/QHBoxLayout&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;self.global_layout = QtWidgets.QVBoxLayout(self.global_widget)
self.global_layout.setContentsMargins(0, 0, 0, 0)

horizontalLayout = QtWidgets.QHBoxLayout()
horizontalLayout.addWidget(Component_label，1)
horizontalLayout.addWidget(Component，1)

self.global_layout.addLayout(horizontalLayout)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;QVBoxLayout&lt;/code&gt;是Qt中的垂直布局类，用于在垂直方向上排列GUI组件。类似地，有&lt;code&gt;QHBoxLayout&lt;/code&gt;类，用于在水平方向上排列GUI组件。&lt;/p&gt;
&lt;p&gt;使用布局类能让程序具有更强的适应性，这个才是布局一个应用的更合适的方式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setContentsMargins&lt;/code&gt;设置左、上、右、下的外边距，可以将左、上、右、下的外边距设置为不同的值。&lt;/p&gt;
&lt;p&gt;通过调用&lt;code&gt;addWidget&lt;/code&gt;可以将&lt;code&gt;QtWidget&lt;/code&gt;的组件加入到布局中，第一个参数为要加入的组件，第二个为可选参数，代表显示组件比例。类似地，调用&lt;code&gt;addLayout&lt;/code&gt;方法，可以将新的布局添加进当前布局内部。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;addStretch&lt;/code&gt;可以在布局中添加一个可伸缩的控件QSpaceItem，0为最小值，并将其作为伸缩量添加到布局，参数为一个整数表示控件的比例，默认为0。&lt;/p&gt;
&lt;h3 id=&#34;一个完整的用例&#34;&gt;一个完整的用例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys
from Qt import QtWidgets, QtCore, QtGui


class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.head_widget = None
        self.head_layout = None
        self.global_layout = None
        self.global_widget = None
        self.global_group = None
        self.initUI()

    def initUI(self):
        self.setWindowTitle(&amp;quot;simple test&amp;quot;)
        self.setGeometry(1800, 100, 385, 480)
        self.setGlobalUI()
        self.setHeaderUI()
        self.setBottomUI()
        self.show()

    def add_SpinBox(self):
        Component_label = QtWidgets.QLabel(self.global_widget)
        Component_label.setText(&amp;quot;微调框&amp;quot;)

        newComponent = QtWidgets.QSpinBox(self.global_widget)
        newComponent.setMinimum(0)
        newComponent.setMaximum(100)
        newComponent.setValue(1)

        self.add_layout(Component_label, newComponent)

    def add_ComboBox(self):
        Component_label = QtWidgets.QLabel(self.global_widget)
        Component_label.setText(&amp;quot;下拉框&amp;quot;)
        newComponent = QtWidgets.QComboBox(self.global_widget)
        newComponent.addItems([&amp;quot;选项1&amp;quot;, &amp;quot;选项2&amp;quot;])
        newComponent.addItem(&amp;quot;选项3&amp;quot;)
        newComponent.addItem(QtGui.QIcon(&amp;quot;help.png&amp;quot;), &amp;quot;选项4&amp;quot;)
        newComponent.setCurrentIndex(1)

        self.add_layout(Component_label, newComponent)

    def add_Slider(self):
        Component_label = QtWidgets.QLabel(self.global_widget)
        Component_label.setText(&amp;quot;滑动条&amp;quot;)
        newComponent = QtWidgets.QSlider(self.global_widget)
        newComponent.setMinimum(1)
        newComponent.setMaximum(100)
        newComponent.setValue(50)
        newComponent.setOrientation(QtCore.Qt.Horizontal)

        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(newComponent.sizePolicy().hasHeightForWidth())
        newComponent.setSizePolicy(sizePolicy)

        self.add_layout(Component_label, newComponent)

    def add_CheckBox(self):
        Component_label = QtWidgets.QLabel(self.global_widget)
        Component_label.setText(&amp;quot;复选框&amp;quot;)
        newComponent = QtWidgets.QCheckBox(self.global_widget)
        newComponent.setChecked(True)

        self.add_layout(Component_label, newComponent)

        Component_label = QtWidgets.QLabel(self.global_widget)
        Component_label.setText(&amp;quot;三态复选框&amp;quot;)
        newComponent = QtWidgets.QCheckBox(self.global_widget)
        newComponent.setTristate(True)
        newComponent.setCheckState(QtCore.Qt.PartiallyChecked)

        self.add_layout(Component_label, newComponent)

    def add_layout(self, Component_label, Component):
        horizontalLayout = QtWidgets.QHBoxLayout()
        horizontalLayout.addWidget(Component_label)
        horizontalLayout.addWidget(Component)

        self.global_layout.addLayout(horizontalLayout)

    def setGlobalUI(self):
        self.global_group = QtWidgets.QGroupBox(self)
        self.global_widget = QtWidgets.QWidget(self.global_group)
        self.global_layout = QtWidgets.QVBoxLayout(self.global_widget)

        self.global_group.setGeometry(QtCore.QRect(10, 40, 360, 350))
        self.global_group.setTitle(&amp;quot;全局&amp;quot;)

        self.global_widget.setGeometry(QtCore.QRect(20, 20, 330, 320))

        self.global_layout.setContentsMargins(0, 0, 0, 0)

        self.add_SpinBox()
        self.add_ComboBox()
        self.add_Slider()
        self.add_CheckBox()

    def setHeaderUI(self):
        help_button = QtWidgets.QToolButton(self)
        help_button.setGeometry(QtCore.QRect(320, 7, 30, 31))
        help_button.setIcon(QtGui.QIcon(&amp;quot;help.png&amp;quot;))

        Component_label = QtWidgets.QLabel(self)
        Component_label.setGeometry(QtCore.QRect(20, 7, 100, 30))
        Component_label.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)
        Component_label.setText(&amp;quot;右下对齐&amp;quot;)
        Component_label.setAlignment(QtCore.Qt.AlignBottom | QtCore.Qt.AlignRight)

    def setBottomUI(self):
        default_para = QtWidgets.QPushButton(self)
        default_para.setGeometry(QtCore.QRect(10, 400, 91, 23))
        default_para.setText(&amp;quot;恢复默认参数&amp;quot;)

        progressBar = QtWidgets.QProgressBar(self)
        progressBar.setGeometry(QtCore.QRect(10, 430, 350, 23))
        progressBar.setValue(10)
        progressBar.setStyleSheet(
            &amp;quot;QProgressBar { border: 2px solid grey; border-radius: 5px; color: rgb(20,20,20);  background-color: #FFFFFF; text-align: center;}QProgressBar::chunk {background-color: rgb(100,200,200); border-radius: 10px; margin: 0.1px;  width: 1px;}&amp;quot;)


if __name__ == &#39;__main__&#39;:
    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow()

    sys.exit(app.exec_())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1687684410796.png&#34; alt=&#34;完整用例&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里将上述的控件都使用上，通过从初始化函数的调用，添加各个控件，在主线程中启动Qt程序并显示。&lt;/p&gt;
">[Python] QT简易使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/yUgU6O2CS/"" data-c="
          &lt;p&gt;本篇博客是对应于上一篇博客：&lt;a href=&#34;https://wjcsw.github.io/Jdib0wfCY/&#34;&gt;Python下自定义数据导出为FBX&lt;/a&gt;，这篇博客主要介绍如何将FBX模型中的UV数据提取出来。&lt;/p&gt;
&lt;h2 id=&#34;1-初始化fbx设置&#34;&gt;1. 初始化FBX设置&lt;/h2&gt;
&lt;p&gt;首先要做的就是是创建FBX SDK管理器，它几乎是所有FBX SDK中的类的对象分配器。&lt;/p&gt;
&lt;p&gt;接着，创建FBX IO设置，并为FBX SDK管理器设置IO设置。&lt;/p&gt;
&lt;p&gt;然后，创建一个空白的场景，用于读入数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lSdkManager = FbxManager.Create()
if not lSdkManager:
    sys.exit(0)

ios = FbxIOSettings.Create(lSdkManager, IOSROOT)
lSdkManager.SetIOSettings(ios)

lScene = FbxScene.Create(lSdkManager, &amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-导入模型&#34;&gt;2. 导入模型&lt;/h2&gt;
&lt;p&gt;导入模型时，先创建&lt;code&gt;FbxImporter&lt;/code&gt;并初始化，&lt;code&gt;Initialize&lt;/code&gt; 方法的第一个参数是导入文件保存路径，第二个参数表示导入的FBX文件类型，这里1代表为ASCii码格式。然后，调用该对象的&lt;code&gt;Import&lt;/code&gt;方法将fbx模型导入到当前的场景，最后使用&lt;code&gt;GetRootNode&lt;/code&gt;获取场景的根节点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def import_scene(fbxManager, fbxScene, fbxFilePath):
    lImporter = FbxImporter.Create(fbxManager, &amp;quot;&amp;quot;)
    result = lImporter.Initialize(fbxFilePath, 1, fbxManager.GetIOSettings())
    if not result:
        return False

    result = lImporter.Import(fbxScene)
    lImporter.Destroy()

    fbxIOSettings = FbxIOSettings.Create(fbxManager, IOSROOT)
    fbxManager.SetIOSettings(fbxIOSettings)

    if not result:
        raise IOError(&amp;quot;load file [{}] failed&amp;quot;.format(fbxFilePath))
    fbxRootNode = fbxScene.GetRootNode()

    return fbxRootNode, fbxIOSettings
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-读入模型uv数据&#34;&gt;3. 读入模型UV数据&lt;/h2&gt;
&lt;h3 id=&#34;31-读入mesh数据&#34;&gt;3.1 读入mesh数据&lt;/h3&gt;
&lt;p&gt;首先，通过&lt;code&gt;GetChild(i)&lt;/code&gt;遍历获取fbx文件中的每个模型，然后调用&lt;code&gt;GetMesh&lt;/code&gt;获取每个模型的mesh数据。&lt;/p&gt;
&lt;p&gt;下一步，使用 &lt;code&gt;GetControlPoints() &lt;/code&gt;方法获取网格的控制点。然后，我们遍历控制点，并将每个控制点的坐标存储在 &lt;code&gt;vertices&lt;/code&gt; 数组中。&lt;/p&gt;
&lt;p&gt;接下来，我们使用 &lt;code&gt;GetPolygonCount()&lt;/code&gt; 方法获取网格的多边形数，并使用 &lt;code&gt;GetPolygonSize()&lt;/code&gt; 和 &lt;code&gt;GetPolygonVertex()&lt;/code&gt; 方法获取每个多边形的顶点索引，并将它们存储在 &lt;code&gt;faces&lt;/code&gt; 数组中。&lt;/p&gt;
&lt;p&gt;最后，我们使用 &lt;code&gt;GetNormals()&lt;/code&gt; 方法获取网格的法线数据，并将它们存储在 &lt;code&gt;normals&lt;/code&gt; 数组中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(fbxRootNode.GetChildCount()):
    fbxMesh = fbxRootNode.GetChild(i)
    if fbxMesh is None:
        raise RuntimeError(&amp;quot;The node is null!&amp;quot;)
    fbxMeshName = fbxMesh.GetName()

    mesh = fbxMesh.GetMesh()

    # 提取顶点数据
    vertices = []
    control_points = mesh.GetControlPoints()
    for i in range(mesh.GetControlPointsCount()):
        vertices.append((control_points[i][0], control_points[i][1], control_points[i][2]))

    # 提取面数据
    faces = []
    polygon_count = mesh.GetPolygonCount()
    for i in range(polygon_count):
        polygon_size = mesh.GetPolygonSize(i)
        for j in range(polygon_size):
            faces.append(mesh.GetPolygonVertex(i, j))

    # 提取法线数据
    normals = []
    layer_element_normal = mesh.GetLayer(0).GetNormals()
    if layer_element_normal:
        for i in range(mesh.GetPolygonCount() * 3):
            normal = layer_element_normal.GetDirectArray().GetAt(i)
            normals.append((normal[0], normal[1], normal[2]))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;32-读入uv数据&#34;&gt;3.2 读入UV数据&lt;/h3&gt;
&lt;p&gt;对于UV数据，直接调用&lt;code&gt;GetElementUV&lt;/code&gt;方法即可获取对应名称的UV数据&lt;/p&gt;
&lt;p&gt;然后用&lt;code&gt;UVValue&lt;/code&gt;存放UV中的顶点数据，用&lt;code&gt;UVIndex&lt;/code&gt;存放面中的顶点序号数组，用&lt;code&gt;UVCount&lt;/code&gt;存放每个面的顶点数目。&lt;/p&gt;
&lt;p&gt;通过UV数据的&lt;code&gt;GetDirectArray()&lt;/code&gt;可以访问其顶点数组，通过&lt;code&gt;GetIndexArray()&lt;/code&gt;可以访问面的顶点序号数组。&lt;br&gt;
接着分别调用对应数组的&lt;code&gt;GetAt&lt;/code&gt;方法获取对应的数据存入&lt;code&gt;UVValue&lt;/code&gt;和&lt;code&gt;UVIndex&lt;/code&gt;，最后使用&lt;code&gt;GetPolygonSize&lt;/code&gt;方法获取每个面的大小存入&lt;code&gt;UVCount&lt;/code&gt;中.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    try:
        # init output uv data
        UVValue = []
        UVIndex = []
        UVCount = []
        UVData = mesh.GetElementUV(&amp;quot;map01&amp;quot;)
    
        numVtx = UVData.GetDirectArray().GetCount()
        numIndex = UVData.GetIndexArray().GetCount()

        # separate uv data: value, index, count
        for i in range(numVtx):
            UVValue.append(UVData.GetDirectArray().GetAt(i)[0])
            UVValue.append(UVData.GetDirectArray().GetAt(i)[1])
        for j in range(numIndex):
            UVIndex.append(UVData.GetIndexArray().GetAt(j))
        for k in range(mesh.GetPolygonCount()):
            UVCount.append(mesh.GetPolygonSize(k))

    except Exception as e:
        runtime_msg.popup_msgbox(info_loader.return_tips_msg(plugin_msg_code.PLUGIN_E_WRITE_UV))
        raise e

&lt;/code&gt;&lt;/pre&gt;
">[Python] 从FBX文件中读取数据</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/python-zhong-de-xing-neng-fen-xi-nei-zhi-de-cprofile/"" data-c="
          &lt;h2 id=&#34;1-什么是性能分析&#34;&gt;1. 什么是性能分析&lt;/h2&gt;
&lt;p&gt;没有优化过的程序通常会在某些子程序（subroutine）上消耗大部分的CPU指令周期（CPU cycle）。性能分析就是分析代码和它正在使用的资源之间有着怎样的关系。例如，性能分析可以告诉你一个指令占用了多少CPU时间，或者整个程序消耗了多少内存。性能分析是通过使用一种被称为性能分析器（profiler）的工具，对程序或者二进制可执行文件（如果可以拿到）的源代码进行调整来完成的。&lt;/p&gt;
&lt;p&gt;通常，当需要优化程序性能，或者程序遇到了一些奇怪的bug时（一般与内存泄漏有关），开发者会对他们的程序进行性能分析。这时，性能分析可以帮助开发者深刻地了解程序是如何使用计算机资源的（即可以细致到一个函数被调用了多少次）。&lt;/p&gt;
&lt;p&gt;根据这些信息，以及对源代码的深刻认知，开发者就可以找到程序的性能瓶颈或者内存泄漏所在，然后修复错误的代码。&lt;/p&gt;
&lt;p&gt;程序性能分析的作用主要有以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发现性能瓶颈：通过性能分析，可以找到程序中的性能瓶颈，即程序中执行时间最长的部分，从而可以有针对性地进行优化，提高程序的执行效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;评估程序性能：通过性能分析，可以对程序的性能进行评估，了解程序的执行效率和资源占用情况，从而可以对程序进行优化和改进。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比较不同实现方案的性能：通过性能分析，可以比较不同实现方案的性能，从而可以选择最优的实现方案，提高程序的执行效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;预测程序的性能：通过性能分析，可以预测程序在不同的环境下的性能表现，从而可以提前发现问题并进行优化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优化程序性能：通过性能分析，可以找到程序中的性能瓶颈，并进行优化，从而提高程序的执行效率，减少资源占用，提高用户体验。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;帮助我们进行性能分析的工具便是性能分析器，它主要分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于事件的性能分析(event-based profiling)&lt;/li&gt;
&lt;li&gt;统计式的性能分析(statistical profiling)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;11-基于事件的性能分析&#34;&gt;1.1 基于事件的性能分析&lt;/h3&gt;
&lt;p&gt;不是所有的编程语言都支持这类性能分析。支持这类基于事件的性能分析的编程语言主要有以下几种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Java：JVMTI（JVM Tools Interface，JVM工具接口）为性能分析器提供了钩子，可以跟踪诸如函数调用、线程相关的事件、类加载之类的事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.NET：和Java一样，.NET运行时提供了事件跟踪功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python： 开发者可以用sys.setprofile函数，跟踪python_[call|return|exception]或c_[ call | return | exception ] 之类的事件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;基于事件的性能分析器&lt;/strong&gt;（event-based profiler，也称为&lt;strong&gt;轨迹性能分析器&lt;/strong&gt;，tracing profiler）是通过收集程序执行过程中的具体事件进行工作的。这些性能分析器会产生大量的数据。基本上，它们需要监听的事件越多，产生的数据量就越大。这导致它们不太实用，在开始对程序进行性能分析时也不是首选。但是，当其他性能分析方法不够用或者不够精确时，它们可以作为最后的选择。如果你想分析程序中所有返回语句的性能，那么这类性能分析器就可以为你提供完成任务应该有的颗粒度，而其他性能分析器都不能为你提供如此细致的结果。&lt;/p&gt;
&lt;h3 id=&#34;12-统计式性能分析&#34;&gt;1.2 统计式性能分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;统计式性能分析器&lt;/strong&gt;以固定的时间间隔对程序计数器（program counter）进行&lt;strong&gt;抽样统计&lt;/strong&gt;。这样做可以让开发者掌握目标程序在每个函数上消耗的时间。由于它对程序计数器进行抽样，所以数据结果是&lt;strong&gt;对真实值的统计近似&lt;/strong&gt;。不过，这类软件足以窥见被分析程序的性能细节，查出性能瓶颈之所在。&lt;/p&gt;
&lt;p&gt;这类性能分析软件的优点如下所示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分析的数据更少&lt;/strong&gt;：由于我们只对程序执行过程进行抽样，而不用保留每一条数据，因此需要分析的信息量会显著减少。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对性能造成的影响更小&lt;/strong&gt;：由于使用抽样的方式（用操作系统中断），目标程序的性能遭受的干扰更小。虽然使用性能分析器并不能做到100%无干扰，但是统计式性能分析器比基于事件的性能分析器造成的干扰要小。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Python中最常用的性能分析工具主要有：&lt;code&gt;cProfiler&lt;/code&gt;, &lt;code&gt;line_profiler&lt;/code&gt;以及&lt;code&gt;memory_profiler&lt;/code&gt; 等。他们以不同的方式帮助我们分析Python代码的性能。这里主要关注Python内置的&lt;code&gt;cProfiler&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;2-一个简单的例子&#34;&gt;2. 一个简单的例子&lt;/h2&gt;
&lt;p&gt;以官方文档的一个简单例子来介绍该模块，通过简单的几行代码就可以对程序进行性能分析。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import cProfile
import re
cProfile.run(&#39;re.compile(&amp;quot;foo|bar&amp;quot;)&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;197 function calls (192 primitive calls) in 0.002 seconds
Ordered by: standard name
ncalls  tottime  percall  cumtime  percall filename:lineno(function)
    1    0.000    0.000    0.001    0.001 &amp;lt;string&amp;gt;:1(&amp;lt;module&amp;gt;)
    1    0.000    0.000    0.001    0.001 re.py:212(compile)
    1    0.000    0.000    0.001    0.001 re.py:268(_compile)
    1    0.000    0.000    0.000    0.000 sre_compile.py:172(_compile_charset)
    1    0.000    0.000    0.000    0.000 sre_compile.py:201(_optimize_charset)
    4    0.000    0.000    0.000    0.000 sre_compile.py:25    (_identityfunction)
3/1    0.000    0.000    0.000    0.000 sre_compile.py:33(_compile)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从分析报告结果中我们可以得到很多信息，包含了程序中的函数调用次数、总时间、平均时间、累计时间等。具体解释如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;总共有197个函数调用，其中有192个是原始函数调用（primitive calls）。&lt;/li&gt;
&lt;li&gt;程序总共执行了0.002秒。&lt;/li&gt;
&lt;li&gt;按照函数名的字母顺序排序，显示了每个函数的调用次数、总时间、平均时间、累计时间等信息。
&lt;ul&gt;
&lt;li&gt;第一列&lt;strong&gt;ncalls&lt;/strong&gt;表示函数调用次数。&lt;/li&gt;
&lt;li&gt;第二列&lt;strong&gt;tottime&lt;/strong&gt;表示函数总共执行的时间，不包括子函数的执行时间。&lt;/li&gt;
&lt;li&gt;第三列&lt;strong&gt;percall&lt;/strong&gt;表示函数平均执行时间，等于tottime/ncalls。&lt;/li&gt;
&lt;li&gt;第四列&lt;strong&gt;cumtime&lt;/strong&gt;表示函数总共执行的时间，包括子函数的执行时间。&lt;/li&gt;
&lt;li&gt;第五列&lt;strong&gt;percall&lt;/strong&gt;表示函数平均执行时间，等于cumtime/ncalls。&lt;/li&gt;
&lt;li&gt;最后一列&lt;strong&gt;filename&lt;/strong&gt;:&lt;strong&gt;lineno&lt;/strong&gt;(&lt;strong&gt;function&lt;/strong&gt;)表示函数所在的文件名、行号和函数名。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从这个性能分析结果可以看出，程序中最耗时的函数是&lt;code&gt;re.py&lt;/code&gt;中的&lt;code&gt;compile&lt;/code&gt;函数，它被调用了1次，总共执行了0.001秒，占据了程序总共执行时间的一半以上。因此，如果要优化程序的性能，就需要重点关注这个函数，找出其中的性能瓶颈并进行优化。&lt;/p&gt;
&lt;h2 id=&#34;3-进阶分析&#34;&gt;3. 进阶分析&lt;/h2&gt;
&lt;p&gt;Python进行性能分析最主要使用两个类：&lt;code&gt;cProfile&lt;/code&gt;模块的&lt;code&gt;Profile&lt;/code&gt;类和&lt;code&gt;pstat&lt;/code&gt;模块的&lt;code&gt;Stats&lt;/code&gt;类。&lt;/p&gt;
&lt;p&gt;下面介绍下部分重要的函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Profile类&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;cProfile&lt;/code&gt;模块的&lt;code&gt;Profile&lt;/code&gt;类主要用于收集分析数据和创建分析结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enable(): 开始收集性能分析数据
disable(): 停止收集性能分析数据
create_stats(): 停止收集分析数据，并为已收集的数据创建stats对象
print_stats(): 创建stats对象并打印分析结果
dump_stats(filename): 把当前性能分析的结果写入文件(二进制格式)
runcall(func, *args, **kwargs): 收集被调用函数func的性能分析数据
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Stats类&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;pstats&lt;/code&gt;模块提供的Stats类可以帮助我们读取和操作stats文件（二进制格式）&lt;br&gt;
&lt;code&gt;Stats类&lt;/code&gt;可以接受stats文件名，也可以直接接受&lt;code&gt;cProfile.Profile&lt;/code&gt;对象作为数据源。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;strip_dirs(): 删除报告中所有函数文件名的路径信息
dump_stats(filename): 把stats中的分析数据写入文件（效果同cProfile.Profile.dump_stats())
sort_stats(*keys): 对报告列表进行排序，函数会依次按照传入的参数排序，关键词包括calls, cumtime等，具体参数参见https://docs.python.org/2/library/profile.html#pstats.Stats.sort_stats
reverse_order(): 逆反当前的排序
print_stats(*restrictions): 把信息打印到标准输出。*restrictions用于控制打印结果的形式, 例如(10, 1.0, &amp;quot;.*.py.*&amp;quot;)表示打印所有py文件的信息的前10行结果。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过利用这两个类，可以更加自由地使用性能分析，可以针对某一部分代码使用性能分析，并使用Stats类进一步对分析结果进行整合和处理，下面给出一个使用的例子模板：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import cProfile, pstats, io
pr = cProfile.Profile()
pr.enable()
# ---- do something ----
create_main_window()
# ---- do something ----
pr.disable()
with open(&amp;quot;time_cost.txt&amp;quot;,&amp;quot;w+&amp;quot;) as f:
    ps = pstats.Stats(pr, stream=f).sort_stats(2)
    ps.print_stats()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将需要分析的代码放在&lt;code&gt;do something&lt;/code&gt;的部分中，即可获得对该部分代码的性能分析。其中&lt;code&gt;sort_stats(2)&lt;/code&gt;代表按照&lt;strong&gt;cumtime&lt;/strong&gt;（累计时间）排序。&lt;/p&gt;
&lt;h2 id=&#34;4-模块化封装&#34;&gt;4. 模块化封装&lt;/h2&gt;
&lt;p&gt;在上面的基础上，我们已经可以很方便的进行性能分析。但是，每次使用时都要加上一大段代码，在测试完毕后再将其删除，显然是不够简洁和方便。因此，我们可以通过写一个&lt;strong&gt;带有参数的装饰器&lt;/strong&gt;，这样想分析项目中任何一个函数，便可方便的使用装饰器来达到目的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import cProfile
import pstats
from functools import wraps
import os

def profile(sort_by=&#39;cumulative&#39;, lines=10, filename=None):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            PROF_FLAG = os.getenv(&amp;quot;PROFILING&amp;quot;)
            if PROF_FLAG:
                profiler = cProfile.Profile()
                profiler.enable()
                result = func(*args, **kwargs)
                profiler.disable()
                stats = pstats.Stats(profiler).sort_stats(sort_by)
                stats.print_stats(lines)
                if filename:
                    stats.dump_stats(filename)
                else:
                    result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个装饰器接受三个参数：&lt;strong&gt;sort_by、lines和filename&lt;/strong&gt;。&lt;strong&gt;sort_by&lt;/strong&gt;表示按照哪个指标进行排序，默认为&#39;cumulative&#39;，表示按照函数的累计时间进行排序；&lt;strong&gt;lines&lt;/strong&gt;表示显示多少行结果，默认为10；&lt;strong&gt;filename&lt;/strong&gt;表示将分析结果存储到哪个文件中，默认为None，表示不存储。&lt;/p&gt;
&lt;p&gt;使用方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@profile(sort_by=&#39;cumulative&#39;, lines=20, filename=&#39;result.prof&#39;)
def my_function():
    # 函数代码

# 调用函数时自动执行性能分析
my_function()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;装饰器函数中通过&lt;code&gt;sys.getenv&lt;/code&gt;来获取环境变量判断是否需要进行分析，只需通过设置环境变量来告诉程序是否进行性能分析，当测试完毕后无需删除代码，只需更改环境变量即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;export PROFILING=y
# run the program...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;程序跑完后便会在当前路径下生成对应的分析文件，我们便可以通过打印或者可视化工具来对这个函数进行分析。&lt;/p&gt;
&lt;h2 id=&#34;5-结果分析&#34;&gt;5. 结果分析&lt;/h2&gt;
&lt;p&gt;按照上文的方法，我们通过装饰器对运行的函数进行修饰来进行性能分析，这样我们便可以像正常一样去跑程序，但是不同的是当前路径下会生成性能分析报告文件。&lt;/p&gt;
&lt;p&gt;生成的这个文件为.&lt;strong&gt;prof&lt;/strong&gt;文件，它是一个二进制文件，一个简单的读取方式是用python的&lt;code&gt;pstats&lt;/code&gt;模块的接口来读取。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ps = pstats.Stats(&amp;quot;filename&amp;quot;).sort_stats(2)
ps.print_stats()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，从这样的数据中继续分析下去显然是相当痛苦和反人类的，不过好在有着很多现成好用的可视化工具可以帮助我们继续分析下去，比如&lt;strong&gt;gprof2dot、vprof、pyflame&lt;/strong&gt;等。这边主要下介绍&lt;strong&gt;gprof2dot&lt;/strong&gt;，个人觉得是用起来最习惯的。其他两个只给出示例图和链接以供参考。&lt;/p&gt;
&lt;h3 id=&#34;51-gprof2dot&#34;&gt;5.1 gprof2dot&lt;/h3&gt;
&lt;p&gt;Gprof2Dot是一个Python脚本，可以可将多种Profiler的数据转换成Graphviz格式的图形化展示，方便用户进行性能分析和优化。&lt;/p&gt;
&lt;p&gt;下载安装及详细用法：https://github.com/jrfonseca/gprof2dot&lt;/p&gt;
&lt;p&gt;通过该脚本可以获得程序运行不同函数的时间分析图：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gprof2dot -f pstats filename.prof | dot -Tpng -o out.png
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行后就可以在同一路径下看到生成好的分析图 out.png&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1686650618450.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;52-vprof&#34;&gt;5.2 vprof&lt;/h3&gt;
&lt;p&gt;下载安装及详细用法：https://github.com/nvdv/vprof&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1686650800347.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;53-pyflame&#34;&gt;5.3 pyflame&lt;/h3&gt;
&lt;p&gt;Pyflame是一个轻量级的Profiler工具，可以帮助用户分析Python程序的性能瓶颈，并可视化地显示函数调用关系和执行时间。Pyflame支持多种输出格式，包括FlameGraph、SVG等。&lt;/p&gt;
&lt;p&gt;下载安装及详细用法：https://github.com/uber-archive/pyflame&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1686651425199.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">[Python] 性能分析--cProfile</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/Jdib0wfCY/"" data-c="
          &lt;p&gt;FBX是Autodesk公司开发的一种通用3D文件格式，可以在不同的3D软件之间进行交换和共享。FBX文件包含了3D模型的&lt;strong&gt;几何形状、材质、动画、灯光、相机和其他相关信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果想在当前流行的 3D 编辑器（如 Maya 和 3DS Max）与 3D 体验引擎（如 Unity、Unreal Engine）之间传输数据，则应使用 FBX 文件格式。这是这个文件格式主要的设计目的。&lt;/p&gt;
&lt;p&gt;关于FBX模型的更多详细信息，可以看我的另一篇博客：&lt;a href=&#34;https://wjcsw.github.io/fbx-wen-jian-ge-shi-3d-jian-mo-he-you-xi-kai-fa-de-tong-yong-yu-yan-fbx-mo-xing-xiang-jie/&#34;&gt;FBX文件格式：3D建模和游戏开发的通用语言----FBX模型详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本篇博客是基于上一篇博客：&lt;a href=&#34;https://wjcsw.github.io/mRtdlAT6L/&#34;&gt;从Max中读取模型数据&lt;/a&gt;，介绍如何将获取到的数据转换为fbx模型导出。&lt;/p&gt;
&lt;h2 id=&#34;1-初始化fbx设置&#34;&gt;1. 初始化FBX设置&lt;/h2&gt;
&lt;p&gt;首先要做的就是是创建FBX SDK管理器，它几乎是所有FBX SDK中的类的对象分配器。&lt;/p&gt;
&lt;p&gt;接着，创建FBX IO设置，并为FBX SDK管理器设置IO设置。&lt;/p&gt;
&lt;p&gt;然后，创建一个空白的场景，用于写入数据。&lt;/p&gt;
&lt;p&gt;最后需要注意的是，由于FBX SDK默认的是Y轴向上，而3ds Max默认的是Z轴向上，因此需要进行利用&lt;code&gt;FbxAxisSystem&lt;/code&gt;的&lt;code&gt;ConvertScene&lt;/code&gt;进行轴转换。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lSdkManager = FbxManager.Create()
if not lSdkManager:
    sys.exit(0)

ios = FbxIOSettings.Create(lSdkManager, IOSROOT)
lSdkManager.SetIOSettings(ios)

lScene = FbxScene.Create(lSdkManager, &amp;quot;&amp;quot;)

if lScene .GetGlobalSettings().GetSystemUnit() != fbx.FbxAxisSystem.eMayaZUp:
    fbx.FbxAxisSystem.MayaZUp.ConvertScene(lScene)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-写入模型数据&#34;&gt;2. 写入模型数据&lt;/h2&gt;
&lt;p&gt;我之前获取到的数据主要就是模型的&lt;strong&gt;mesh数据&lt;/strong&gt;，&lt;strong&gt;UV数据&lt;/strong&gt;以及&lt;strong&gt;变换属性&lt;/strong&gt;。下面依次介绍如何将这些数据写入。&lt;/p&gt;
&lt;h3 id=&#34;21-写入mesh数据&#34;&gt;2.1 写入mesh数据&lt;/h3&gt;
&lt;p&gt;首先，创建一个新的&lt;code&gt;FbxMesh&lt;/code&gt;用于写入。接着，调用&lt;code&gt;InitControlPoints&lt;/code&gt;初始化控制点，然后将顶点数据写入控制点。&lt;/p&gt;
&lt;p&gt;下一步，先构造模型的材料属性并设置材料映射。接着，将面数据写入多边形中。&lt;code&gt;BeginPolygon&lt;/code&gt;表示开始多边形构造， &lt;code&gt;AddPolygon&lt;/code&gt;向多边形中添加顶点的ID, &lt;code&gt;EndPolygon&lt;/code&gt;表示多边形构造结束。&lt;/p&gt;
&lt;p&gt;最后是写入法线数据。先构造模型的法线属性并设置法线的映射类型。接着，&lt;br&gt;
通过&lt;code&gt;GetDirectArray&lt;/code&gt;方法获取法线数组，接着调用&lt;code&gt;Add&lt;/code&gt;写入法线数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lMesh = fbx.FbxMesh.Create(fbxScene, &amp;quot;&amp;quot;)

lMesh.InitControlPoints(len(vertices))

for i, vertex in enumerate(vertices):
    lMesh.SetControlPointAt(vertex, i)

materialElement = lMesh.CreateElementMaterial()
materialElement.SetMappingMode(fbx.FbxLayerElement.eByPolygon)
materialElement.SetReferenceMode(fbx.FbxLayerElement.eIndexToDirect)

for i in range(len(faces)):
    face = faces[i]
    lMesh.BeginPolygon(material_ids[i])
    for index in face:
        Mesh.AddPolygon(index)
    Mesh.EndPolygon()

normalElement = lMesh.CreateElementNormal()
normalElement.SetMappingMode(fbx.FbxLayerElement.eByPolygonVertex) 
normalElement.SetReferenceMode(fbx.FbxLayerElement.eDirect) 

for normal in normals:
    normalElement.GetDirectArray().Add(normal)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22-写入uv&#34;&gt;2.2 写入UV&lt;/h3&gt;
&lt;p&gt;先构造模型的UV属性并设置UV映射，接着通过&lt;code&gt;GetDirectArray&lt;/code&gt;方法获取UV顶点数组，然后调用&lt;code&gt;Add&lt;/code&gt;写入UV的顶点数据。&lt;/p&gt;
&lt;p&gt;接下来，调用&lt;code&gt;GetIndexArray&lt;/code&gt;获取面索引数组，然后调用&lt;code&gt;Add&lt;/code&gt;写入UV的面的顶点索引数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;UVElement = lMesh.CreateElementUV(&amp;quot;&amp;quot;)
UVElement.SetMappingMode(fbx.FbxLayerElement.eByPolygonVertex)
UVElement.SetReferenceMode(fbx.FbxLayerElement.eIndexToDirect)

for i in range(numVtx):
    UVValue = fbx.FbxVector2(verts[i][0], verts[i][1])
    UVElement.GetDirectArray().Add(UVValue)

for i in range(numIndex):
    UVIndex = faces[i]
    for j in range(len(UVIndex)):
        UVElement.GetIndexArray().Add(UVIndex[j] - 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-写入变换属性&#34;&gt;2.3 写入变换属性&lt;/h3&gt;
&lt;p&gt;在写入变换属性之前，需要先在场景中构造一个节点&lt;code&gt;FbxNode&lt;/code&gt;代表模型，并将刚刚写入的lMesh通过&lt;code&gt;SetNodeAttribute&lt;/code&gt;方法赋予给这个节点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lNode = fbx.FbxNode.Create(lScene, &amp;quot;&amp;quot;)
lNode.SetNodeAttribute(lMesh)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着，就可以向这个节点设置变换属性了。直接使用节点的对应属性的&lt;code&gt;set&lt;/code&gt;方法就可以完成。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lNode.LclTranslation.Set(LclTranslation)
lNode.LclRotation.Set(LclRotation)
lNode.LclScaling.Set(LclScaling)

lNode.GeometricTranslation.Set(GeometricTranslation)
lNode.GeometricRotation.Set(GeometricRotation)
lNode.GeometricScaling.Set(GeometricScaling)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-导出模型&#34;&gt;3. 导出模型&lt;/h2&gt;
&lt;p&gt;导出模型时，需要将刚刚的那个节点放入场景中。先通过&lt;code&gt;GetRootNode&lt;/code&gt;获取场景的根节点，然后使用&lt;code&gt;AddChild&lt;/code&gt;将其加入根节点的孩子。&lt;/p&gt;
&lt;p&gt;最后，创建&lt;code&gt;FbxExporter&lt;/code&gt;并初始化，&lt;code&gt;Initialize&lt;/code&gt; 方法的第一个参数是导出文件保存路径，第二个参数表示导出的FBX文件类型，这里1代表为ASCii码格式。然后，调用该对象的&lt;code&gt;Export&lt;/code&gt;方法将当前的场景导出为fbx模型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lRootNode = fbxScene.GetRootNode()
lRootNode.AddChild(lNode)

exporter = FbxExporter.Create(fbxManager, &amp;quot;&amp;quot;)
exporter.Initialize(output_path, 1, fbxIOSettings)

exporter.Export(fbxOutputScene)
exporter.Destroy()
&lt;/code&gt;&lt;/pre&gt;
">[Python] 自定义数据导出为FBX</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/mRtdlAT6L/"" data-c="
          &lt;p&gt;3ds Max 和 Maya 是目前最常用的建模工具之一，最近在为项目开发需求时发现，这两者在导入导出时的设置有着不小的区别。&lt;/p&gt;
&lt;p&gt;最影响体验的就是，3ds Max在导入和导出模型时会阻塞当前max除了主窗口的所有窗口，而且速度上也不是很快，导出一个模型要卡好几秒，期间所有基于3ds Max的窗口都会被隐藏，对于插件设计来讲十分的致命。&lt;/p&gt;
&lt;p&gt;基于此，直接从Max中读取模型数据是一个更为理想的方法，下面就介绍下一些关键接口，不过在此之前我先记录一个Max导出设置的大坑。&lt;/p&gt;
&lt;p&gt;这里我获取数据的目的是为了从美术资产中提取出需要的部分数据并将其导出为一个新的fbx模型，因此对获取到的数据格式进行了向fbx的格式转换。如何将获取到的数据利用fbx sdk导出成新的模型，见我的另一篇博客：&lt;a href=&#34;https://wjcsw.github.io/Jdib0wfCY/&#34;&gt;使用fbx sdk将获取的数据转换为模型导出&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;1-多边形拆分问题&#34;&gt;1. 多边形拆分问题&lt;/h2&gt;
&lt;p&gt;3ds Max 默认导出设置会将多边形都拆成三角面，导致模型在检测时出现问题，这一度让我觉得是不是Max本身的问题。&lt;/p&gt;
&lt;p&gt;最后发现是Max设置中有一个&lt;strong&gt;保留边缘方向(Preserve edge orientation)&lt;/strong&gt;，默认是勾选上的，它会导致将多边形都拆成三角面，将其设为False就行了。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1686815514150.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-pymxs库&#34;&gt;2. Pymxs库&lt;/h2&gt;
&lt;p&gt;最早的3ds Max中提供的Python API是&lt;code&gt;MaxPlus&lt;/code&gt;库， 它只是对C++版本的sdk的一个缩减封装版，功能很少，也不太实用。调用它甚至不如直接使用MaxScript来的方便。&lt;/p&gt;
&lt;p&gt;从3ds Max 2017开始，它提供了一个全新的Python API，也就是&lt;code&gt;Pymxs&lt;/code&gt;用于在3ds Max中执行MaxScript代码。它提供了一个Python接口，可以在Python脚本中调用MaxScript函数和命令，以及访问3ds Max中的对象和属性。使用pymxs库，可以将Python和MaxScript结合起来，实现更高效、更灵活的3D建模和动画制作。&lt;/p&gt;
&lt;p&gt;pymxs库的主要特点包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;支持Python 2和Python 3。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供了完整的MaxScript函数和命令的Python接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以在Python脚本中访问3ds Max中的对象和属性，例如场景、节点、材质、动画等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持Python和MaxScript之间的数据转换，例如将Python列表转换为MaxScript数组，将Python字典转换为MaxScript结构体等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以在Python脚本中执行MaxScript代码，并获取执行结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持Python和MaxScript之间的交互式会话，可以在3ds Max中打开Python控制台，并在其中执行Python代码和MaxScript代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这边使用的就是基于Pymxs库来读取Max的数据。&lt;/p&gt;
&lt;h2 id=&#34;3-获取模型数据&#34;&gt;3. 获取模型数据&lt;/h2&gt;
&lt;p&gt;首先，必须要知道的一个重要常识是，3ds Max中的索引大部分都是从1开始的，与Python不同，使用时必须注意到这点去转换索引。&lt;/p&gt;
&lt;h3 id=&#34;31-获取选择模型&#34;&gt;3.1 获取选择模型&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;getCurrentSelection&lt;/code&gt;接口就可以直接获取到当前选择的模型节点集合&lt;/p&gt;
&lt;p&gt;后面通过遍历该集合中的节点node来操作来获取数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 引入Max的python库
from pymxs import runtime as rt
# 引入fbx sdk
import fbx

exportList = rt.getCurrentSelection() # 获取当前所有选择的模型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于模型类型poly和mesh类型的接口不一致，为了方便起见，可以通过类型判断，用一个变量统一地使用接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;rt_convert = rt.polyop
nodecls = rt.classOf(node)
if str(nodecls) == &amp;quot;Editable_mesh&amp;quot;:
    rt_convert = rt.meshop
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;32-获取顶点&#34;&gt;3.2 获取顶点&lt;/h3&gt;
&lt;p&gt;直接通过节点的属性就可以直接访问到模型的顶点数据，不过需要注意这里获取的verts的坐标在其pos属性中，顶点的三维坐标分别对应于pos属性中的x，y，z的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;maxmesh = node.mesh
vertices = maxmesh.verts

pMeshVerts = [fbx.FbxVector4(vertex.pos.x, vertex.pos.y, vertex.pos.z) for vertex in vertices]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;33-获取法线&#34;&gt;3.3 获取法线&lt;/h3&gt;
&lt;p&gt;获取法线数据时，必须要注意，&lt;strong&gt;直接通过3ds Max提供的 &lt;code&gt;getNormal&lt;/code&gt; 接口去获取，得到的法线数据是不正确的&lt;/strong&gt;。&lt;br&gt;
这里直接以Maxscript获取一个立方体的例子举例：&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1686815455506.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vertNum = box01.numverts
8
for i in 1 to vertNum do
(
	local vertNormal = getNormal box01.mesh i
	print vertNormal
)
[0,0,-1.5708]
[0,0,-1.5708]
[0,0,-1.5708]
[0,0,-1.5708]
[0,0,1.5708]
[0,0,1.5708]
[0,0,1.5708]
[0,0,1.5708]
OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;getNormal&lt;/code&gt;方法获得的顶点法线数据是显然错误的，首先，8个点只有2种法线方向，然后，这个法线也没有归一化，长度并不是1的，所以这个获取的结果完全是没法用的。而且实际上，我们知道，一个顶点有可能不止一个法线方向的。事实上，这里按理说应该有24个法线。&lt;/p&gt;
&lt;p&gt;为了正确的获取法线，必须先为节点加入编辑法线的修改器，然后获取完删掉即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# normals
modN = node.modifiers[0]
faceNum = modN.GetNumFaces()
faceNormalIdList = [[modN.GetNormalID(i + 1, j + 1) for j in range(modN.GetFaceDegree(i + 1))] for i in
                        range(faceNum)]

infx = set([nidx for fn in faceNormalIdList for nidx in fn])
temp = {}
for ndx in infx:
    n = modN.GetNormal(ndx)
    temp[ndx] = fbx.FbxVector4(n[0], n[1], n[2])

rt.deleteModifier(node, modN)
normals = [temp[nidx] for fn in faceNormalIdList for nidx in fn]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里，&lt;code&gt;modN.GetFaceDegree(i + 1)&lt;/code&gt;的含义可以理解成这个面由多少个不同角度的点组成，然后遍历组成面的这些点，通过&lt;code&gt;GetNormalID&lt;/code&gt;方法，获得组成这个面的顶点对应的normalId。&lt;/p&gt;
&lt;p&gt;接着通过normalId获取normal的值，这里&lt;strong&gt;使用集合是为了减少对重复的normalId进行接口调用，加快速度&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;34-获取面&#34;&gt;3.4 获取面&lt;/h3&gt;
&lt;p&gt;稍微注意下这里mesh和poly类型的接口使用的不同，一般而言，这两者的接口名称是相同的，但是这里不同。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# faces
pMeshFaces = []  
face_mat_ids = []
num_faces = rt_convert.getNumFaces(node)
if rt_convert == rt.polyop:
    for i in range(num_faces):
        face = rt_convert.getFaceVerts(node, i + 1)
        mat_id = rt_convert.getFaceMatID(node, i + 1)
        Fa = [int(face[j] - 1) for j in range(len(face))]
        pMeshFaces.append(Fa)
        face_mat_ids.append(mat_id)
else:
    for i in range(num_faces):
        face = rt.getFace(maxmesh, i + 1)
        mat_id = rt.getFaceMatID(maxmesh, i + 1)
        Fa = [int(face[j] - 1) for j in range(len(face))]
        pMeshFaces.append(Fa)
        face_mat_ids.append(mat_id)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;35-获取map&#34;&gt;3.5 获取Map&lt;/h3&gt;
&lt;p&gt;首先通过&lt;code&gt;getNumMaps&lt;/code&gt;获取该模型的通道数，然后遍历每个通道，通过&lt;code&gt;getMapVert&lt;/code&gt;和&lt;code&gt;getMapFace&lt;/code&gt;获取顶点和面数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UVData&lt;/code&gt;是我自定义的数据类型，用于保存这些数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;numMaps = rt_convert.getNumMaps(node)
UVDatas = []
for index in range(1, numMaps):
    numFaces = rt_convert.getNumMapFaces(node, index)
    numVerts = rt_convert.getNumMapVerts(node, index)
    pMapVerts = []
    for i in range(numVerts):
        vert = rt_convert.getMapVert(node, index, i + 1)
        pMapVerts.append(vert)

    pMapFaces = []
    for i in range(numFaces):
        face = rt_convert.getMapFace(node, index, i + 1)
        Fa = []
        for j in range(len(face)):
            Fa.append(int(face[j]))
        pMapFaces.append(Fa)

    uv_data = UVData(pMapVerts, pMapFaces, numVerts, numFaces, uv_name)
    UVDatas.append(uv_data)

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;36-获取变换属性&#34;&gt;3.6 获取变换属性&lt;/h3&gt;
&lt;p&gt;通过node可以直接访问到模型的变换属性，分为局部变换和全局变换。主要包括三个属性：Translation 平移变换，Rotation 旋转变换以及Scaling 缩放变换。&lt;/p&gt;
&lt;p&gt;值得一提的是，直接从Max中读取得到的是四元数表示的角度，这里为了将其转换为Fbx的欧拉角度角度，做了两次转换。先将其转换为Fbx的四元数类型，再利用&lt;code&gt;FbxAMatrix&lt;/code&gt;将其转换为欧拉角度。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 局部变换属性
lclTranslation = fbx.FbxDouble3(node.pos.x, node.pos.y, node.pos.z)
lclRotation = node.rotation
lclRotation = fbx.FbxQuaternion(lclRotation.x, lclRotation.y, lclRotation.z, lclRotation.w)
fbxMatrix = fbx.FbxAMatrix()
fbxMatrix.SetQ(lclRotation)
# 将FbxAMatrix转换为欧拉角度
lclRotation = fbxMatrix.GetR()
lclRotation = fbx.FbxDouble3(lclRotation[0], lclRotation[1], lclRotation[2])
lclScaling = fbx.FbxDouble3(node.scale.x, node.scale.y, node.scale.z)
    
# 全局变换属性
geometricTranslation = node.objectOffsetPos
geometricTranslation = fbx.FbxDouble3(geometricTranslation.x, geometricTranslation.y, geometricTranslation.z)
geometricRotation = node.objectOffsetRot
geometricRotation = fbx.FbxQuaternion(geometricRotation.x, geometricRotation.y, geometricRotation.z,geometricRotation.w)
fbxMatrix.SetQ(geometricRotation)
geometricRotation = fbxMatrix.GetR()
geometricRotation = fbx.FbxDouble3(geometricRotation[0], geometricRotation[1], geometricRotation[2])
geometricScaling = node.objectOffsetScale
geometricScaling = fbx.FbxDouble3(geometricScaling.x, geometricScaling.y, geometricScaling.z)
&lt;/code&gt;&lt;/pre&gt;
">[Python] 从Max中读取模型数据</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/pIi1qYHnn/"" data-c="
          &lt;p&gt;FBX SDK 为FBX模型的导入导出提供了对应的&lt;code&gt;FbxImporter&lt;/code&gt;和&lt;code&gt;FbxExporter&lt;/code&gt;类&lt;/p&gt;
&lt;p&gt;这里介绍下如何使用这两个类进行导入与导出以及对应的导入导出设置&lt;/p&gt;
&lt;h2 id=&#34;1-初始化&#34;&gt;1. 初始化&lt;/h2&gt;
&lt;p&gt;使用FBX SDK，首先得对&lt;code&gt;FbxManager&lt;/code&gt;对象初始化，用于管理FBX模型的几乎所有对象&lt;/p&gt;
&lt;p&gt;然后创建一个空白场景用于写入将要导入或导出的数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lSdkManager = FbxManager.Create()
if not lSdkManager:
    sys.exit(0)

ios = FbxIOSettings.Create(lSdkManager, IOSROOT)
pSdkManager.SetIOSettings(ios)

pScene = FbxScene.Create(lSdkManager, &amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-导入模型&#34;&gt;2. 导入模型&lt;/h2&gt;
&lt;p&gt;FBX SDK通过&lt;code&gt;FbxImporter&lt;/code&gt;类来完成导入模型。&lt;/p&gt;
&lt;p&gt;首先，创建导入器对象，接着调用其初始化方法完成导入的基本设置，该方法共有三个参数以及一个额外的可选参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数指定要导入的FBX文件的路径和文件名。&lt;/li&gt;
&lt;li&gt;第二个参数指定要导入的FBX文件的格式，可以是二进制格式或ASCII格式。-1表示自动检测文件格式，0为二进制格式，1为ASCII格式。&lt;/li&gt;
&lt;li&gt;第三个参数为导入的&lt;code&gt;FbxIOSettings&lt;/code&gt;对象，用于设置导入FBX文件的选项，例如是否导入材质、动画、几何体等。&lt;/li&gt;
&lt;li&gt;最后的可选参数指定一个文件流，表示用于读取FBX文件的数据流，可以是文件流或内存流。如果不指定文件流，则默认使用文件名和格式来创建一个文件流。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;FbxIOSettings&lt;/code&gt;对象具体设置了对于导入FBX文件的选项，常见的导入设置如下所示，这里介绍下每个选项的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IMP_FBX_MATERIAL：设置是否导入FBX文件中的材质信息。&lt;/li&gt;
&lt;li&gt;IMP_FBX_TEXTURE：设置是否导入FBX文件中的纹理信息。&lt;/li&gt;
&lt;li&gt;IMP_FBX_SHAPE：设置是否导入FBX文件中的形状信息，例如几何体和曲线。&lt;/li&gt;
&lt;li&gt;IMP_FBX_GOBO：设置是否导入FBX文件中的灯光信息。&lt;/li&gt;
&lt;li&gt;IMP_FBX_ANIMATION：设置是否导入FBX文件中的动画信息。&lt;/li&gt;
&lt;li&gt;IMP_FBX_GLOBAL_SETTINGS：设置是否导入FBX文件中的全局设置信息，例如单位、坐标系和时间轴设置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些选项可以根据需要进行设置，以便在导入FBX文件时只导入所需的信息，从而提高导入效率和减少内存占用。&lt;/p&gt;
&lt;p&gt;最后调用导入器对象的&lt;code&gt;Import&lt;/code&gt;方法导入即可，记得导入完成后销毁导入器对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def LoadScene(pSdkManager, pScene, pFileName):
    lImporter = FbxImporter.Create(pSdkManager, &amp;quot;&amp;quot;)
    result = lImporter.Initialize(pFileName, -1, pSdkManager.GetIOSettings())
    if not result:
        return False

    if lImporter.IsFBX():
        pSdkManager.GetIOSettings().SetBoolProp(IMP_FBX_MATERIAL, True)
        pSdkManager.GetIOSettings().SetBoolProp(IMP_FBX_TEXTURE, True)
        pSdkManager.GetIOSettings().SetBoolProp(IMP_FBX_SHAPE, True)
        pSdkManager.GetIOSettings().SetBoolProp(IMP_FBX_GOBO, True)
        pSdkManager.GetIOSettings().SetBoolProp(IMP_FBX_ANIMATION, True)
        pSdkManager.GetIOSettings().SetBoolProp(IMP_FBX_GLOBAL_SETTINGS, True)

    result = lImporter.Import(pScene)
    lImporter.Destroy()
    return result
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-导出模型&#34;&gt;3. 导出模型&lt;/h2&gt;
&lt;p&gt;类似地，FBX SDK通过&lt;code&gt;FbxExporter&lt;/code&gt;类来完成导入模型。&lt;/p&gt;
&lt;p&gt;导出的方法与导入的基本一致，只有IO设置中参数的前缀都要从IMP改为EXP&lt;/p&gt;
&lt;p&gt;最后调用导出器对象的&lt;code&gt;Export&lt;/code&gt;方法导出即可，记得导入完成后销毁导出器对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def export_scene(pSdkManager, pScene, pFileName):
    lExporter = FbxExporter.Create(fbxManager, &amp;quot;&amp;quot;)

    if not pSdkManager.GetIOSettings():
        ios = FbxIOSettings.Create(pSdkManager, IOSROOT)
        pSdkManager.SetIOSettings(ios)

    pSdkManager.GetIOSettings().SetBoolProp(EXP_FBX_MATERIAL, True)
    pSdkManager.GetIOSettings().SetBoolProp(EXP_FBX_TEXTURE, True)
    pSdkManager.GetIOSettings().SetBoolProp(EXP_FBX_EMBEDDED, False)
    pSdkManager.GetIOSettings().SetBoolProp(EXP_FBX_SHAPE, True)
    pSdkManager.GetIOSettings().SetBoolProp(EXP_FBX_GOBO, True)
    pSdkManager.GetIOSettings().SetBoolProp(EXP_FBX_ANIMATION, True)
    pSdkManager.GetIOSettings().SetBoolProp(EXP_FBX_GLOBAL_SETTINGS, True)

    result = lExporter.Initialize(output_path, 1, pSdkManager.GetIOSettings())

    if result:
        result = lExporter.Export(pScene)
    lExporter.Destroy()
&lt;/code&gt;&lt;/pre&gt;
">[Python] FBX SDK：使用Python进行3D模型导入导出的设置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/fbx-wen-jian-ge-shi-3d-jian-mo-he-you-xi-kai-fa-de-tong-yong-yu-yan-fbx-mo-xing-xiang-jie/"" data-c="
          &lt;h2 id=&#34;1-fbx概述&#34;&gt;1. FBX概述&lt;/h2&gt;
&lt;p&gt;FBX是Autodesk公司开发的一种通用3D文件格式，可以在不同的3D软件之间进行交换和共享。FBX文件包含了3D模型的&lt;strong&gt;几何形状、材质、动画、灯光、相机和其他相关信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果想在当前流行的 3D 编辑器（如 Maya 和 3DS Max）与 3D 体验引擎（如 Unity、Unreal Engine）之间传输数据，则应使用 FBX 文件格式。这是这个文件格式主要的设计目的。&lt;/p&gt;
&lt;h2 id=&#34;2-优缺点&#34;&gt;2. 优缺点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;FBX模型具有以下几个方面的优势&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;1. 跨平台兼容性&lt;/strong&gt;：FBX文件可以在不同的3D软件之间进行交换和共享，包括Autodesk Maya、3ds Max、Blender、Unity、Unreal Engine等。这使得开发人员可以在不同的软件之间自由地转换和共享3D模型和场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;2. 支持多种数据类型&lt;/strong&gt;：FBX文件支持几何、材质、动画、灯光、相机等多种数据类型，可以完整地保存3D模型和场景的各个方面。这使得开发人员可以在不同的软件之间自由地转换和共享3D模型和场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;3. 高效的数据压缩&lt;/strong&gt;：FBX文件使用高效的数据压缩算法，可以将3D模型和场景的数据压缩到较小的文件大小。这使得开发人员可以更快地加载和处理3D模型和场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;4. 支持多种操作&lt;/strong&gt;：FBX文件支持多种操作，包括动画、物理模拟、碰撞检测等。这使得开发人员可以在不同的软件之间自由地转换和共享3D模型和场景，并进行各种操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;5. 可扩展性&lt;/strong&gt;：FBX文件是一种可扩展的文件格式，可以通过添加自定义属性和元数据来扩展其功能。这使得开发人员可以根据自己的需求来扩展FBX文件的功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;FBX 格式的最大缺点&lt;/strong&gt;: 它是一种封闭格式。访问 FBX 文件中数据的&lt;strong&gt;唯一官方方法&lt;/strong&gt;是&lt;strong&gt;使用官方 SDK&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;3-模型数据详解&#34;&gt;3. 模型数据详解&lt;/h2&gt;
&lt;p&gt;FBX有&lt;strong&gt;二进制&lt;/strong&gt;和&lt;strong&gt;ASCII码&lt;/strong&gt;两种格式，在&lt;strong&gt;ASCII码&lt;/strong&gt;格式下我们可以直接看到里面储存的数据。下面以一个简单的长方体模型为例，介绍模型的每项数据及其含义。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1686643620943.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;31-头部数据&#34;&gt;3.1 头部数据&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;; FBX 7.4.0 project file
; ----------------------------------------------------

FBXHeaderExtension:  {
    FBXHeaderVersion: 1003
    FBXVersion: 7400
    CreationTimeStamp:  {
        Version: 1000
        Year: 2023
        Month: 6
        Day: 13
        Hour: 14
        Minute: 45
        Second: 31
        Millisecond: 644
    }
    Creator: &amp;quot;FBX SDK/FBX Plugins version 2020.3.1&amp;quot;
    SceneInfo: &amp;quot;SceneInfo::GlobalInfo&amp;quot;, &amp;quot;UserData&amp;quot; {
        Type: &amp;quot;UserData&amp;quot;
        Version: 100
        MetaData:  {
            Version: 100
            Title: &amp;quot;&amp;quot;
            Subject: &amp;quot;&amp;quot;
            Author: &amp;quot;&amp;quot;
            Keywords: &amp;quot;&amp;quot;
            Revision: &amp;quot;&amp;quot;
            Comment: &amp;quot;&amp;quot;
        }
        Properties70:  {
            P: &amp;quot;DocumentUrl&amp;quot;, &amp;quot;KString&amp;quot;, &amp;quot;Url&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;C:\Users\xxx\Desktop\tes.fbx&amp;quot;
            P: &amp;quot;SrcDocumentUrl&amp;quot;, &amp;quot;KString&amp;quot;, &amp;quot;Url&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;C:\Users\xxx\Desktop\tes.fbx&amp;quot;
            P: &amp;quot;Original&amp;quot;, &amp;quot;Compound&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;
            P: &amp;quot;Original|ApplicationVendor&amp;quot;, &amp;quot;KString&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Autodesk&amp;quot;
            P: &amp;quot;Original|ApplicationName&amp;quot;, &amp;quot;KString&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;3ds Max&amp;quot;
            P: &amp;quot;Original|ApplicationVersion&amp;quot;, &amp;quot;KString&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;2022&amp;quot;
            P: &amp;quot;Original|DateTime_GMT&amp;quot;, &amp;quot;DateTime&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;13/06/2023 06:45:31.643&amp;quot;
            P: &amp;quot;Original|FileName&amp;quot;, &amp;quot;KString&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;C:\Users\xxx\Desktop\tes.fbx&amp;quot;
            P: &amp;quot;LastSaved&amp;quot;, &amp;quot;Compound&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;
            P: &amp;quot;LastSaved|ApplicationVendor&amp;quot;, &amp;quot;KString&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Autodesk&amp;quot;
            P: &amp;quot;LastSaved|ApplicationName&amp;quot;, &amp;quot;KString&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;3ds Max&amp;quot;
            P: &amp;quot;LastSaved|ApplicationVersion&amp;quot;, &amp;quot;KString&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;2022&amp;quot;
            P: &amp;quot;LastSaved|DateTime_GMT&amp;quot;, &amp;quot;DateTime&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;13/06/2023 06:45:31.643&amp;quot;
            P: &amp;quot;Original|ApplicationActiveProject&amp;quot;, &amp;quot;KString&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;C:\Users\xxx\Documents\3ds Max 2022&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是FBX文件的&lt;strong&gt;头部扩展数据&lt;/strong&gt;，其中包含了以下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FBXHeaderVersion&lt;/strong&gt;: FBX文件头部版本号，这里是1003。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FBXVersion&lt;/strong&gt;: FBX文件版本号，这里是7400。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CreationTimeStamp&lt;/strong&gt;: FBX文件创建时间戳，包括年、月、日、时、分、秒和毫秒。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Creator&lt;/strong&gt;: 创建FBX文件的软件和插件版本号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SceneInfo&lt;/strong&gt;: 场景信息，包括全局信息和用户数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Type&lt;/strong&gt;: 用户数据类型，这里是&amp;quot;UserData&amp;quot;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Version&lt;/strong&gt;: 用户数据版本号，这里是100。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MetaData&lt;/strong&gt;: 用户数据的元数据，包括标题、主题、作者、关键字、修订版本和注释。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Properties70&lt;/strong&gt;: 用户数据的属性，包括文档URL、源文档URL、原始应用程序供应商、原始应用程序名称、原始应用程序版本、原始日期时间、原始文件名、最后保存的应用程序供应商、最后保存的应用程序名称、最后保存的应用程序版本、最后保存的日期时间和原始应用程序活动项目。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些数据提供了有关FBX文件的详细信息，包括文件版本、创建时间、创建者、场景信息和用户数据。它们可以帮助开发人员了解FBX文件的来源和属性，以便更好地处理和使用它们。&lt;/p&gt;
&lt;h3 id=&#34;32-全局设置数据&#34;&gt;3.2 全局设置数据&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;GlobalSettings:  {
    Version: 1000
    Properties70:  {
        P: &amp;quot;UpAxis&amp;quot;, &amp;quot;int&amp;quot;, &amp;quot;Integer&amp;quot;, &amp;quot;&amp;quot;,2
        P: &amp;quot;UpAxisSign&amp;quot;, &amp;quot;int&amp;quot;, &amp;quot;Integer&amp;quot;, &amp;quot;&amp;quot;,1
        P: &amp;quot;FrontAxis&amp;quot;, &amp;quot;int&amp;quot;, &amp;quot;Integer&amp;quot;, &amp;quot;&amp;quot;,1
        P: &amp;quot;FrontAxisSign&amp;quot;, &amp;quot;int&amp;quot;, &amp;quot;Integer&amp;quot;, &amp;quot;&amp;quot;,-1
        P: &amp;quot;CoordAxis&amp;quot;, &amp;quot;int&amp;quot;, &amp;quot;Integer&amp;quot;, &amp;quot;&amp;quot;,0
        P: &amp;quot;CoordAxisSign&amp;quot;, &amp;quot;int&amp;quot;, &amp;quot;Integer&amp;quot;, &amp;quot;&amp;quot;,1
        P: &amp;quot;OriginalUpAxis&amp;quot;, &amp;quot;int&amp;quot;, &amp;quot;Integer&amp;quot;, &amp;quot;&amp;quot;,2
        P: &amp;quot;OriginalUpAxisSign&amp;quot;, &amp;quot;int&amp;quot;, &amp;quot;Integer&amp;quot;, &amp;quot;&amp;quot;,1
        P: &amp;quot;UnitScaleFactor&amp;quot;, &amp;quot;double&amp;quot;, &amp;quot;Number&amp;quot;, &amp;quot;&amp;quot;,1
        P: &amp;quot;OriginalUnitScaleFactor&amp;quot;, &amp;quot;double&amp;quot;, &amp;quot;Number&amp;quot;, &amp;quot;&amp;quot;,2.54
        P: &amp;quot;AmbientColor&amp;quot;, &amp;quot;ColorRGB&amp;quot;, &amp;quot;Color&amp;quot;, &amp;quot;&amp;quot;,0,0,0
        P: &amp;quot;DefaultCamera&amp;quot;, &amp;quot;KString&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Producer Perspective&amp;quot;
        P: &amp;quot;TimeMode&amp;quot;, &amp;quot;enum&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,6
        P: &amp;quot;TimeProtocol&amp;quot;, &amp;quot;enum&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,2
        P: &amp;quot;SnapOnFrameMode&amp;quot;, &amp;quot;enum&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,0
        P: &amp;quot;TimeSpanStart&amp;quot;, &amp;quot;KTime&amp;quot;, &amp;quot;Time&amp;quot;, &amp;quot;&amp;quot;,0
        P: &amp;quot;TimeSpanStop&amp;quot;, &amp;quot;KTime&amp;quot;, &amp;quot;Time&amp;quot;, &amp;quot;&amp;quot;,153953860000
        P: &amp;quot;CustomFrameRate&amp;quot;, &amp;quot;double&amp;quot;, &amp;quot;Number&amp;quot;, &amp;quot;&amp;quot;,-1
        P: &amp;quot;TimeMarker&amp;quot;, &amp;quot;Compound&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;
        P: &amp;quot;CurrentTimeMarker&amp;quot;, &amp;quot;int&amp;quot;, &amp;quot;Integer&amp;quot;, &amp;quot;&amp;quot;,-1
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是FBX文件的&lt;strong&gt;全局设置数据&lt;/strong&gt;，其中包含了以下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Version&lt;/strong&gt;: 全局设置版本号，这里是1000。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Properties70&lt;/strong&gt;: 全局设置的属性，部分类似属性如UpAxis和FrontAxis只介绍一个。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;UpAxis&lt;/strong&gt;: 上轴属性，表示FBX文件中的上轴方向。这里的值为2，表示上轴方向为Z轴。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UpAxisSign&lt;/strong&gt;: 上轴符号属性，表示FBX文件中的上轴方向的符号。这里的值为1，表示上轴方向为正方向。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CoordAxis&lt;/strong&gt;: 坐标轴属性，表示FBX文件中的坐标轴方向。这里的值为0，表示坐标轴方向为X、Y、Z轴。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CoordAxisSign&lt;/strong&gt;: 坐标轴符号属性，表示FBX文件中的坐标轴方向的符号。这里的值为1，表示坐标轴方向为正方向。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UnitScaleFactor&lt;/strong&gt;: 单位比例因子属性，表示FBX文件中的单位比例因子。这里的值为1，表示FBX文件中的距离单位为厘米。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AmbientColor&lt;/strong&gt;: 环境颜色属性，表示FBX文件中的环境光颜色。这里的值为0,0,0，表示环境光颜色为黑色。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DefaultCamera&lt;/strong&gt;: 默认相机属性，表示FBX文件中的默认相机。这里的值为&amp;quot;Producer Perspective&amp;quot;，表示默认相机为FBX生产者透视相机。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TimeMode&lt;/strong&gt;: 时间模式属性，表示FBX文件中的时间单位。这里的值为6，表示时间单位为帧。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TimeProtocol&lt;/strong&gt;: 时间协议属性，表示FBX文件中的时间协议。这里的值为2，表示时间协议为NTSC。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SnapOnFrameMode&lt;/strong&gt;: 帧捕捉模式属性，表示FBX文件中的帧捕捉模式。这里的值为0，表示帧捕捉模式为关闭。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TimeSpanStart&lt;/strong&gt;: 时间跨度开始属性，表示FBX文件中的时间跨度开始时间。这里的值为0，表示时间跨度开始时间为0帧。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TimeSpanStop&lt;/strong&gt;: 时间跨度结束属性，表示FBX文件中的时间跨度结束时间。这里的值为153953860000，表示时间跨度结束时间为153953860000帧。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CustomFrameRate&lt;/strong&gt;: 自定义帧速率属性，表示FBX文件中的自定义帧速率。这里的值为-1，表示没有自定义帧速率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TimeMarker&lt;/strong&gt;: 时间标记属性，表示FBX文件中的时间标记。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些数据提供了有关FBX文件的全局设置信息，包括坐标轴方向、单位比例因子、时间模式和时间跨度等。它们可以帮助开发人员了解FBX文件的坐标系、单位和时间轴设置，以便更好地处理和使用它们。例如，上轴和前轴属性可以告诉开发人员FBX文件的坐标系方向，单位比例因子可以告诉开发人员FBX文件中的距离单位，时间模式和时间跨度可以告诉开发人员FBX文件中的时间单位和时间范围。&lt;/p&gt;
&lt;h3 id=&#34;33-对象动画层数据&#34;&gt;3.3 对象动画层数据&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ObjectType: &amp;quot;AnimationLayer&amp;quot; {
        Count: 1
        PropertyTemplate: &amp;quot;FbxAnimLayer&amp;quot; {
            Properties70:  {
                P: &amp;quot;Weight&amp;quot;, &amp;quot;Number&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;A&amp;quot;,100
                P: &amp;quot;Mute&amp;quot;, &amp;quot;bool&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,0
                P: &amp;quot;Solo&amp;quot;, &amp;quot;bool&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,0
                P: &amp;quot;Lock&amp;quot;, &amp;quot;bool&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,0
                P: &amp;quot;Color&amp;quot;, &amp;quot;ColorRGB&amp;quot;, &amp;quot;Color&amp;quot;, &amp;quot;&amp;quot;,0.8,0.8,0.8
                P: &amp;quot;BlendMode&amp;quot;, &amp;quot;enum&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,0
                P: &amp;quot;RotationAccumulationMode&amp;quot;, &amp;quot;enum&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,0
                P: &amp;quot;ScaleAccumulationMode&amp;quot;, &amp;quot;enum&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,0
                P: &amp;quot;BlendModeBypass&amp;quot;, &amp;quot;ULongLong&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,0
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些是&lt;strong&gt;动画层对象类型的数据&lt;/strong&gt;，包括权重、静音、独奏、锁定、颜色、混合模式、旋转累积模式、缩放累积模式和混合模式旁路等属性。以下是每个属性的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Weight&lt;/strong&gt;: 权重属性，表示动画层的权重。这里的值为100，表示动画层的权重为100%。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mute&lt;/strong&gt;: 静音属性，表示动画层是否静音。这里的值为0，表示动画层未静音。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Solo&lt;/strong&gt;: 独奏属性，表示动画层是否独奏。这里的值为0，表示动画层未独奏。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lock&lt;/strong&gt;: 锁定属性，表示动画层是否锁定。这里的值为0，表示动画层未锁定。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Color&lt;/strong&gt;: 颜色属性，表示动画层的颜色。这里的值为0.8,0.8,0.8，表示动画层的颜色为灰色。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BlendMode&lt;/strong&gt;: 混合模式属性，表示动画层的混合模式。这里的值为0，表示动画层的混合模式为标准混合模式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RotationAccumulationMode&lt;/strong&gt;: 旋转累积模式属性，表示动画层的旋转累积模式。这里的值为0，表示动画层的旋转累积模式为相加。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ScaleAccumulationMode&lt;/strong&gt;: 缩放累积模式属性，表示动画层的缩放累积模式。这里的值为0，表示动画层的缩放累积模式为相加。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BlendModeBypass&lt;/strong&gt;: 混合模式旁路属性，表示动画层的混合模式旁路。这里的值为0，表示动画层的混合模式旁路为关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些属性用于控制动画层的行为和外观。例如，权重属性可以控制动画层在混合动画时的权重，静音属性可以控制动画层是否播放声音，颜色属性可以控制动画层的颜色，混合模式属性可以控制动画层的混合模式等。这些属性可以帮助开发人员控制动画层的行为和外观，以便更好地实现动画效果。&lt;/p&gt;
&lt;h3 id=&#34;34-对象几何数据&#34;&gt;3.4 对象几何数据&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Geometry: 2544941990176, &amp;quot;Geometry::&amp;quot;, &amp;quot;Mesh&amp;quot; {
        Properties70:  {
            P: &amp;quot;Color&amp;quot;, &amp;quot;ColorRGB&amp;quot;, &amp;quot;Color&amp;quot;, &amp;quot;&amp;quot;,0.694117647058824,0.345098039215686,0.105882352941176
        }
        Vertices: *24 {
            a: -5.73998689651489,-20.0938777923584,0,5.73998689651489,-20.0938777923584,0,-5.73998689651489,20.0938777923584,0,5.73998689651489,20.0938777923584,0,-5.73998689651489,-20.0938777923584,10.2069730758667,5.73998689651489,-20.0938777923584,10.2069730758667,-5.73998689651489,20.0938777923584,10.2069730758667,5.73998689651489,20.0938777923584,10.2069730758667
        } 
        PolygonVertexIndex: *24 {
            a: 0,2,3,-2,4,5,7,-7,0,1,5,-5,1,3,7,-6,3,2,6,-8,2,0,4,-7
        } 
        Edges: *12 {
            a: 0,1,2,3,4,5,6,7,9,11,13,17
        } 
        GeometryVersion: 124
        LayerElementNormal: 0 {
            Version: 102
            Name: &amp;quot;&amp;quot;
            MappingInformationType: &amp;quot;ByPolygonVertex&amp;quot;
            ReferenceInformationType: &amp;quot;Direct&amp;quot;
            Normals: *72 {
                a: 0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0
            } 
            NormalsW: *24 {
                a: 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            } 
        }
        LayerElementUV: 0 {
            Version: 101
            Name: &amp;quot;UVChannel_1&amp;quot;
            MappingInformationType: &amp;quot;ByPolygonVertex&amp;quot;
            ReferenceInformationType: &amp;quot;IndexToDirect&amp;quot;
            UV: *48 {
                a: 1,0,0,0,1,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1
            } 
            UVIndex: *24 {
                a: 0,2,3,1,4,5,7,6,8,9,11,10,12,13,15,14,16,17,19,18,20,21,23,22
            } 
        }
        Layer: 0 {
            Version: 100
            LayerElement:  {
                Type: &amp;quot;LayerElementNormal&amp;quot;
                TypedIndex: 0
            }
            LayerElement:  {
                Type: &amp;quot;LayerElementUV&amp;quot;
                TypedIndex: 0
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是FBX文件中的几何体对象类型数据，包括顶点、多边形顶点索引、边、法线、UV等属性。以下是每个属性的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Vertices&lt;/strong&gt;: 顶点属性，表示几何体的顶点坐标。这里的值为三维数据集的8个顶点（3个值代表一个顶点三维坐标）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PolygonVertexIndex&lt;/strong&gt;: 多边形顶点索引属性，表示几何体的多边形顶点索引。这里的值为24个多边形顶点索引。其中的负值代表多边形结束，每隔3个出现负值代表是个三角形面，每隔4个出现负值代表是四边形面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Edges&lt;/strong&gt;: 边属性，表示几何体的边。这里的值为12个边。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LayerElementNormal&lt;/strong&gt;: 法线属性，表示几何体的法线。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Normals&lt;/strong&gt;：法线向量。这里的72是6个四边形的每个四边形顶点的24个法线（3个值代表一个法向量）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NormalsW&lt;/strong&gt;：法线权重。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LayerElementUV&lt;/strong&gt;: UV属性，表示几何体的UV坐标。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Name&lt;/strong&gt;: 名称属性，表示UV属性的名称。这里的值为&amp;quot;UVChannel_1&amp;quot;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MappingInformationType&lt;/strong&gt;: 映射信息类型属性，表示UV坐标的映射方式。这里的值为&amp;quot;ByPolygonVertex&amp;quot;，表示每个多边形顶点都有一个对应的UV坐标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ReferenceInformationType&lt;/strong&gt;: 引用信息类型属性，表示UV坐标的索引方式。这里的值为&amp;quot;IndexToDirect&amp;quot;，表示UV坐标使用索引方式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UV&lt;/strong&gt;: UV坐标属性，表示几何体的UV坐标。这里的值为24个多边形顶点的48个UV坐标（2个值代表一个顶点二维坐标）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UVIndex&lt;/strong&gt;: UV索引属性，表示几何体的UV坐标索引。这里的值为24个UV索引，与多边形顶点索引对应。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Layer&lt;/strong&gt;: 层属性，表示几何体的层。这里的值表示模型包含法线和UV的层。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;着重解释下部分重要属性：&lt;/p&gt;
&lt;p&gt;在FBX模型中，&lt;strong&gt;PolygonVertexIndex&lt;/strong&gt;是一个数组，它存储了多边形的顶点索引。具体来说，它指定了每个多边形的顶点在顶点数组中的索引位置。例如，如果一个三角形有三个顶点，那么PolygonVertexIndex数组中将有三个值，分别表示这三个顶点在顶点数组中的索引位置。这个数组的作用是帮助3D渲染引擎正确地绘制多边形，因为它告诉引擎哪些顶点应该连接在一起形成多边形。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MappingInformationType&lt;/strong&gt;属性表示UV坐标、法线等属性的映射方式。常见的属性值设置有以下几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;ByControlPoint&amp;quot;: 按控制点映射，即每个控制点都有一个对应的属性值。
&amp;quot;ByPolygonVertex&amp;quot;: 按多边形顶点映射，即每个多边形顶点都有一个对应的属性值。
&amp;quot;ByPolygon&amp;quot;: 按多边形映射，即每个多边形都有一个对应的属性值。
&amp;quot;ByEdge&amp;quot;: 按边映射，即每个边都有一个对应的属性值。
&amp;quot;AllSame&amp;quot;: 所有属性值相同。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，&amp;quot;ByControlPoint&amp;quot;和&amp;quot;ByPolygonVertex&amp;quot;是最常用的两种映射方式。&amp;quot;ByControlPoint&amp;quot;适用于需要对控制点进行操作的情况，如平滑法线计算；&amp;quot;ByPolygonVertex&amp;quot;适用于需要对多边形顶点进行操作的情况，如纹理映射。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ReferenceInformationType&lt;/strong&gt;属性表示UV坐标、法线等属性的索引方式。常见的属性值设置有以下几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;Direct&amp;quot;: 直接索引，即每个属性值都直接存储在属性数组中。
&amp;quot;IndexToDirect&amp;quot;: 索引到直接，即每个属性值都通过索引引用属性数组中的值。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，&amp;quot;Direct&amp;quot;适用于属性值数量较少的情况，可以直接存储在属性数组中；&amp;quot;IndexToDirect&amp;quot;适用于属性值数量较多的情况，可以通过索引引用属性数组中的值，节省存储空间。&lt;/p&gt;
&lt;p&gt;需要注意的是，不同的属性类型可能支持不同的ReferenceInformationType属性值。例如，&lt;strong&gt;法线属性只支持&amp;quot;Direct&amp;quot;索引方式&lt;/strong&gt;，而UV属性通常使用&amp;quot;IndexToDirect&amp;quot;索引方式。&lt;/p&gt;
&lt;h3 id=&#34;35-其他重要属性&#34;&gt;3.5 其他重要属性&lt;/h3&gt;
&lt;p&gt;其余部分中也有着一些重要属性，下面简略介绍下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Shading&lt;/strong&gt;: 着色属性，表示模型对象的着色方式。这里的值为&amp;quot;T&amp;quot;，表示使用纹理着色。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Culling&lt;/strong&gt;: 背面剔除属性，表示模型对象的背面剔除方式。这里的值为&amp;quot;CullingOff&amp;quot;，表示不进行背面剔除。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lcl Translation&lt;/strong&gt;：表示模型对象的平移属性。Lcl是Local的缩写，表示该属性是相对于模型对象的&lt;strong&gt;本地坐标系&lt;/strong&gt;而言的。与之类似的还有&lt;strong&gt;Lcl Rotation、Lcl Scaling&lt;/strong&gt;分别代表模型相对于本地坐标系的旋转和缩放属性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Geometric Translation&lt;/strong&gt;：表示整个场景或模型对象的平移属性，与Lcl Translation属性不同，它是相对于FBX文件的&lt;strong&gt;全局坐标系&lt;/strong&gt;而言的。与之类似的还有&lt;strong&gt;Geometric Rotation、Geometric Scaling&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
">FBX文件格式：3D建模和游戏开发的通用语言----FBX模型详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/3ds-max-yi-ji-maya-ge-ban-ben-yu-nei-zhi-python-jie-shi-qi-dui-ying-ban-ben/"" data-c="
          &lt;p&gt;3ds Max 以及 Maya 在多个版本以前就提供了内置python以供调用，但是不同版本的客户端使用的python版本不同，这在我工作中也带来了不少麻烦，目前将这些版本的对应关系整理如下：&lt;/p&gt;
&lt;h2 id=&#34;3ds-max&#34;&gt;3ds Max&lt;/h2&gt;
&lt;p&gt;其中2021提供了双版本python，默认使用的是高版本的&lt;/p&gt;
&lt;p&gt;额外注意，3dsMax的python2使用的是自己编译的python版本，环境与标准python不一致，某些库需要安装cpython编译的特殊版本&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;max版本&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;python版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2017&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2.7.6&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2018&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2.7.12&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2019&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2.7.12&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2020&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2.7.15&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2021&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;3.7.6&lt;/strong&gt; &amp;amp;&amp;amp; &lt;strong&gt;2.7.17&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2022&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;3.7.12&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2023&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;3.9.7&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2024&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;3.10.8&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;maya&#34;&gt;Maya&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;maya版本&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;python版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2017&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2.7.11&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2018&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2.7.11&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2019&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2.7.11&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2020&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2.7.15&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2021&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;3.7.6&lt;/strong&gt; &amp;amp;&amp;amp; &lt;strong&gt;2.7.17&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2022&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;3.7.7&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2023&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;3.9.7&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;2024&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;3.10.8&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">3ds Max 以及 Maya 各版本与内置 python 解释器对应版本</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/cMzgQqGbQ/"" data-c="
          &lt;h3 id=&#34;1-概述&#34;&gt;1. 概述&lt;/h3&gt;
&lt;p&gt;互联网的产生带来了机器间通讯的需求，而互联通讯的双方需要采用约定的协议，序列化和反序列化属于通讯协议的一部分。在OSI七层协议模型中展现层（Presentation Layer）的主要功能是把应用层的对象转换成一段连续的二进制串，或者反过来，把二进制串转换成应用层的对象–这两个功能就是序列化和反序列化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;序列化： 将数据结构或对象转换成二进制串的过程&lt;/li&gt;
&lt;li&gt;反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-protobuf&#34;&gt;2. Protobuf&lt;/h3&gt;
&lt;p&gt;Protobuf是一种轻量级的数据交换格式，具有高效、可扩展、跨平台等特点，用于通信协议、数据存储等。&lt;/p&gt;
&lt;p&gt;Protobuf只需定义一次数据的结构化方式，然后可以使用特殊生成的源代码轻松地使用多种语言在各种数据流中写入和读取结构化数据。&lt;/p&gt;
&lt;p&gt;Protobuf甚至可以在不破坏针对“旧”格式编译的已部署程序的情况下更新数据结构。&lt;/p&gt;
&lt;p&gt;其主要优点有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标准的IDL和IDL编译器，这使得其对工程师非常友好。&lt;/li&gt;
&lt;li&gt;序列化数据非常简洁，紧凑，与XML相比，其序列化之后的数据量约为1/3到1/10。&lt;/li&gt;
&lt;li&gt;解析速度非常快，比对应的XML快约20-100倍。&lt;/li&gt;
&lt;li&gt;提供了非常友好的动态库，使用非常简洁，反序列化只需要一行代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Protobuf的语法规则定义了如何描述消息类型、字段、枚举等元素，以及如何将这些元素序列化为二进制数据。下面是Protobuf的语法规则的简要介绍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;消息类型的定义：使用message关键字定义一个消息类型，可以包含多个字段，每个字段有一个名称、类型和标识符。字段可以是必需的、可选的或重复的，可以设置默认值和注释。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字段类型的定义：Protobuf支持多种基本类型，包括整数、浮点数、布尔值、字符串、字节流等，还支持嵌套类型和枚举类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以使用&lt;strong&gt;required、optional和repeated&lt;/strong&gt;关键字定义字段的必需性和重复性。&lt;br&gt;
&lt;strong&gt;①required&lt;/strong&gt;: 必须赋值，不能为空，否则该条message会被认为是“uninitialized”。除此之外，“required”字段跟“optional”字段并无差别。&lt;br&gt;
&lt;strong&gt;②optional&lt;/strong&gt;:字段可以赋值，也可以不赋值。假如没有赋值的话，会被赋上默认值。&lt;br&gt;
&lt;strong&gt;③repeated&lt;/strong&gt;: 该字段可以重复任意次数，包括0次。重复数据的顺序将会保存在protocol buffer中，将这个字段想象成一个可以自动设置size的数组就可以了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字段的值为字段编号，用来标记该字段在序列化后的二进制数据中所在的field，每个字段的Number在message内部都是独一无二的。也不能进行改变，否则数据就不能正确的解包，可以用于快速定位和解析字段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;枚举类型的定义：使用enum关键字定义一个枚举类型，可以包含多个枚举值，每个枚举值有一个名称和一个整数值。枚举类型的整数值可以是任意整数，也可以使用[deprecated]标记表示该枚举值已经过时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务类型的定义：使用service关键字定义一个服务类型，可以包含多个RPC方法，每个RPC方法有一个名称、输入参数和输出参数。RPC方法可以是单向的、请求-响应的或流式的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件描述符的定义：使用syntax、package和import关键字定义文件的元数据，包括语法版本、包名和导入的其他文件。文件描述符可以使用proto文件的二进制格式或JSON格式进行序列化和反序列化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Protobuf还支持扩展、注释、默认值、嵌套类型等高级特性，可以根据实际需求进行灵活使用。&lt;/p&gt;
&lt;h3 id=&#34;3-简单的实例分析&#34;&gt;3. 简单的实例分析&lt;/h3&gt;
&lt;p&gt;使用Protobuf语法编写&lt;code&gt;.proto&lt;/code&gt;文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Protobuf&#34;&gt;syntax = &amp;quot;proto2&amp;quot;;
package test;
message TestMsg {
    required string name = 1;
    required int32 id = 2;
}

enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;syntax = &amp;quot;proto2&amp;quot;&lt;/code&gt;：指定了protobuf文件的语法版本，即proto2。proto2是protobuf的第二个版本，是目前广泛使用的版本。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;package test&lt;/code&gt;：指定了protobuf文件的包名，即test。包名用于标识该文件所属的命名空间，可以避免不同文件中的消息类型名称冲突。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;message TestMsg&lt;/code&gt;部分定义了一个protobuf消息类型，用于描述测试信息。具体来说，包含了两个必须赋值的字段，分别是string类型的name和32位整数类型的id。它们的字段编号分别为1和2，这标识了它们的数据的位置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enum PhoneType&lt;/code&gt;部分定义了一个枚举类型，有着三个值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-编译文件&#34;&gt;4. 编译文件&lt;/h3&gt;
&lt;p&gt;安装参考：https://github.com/protocolbuffers/protobuf&lt;/p&gt;
&lt;p&gt;安装完成后，使用如下命令编译&lt;code&gt;.proto&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;python环境会将.proto文件编译为*_pb2.py (比如test.proto编译为test_pb2.py)，python内部调用就需要&lt;code&gt;import *_pb2&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;protoc ./test.proto  --python_out=./
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译完成后的python文件test_pb2.py 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: test.proto

import sys
_b=sys.version_info[0]&amp;lt;3 and (lambda x:x) or (lambda x:x.encode(&#39;latin1&#39;))
from google.protobuf.internal import enum_type_wrapper
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import symbol_database as _symbol_database
from google.protobuf import descriptor_pb2
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()

DESCRIPTOR = _descriptor.FileDescriptor(
  name=&#39;test.proto&#39;,
  package=&#39;try&#39;,
  syntax=&#39;proto2&#39;,
  serialized_pb=_b(&#39;\n\ntest.proto\x12\x03try\&amp;quot;#\n\x07TestMsg\x12\x0c\n\x04name\x18\x01 \x02(\t\x12\n\n\x02id\x18\x02 \x02(\x05*+\n\tPhoneType\x12\n\n\x06MOBILE\x10\x00\x12\x08\n\x04HOME\x10\x01\x12\x08\n\x04WORK\x10\x02&#39;)
)

_PHONETYPE = _descriptor.EnumDescriptor(
  name=&#39;PhoneType&#39;,
  full_name=&#39;try.PhoneType&#39;,
  filename=None,
  file=DESCRIPTOR,
  values=[
    _descriptor.EnumValueDescriptor(
      name=&#39;MOBILE&#39;, index=0, number=0,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name=&#39;HOME&#39;, index=1, number=1,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name=&#39;WORK&#39;, index=2, number=2,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=56,
  serialized_end=99,
)
_sym_db.RegisterEnumDescriptor(_PHONETYPE)

PhoneType = enum_type_wrapper.EnumTypeWrapper(_PHONETYPE)
MOBILE = 0
HOME = 1
WORK = 2

_TESTMSG = _descriptor.Descriptor(
  name=&#39;TestMsg&#39;,
  full_name=&#39;try.TestMsg&#39;,
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name=&#39;name&#39;, full_name=&#39;try.TestMsg.name&#39;, index=0,
      number=1, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=_b(&amp;quot;&amp;quot;).decode(&#39;utf-8&#39;),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None, file=DESCRIPTOR),
    _descriptor.FieldDescriptor(
      name=&#39;id&#39;, full_name=&#39;try.TestMsg.id&#39;, index=1,
      number=2, type=5, cpp_type=1, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None, file=DESCRIPTOR),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax=&#39;proto2&#39;,
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=19,
  serialized_end=54,
)

DESCRIPTOR.message_types_by_name[&#39;TestMsg&#39;] = _TESTMSG
DESCRIPTOR.enum_types_by_name[&#39;PhoneType&#39;] = _PHONETYPE
_sym_db.RegisterFileDescriptor(DESCRIPTOR)

TestMsg = _reflection.GeneratedProtocolMessageType(&#39;TestMsg&#39;, (_message.Message,), dict(
  DESCRIPTOR = _TESTMSG,
  __module__ = &#39;test_pb2&#39;
  # @@protoc_insertion_point(class_scope:try.TestMsg)
  ))
_sym_db.RegisterMessage(TestMsg)

# @@protoc_insertion_point(module_scope)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-使用protobuf&#34;&gt;5. 使用Protobuf&lt;/h3&gt;
&lt;p&gt;编译完成以后，就可以直接导入刚才编译得到的python文件用于序列化和反序列化了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import test_pb2

# 序列化
obj = test_pb2.TestMsg()
obj.id = 1
obj.name = &amp;quot;zhangsan&amp;quot;
p = obj.SerializeToString()
print(&amp;quot;序列化结果：&amp;quot;, p)

# 反序列化
new_obj = test_pb2.TestMsg()
new_obj.ParseFromString(p)
print(&amp;quot;反序列化结果：\n&amp;quot;, new_obj)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里打印出序列化结果，并将构建新的对象进行反序列化，再打印出反序列化结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;序列化结果： b&#39;\n\x08zhangsan\x10\x01&#39;
反序列化结果：
name: &amp;quot;zhangsan&amp;quot;
id: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-扩展阅读&#34;&gt;6. 扩展阅读&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.infoq.cn/article/json-is-5-times-faster-than-protobuf&#34;&gt;Protobuf 有没有比 JSON 快 5 倍？&lt;/a&gt;&lt;br&gt;
该文章针对不同类型的数据，详细测试了Protobuf与JSON之间的性能对比。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1687165162927.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1687165168752.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
他的比较结果显示，JSON 最差的情况是下面几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跳过非常长的字符串：和字符串长度线性相关。&lt;/li&gt;
&lt;li&gt;解码 double 字段：Protobuf 优势明显，是 Jsoniter 的 3.27 倍，是 Jackson 的 13.75 倍。&lt;/li&gt;
&lt;li&gt;编码 double 字段：如果不能接受只保留 6 位小数，Protobuf 是 Jackson 的 12.71 倍。如果接受精度损失，Protobuf 是 Jsoniter 的 1.96 倍。&lt;/li&gt;
&lt;li&gt;解码整数：Protobuf 是 Jsoniter 的 2.64 倍，是 Jackson 的 8.51 倍。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Protobuf在处理字符串和对象列表时，性能甚至不如某些高性能的JSON，如DSL-JSON&lt;/p&gt;
&lt;p&gt;因此如果生产环境中的 JSON 没有那么多的 double 字段，都是字符串占大头，那么基本上来说替换成 Protobuf 并不会特别明显的提高速度。如果不幸的话，没准 Protobuf 还要更慢一点。&lt;/p&gt;
">Protobuf：序列化与反序列</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/iWQe48TGd/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;QT是一个跨平台的C++应用程序框架，由Qt公司开发。它提供了丰富的GUI组件和功能，可以用于创建各种类型的应用程序。&lt;/p&gt;
&lt;p&gt;QT的API非常丰富，包括GUI组件、网络、数据库、多媒体、图形等方面的功能。&lt;/p&gt;
&lt;p&gt;QT是一个非常流行的应用程序框架，被广泛用于开发桌面应用程序、移动应用程序、嵌入式系统等。&lt;/p&gt;
&lt;p&gt;QT的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;跨平台性&lt;/strong&gt;：QT是一个跨平台的应用程序框架，可以在Windows、Linux、macOS等操作系统上运行。QT提供了一组统一的API，可以让开发者在不同的平台上编写相同的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;面向对象&lt;/strong&gt;：QT是一个面向对象的应用程序框架，它使用C++语言编写。QT的API设计非常优雅，可以让开发者使用面向对象的方式来编写应用程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;丰富的GUI组件&lt;/strong&gt;：QT提供了丰富的GUI组件，包括按钮、标签、文本框、列表框、树形控件、表格控件等。这些组件可以用于创建各种类型的用户界面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;高效的绘图&lt;/strong&gt;：QT提供了高效的绘图功能，可以用于创建各种类型的图形界面。QT的绘图功能支持矢量图形、像素图形、OpenGL等多种绘图方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据库支持&lt;/strong&gt;：QT提供了数据库支持，可以用于连接各种类型的数据库，包括MySQL、SQLite、Oracle等。QT的数据库支持非常强大，可以用于创建各种类型的数据库应用程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多语言支持&lt;/strong&gt;：QT提供了多语言支持，可以用于创建多语言应用程序。QT的多语言支持非常强大，可以让开发者轻松地创建多语言应用程序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;pyqt和pyside的关系&#34;&gt;PyQt和PySide的关系&lt;/h2&gt;
&lt;p&gt;PyQt和PySide是两个Python模块，用于将Qt库的API绑定到Python语言中。它们提供了一组Python API，用于创建Qt应用程序。这样做的最大好处就是在保留了Qt高运行效率的同时，大大提高了开发效率。PyQt和PySide对Qt做了完整的封装，几乎可以用PyQt做Qt能做的任何事情。&lt;/p&gt;
&lt;p&gt;PyQt和PySide的API与Qt库的API都非常相似，因此可以很容易地使用Qt库的文档和示例来学习PyQt和PySide。&lt;/p&gt;
&lt;p&gt;PySide和PyQt的主要区别在于它们的开发者和许可证。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开发者&lt;/strong&gt;：PySide是由Qt公司开发的Python模块，而PyQt是由Riverbank Computing开发的Python模块。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;许可证&lt;/strong&gt;：PySide使用LGPL许可证，而PyQt使用GPL许可证或商业许可证。这意味着，如果使用PySide开发的应用程序是开源的，那么可以免费使用PySide。但是，如果使用PyQt开发的应用程序是开源的，那么必须使用GPL许可证。如果想要使用商业许可证，则需要购买PyQt的商业许可证。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种不同主要是由于历史引起的，最初Qt的母公司是Nokia，后来riverbank computing公司开发了PyQt，但是PyQt使用的是GPLv3许可协议，即如果你的程序引用了该协议的程序，则你的程序也必须开源，如果你想要商业闭源，则必须购买该公司的商业许可协议。&lt;/p&gt;
&lt;p&gt;Nokia公司希望修改协议内容以吸引更多的商业用户，但是riverbank computing公司不同意，因此，Nokia公司推出了PySide。PySide使用的是LGPL协议，LGPL协议是一个商业友好的协议：使用 LGPL 协议开发闭源程序，如果你使用动态链接的形式，那么，你可以以任何形式（商业的、非商业的、开源的、非开源的等等）发布你的应用程序。&lt;/p&gt;
&lt;p&gt;除了开发者和许可证之外，PySide和PyQt的API也有一些微小的差异。例如，PySide的信号和槽机制使用了Python的装饰器语法，而PyQt使用了C++的语法。此外，PySide和PyQt的一些GUI组件的名称也略有不同。&lt;/p&gt;
&lt;h2 id=&#34;qtpy&#34;&gt;QT.py&lt;/h2&gt;
&lt;p&gt;QT.py是一个Python模块，用于在不同的Python GUI工具包之间提供统一的API。它可以让开发者在不同的GUI工具包之间切换，而无需更改代码。QT.py模块提供了一组统一的API，这些API与PyQt、PySide、PySide2等GUI工具包的API类似，但是在不同的GUI工具包之间具有相同的行为。&lt;/p&gt;
&lt;p&gt;QT.py的主要特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;统一的API&lt;/strong&gt;：QT.py提供了一组统一的API，这些API与PyQt、PySide、PySide2等GUI工具包的API类似，但是在不同的GUI工具包之间具有相同的行为。这意味着，开发者可以使用QT.py编写与PyQt、PySide、PySide2等GUI工具包类似的代码，而无需了解其他GUI工具包的API。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;跨平台性&lt;/strong&gt;：QT.py可以在不同的平台上运行，包括Windows、Linux、macOS等操作系统。这意味着，开发者可以使用QT.py编写跨平台的应用程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;易于使用&lt;/strong&gt;：QT.py的API设计非常简单，易于使用。开发者可以很容易地学习和使用QT.py。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开源&lt;/strong&gt;：QT.py是一个开源的Python模块，可以免费使用和分发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体来说就是，通过QT.py你可以在无需了解具体使用的GUI工具包的情况下（可能是Pyside,可能是Pyside2,可能是pyqt5等等），使用统一的API来调用它们。&lt;/p&gt;
">QT、PyQt、Pyside、QT.py之间的关系和区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/uvuv-zhan-kai-de-han-yi-he-zuo-yong/"" data-c="
          &lt;h2 id=&#34;什么是uv贴图和展开&#34;&gt;什么是UV贴图和展开？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;UV贴图是一种将2D图像映射到3D模型表面的技术&lt;/strong&gt;，它通常用于给3D模型添加纹理、颜色和其他视觉效果。&lt;strong&gt;UV贴图的原理是将2D图像的坐标系映射到3D模型的表面上，使得每个表面上的点都对应着2D图像上的一个像素&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在进行UV贴图之前，需要先对3D模型进行展开操作，将其表面展开成一个平面。展开操作通常会生成一个UV坐标系，用于将2D图像映射到3D模型表面上。展开操作可以手动进行，也可以使用自动展开工具进行。&lt;/p&gt;
&lt;p&gt;展开操作和UV贴图是3D模型制作中非常重要的步骤，它们可以为3D模型添加丰富的纹理和视觉效果，使得模型更加真实、生动。&lt;/p&gt;
&lt;p&gt;具体来说，&lt;strong&gt;UV就是一张二维图像，UV映射就是将二维图像投影到三维模型的表面以进行纹理映射的3D建模过程&lt;/strong&gt;。创建UV贴图的过程称为UV展开。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;U代表水平方向，V代表垂直方向&lt;/strong&gt;，所以&lt;strong&gt;U和V就代表了2D纹理的轴，而 X,Y,Z 则用于表示三维模型空间中3D对象的轴&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;1uv&#34;&gt;1UV&lt;/h2&gt;
&lt;p&gt;用于漫反射纹理、法线纹理、PBR纹理等纹理的UV映射。&lt;/p&gt;
&lt;h2 id=&#34;2uv&#34;&gt;2UV&lt;/h2&gt;
&lt;p&gt;用于引擎烘培所生成的光照纹理的UV映射。为了满足使用的需要，2UV应当尽量满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能有重叠，全部展开UV&lt;/li&gt;
&lt;li&gt;尽量减少uv断开，接缝尽量在看不到或者硬面的位置&lt;/li&gt;
&lt;li&gt;单个模型UV尽量摆满整个UV格&lt;/li&gt;
&lt;/ul&gt;
">UV、UV展开的含义和作用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/BUzNRgpmu/"" data-c="
          &lt;h2 id=&#34;web服务器框架&#34;&gt;web服务器框架&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1689593389591.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;模块&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;I/O处理单元&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;处理客户连接，读写网络数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;逻辑单元&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;处理客户连接，读写网络数据业务进程或线程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网络存储单元&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据库、文件或缓存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网络存储单元&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;各单元之间的通信方式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;I/O处理单元是服务器管理客户连接的模块。它通常要完成以下工作:等待并接受新的客户连接，接收客户数据,将服务器响应数据返回给客户端但是数据的收发不-定在I/O处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个逻辑单元通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给I/O处理单元或者直接发送给客户端(具体使用哪种方式取决于事件处理模式)。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络存储单元可以是数据库、缓存和文件,但不是必须的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求队列是各单元之间的通信方式的抽象。I/O 处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。请求队列通常被实现为池的一部分。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;事件处理模式&#34;&gt;事件处理模式&lt;/h2&gt;
&lt;p&gt;服务器程序通常需要处理三类事件: &lt;strong&gt;I/O 事件、信号及定时事件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一般有两种高效的事件处理模式: &lt;strong&gt;Reactor&lt;/strong&gt; 和&lt;strong&gt;Proactor&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步I/O模型通常用于实现&lt;strong&gt;Reactor&lt;/strong&gt;模式&lt;/li&gt;
&lt;li&gt;异步I/O模型通常用于实现&lt;strong&gt;Proactor&lt;/strong&gt;模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;reactor模式&#34;&gt;Reactor模式&lt;/h3&gt;
&lt;p&gt;该模式要求主线程(I/O处理单元) 只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程(逻辑单元)，将socket可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。&lt;/p&gt;
&lt;p&gt;读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。&lt;/p&gt;
&lt;p&gt;使用同步I/O模拟 (以&lt;code&gt;epoll_wait&lt;/code&gt;为例) 实现的&lt;strong&gt;Reactor&lt;/strong&gt;模式的工作流程是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主线程往epoll内核事件表中注册socket上的读就绪事件。&lt;/li&gt;
&lt;li&gt;主线程调用&lt;code&gt;epoll_wait&lt;/code&gt;等待socket上有数据可读。&lt;/li&gt;
&lt;li&gt;当socket上有数据可读时，&lt;code&gt;epoll_wait&lt;/code&gt;通知主线程。主线程则将socket可读事件放入请求队列。&lt;/li&gt;
&lt;li&gt;睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。&lt;/li&gt;
&lt;li&gt;当主线程调用&lt;code&gt;epoll_wait&lt;/code&gt;等待socket可写。&lt;/li&gt;
&lt;li&gt;当socket可写时, &lt;code&gt;epoll_wait&lt;/code&gt;通知主线程。主线程将socket可写事件放入请求队列。&lt;/li&gt;
&lt;li&gt;睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Reactor模式的工作流程：&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1689593402218.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;proactor模式&#34;&gt;Proactor模式&lt;/h3&gt;
&lt;p&gt;Proactor模式将所有I/O操作都交给主线程和内核来处理(进行读、写)，工作线程仅仅负责业务逻辑。&lt;/p&gt;
&lt;p&gt;使用异步I/O模型(以&lt;code&gt;aio_read&lt;/code&gt;和&lt;code&gt;aio_write&lt;/code&gt;为例)实现的Proactor模式的工作流程是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主线程调用&lt;code&gt;aio_read&lt;/code&gt;函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序(这里以信号为例)。&lt;/li&gt;
&lt;li&gt;主线程继续处理其他逻辑。&lt;/li&gt;
&lt;li&gt;当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号， 以通知应用程序数据已经可用。&lt;/li&gt;
&lt;li&gt;应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用&lt;code&gt;aio_write&lt;/code&gt;函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。&lt;/li&gt;
&lt;li&gt;主线程继续处理其他逻辑。&lt;/li&gt;
&lt;li&gt;当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号, 以通知应用程序数据已经发送完毕。&lt;/li&gt;
&lt;li&gt;应用程序预先定义好的信号处理函数选择-个工作线程来做善后处理，比如决定是否关闭socket。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Proactor模式工作流程：&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1689593411012.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;同步io模型实现proactor模式&#34;&gt;同步IO模型实现Proactor模式&lt;/h4&gt;
&lt;p&gt;使用同步I/O方式模拟出Proactor模式。原理是:主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一”完成事件”。&lt;/p&gt;
&lt;p&gt;那么从工作线程的角度来看,它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。&lt;/p&gt;
&lt;p&gt;使用同步I/O模型(以&lt;code&gt;epoll_wait&lt;/code&gt;为例)模拟出的Proactor模式的工作流程如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主线程往epoll内核事件表中注册socket上的读就绪事件。&lt;/li&gt;
&lt;li&gt;主线程调用&lt;code&gt;epoll_wait&lt;/code&gt;等待socket上有数据可读。&lt;/li&gt;
&lt;li&gt;当socket上有数据可读时，&lt;code&gt;epoll_wait&lt;/code&gt;通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。&lt;/li&gt;
&lt;li&gt;睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。&lt;/li&gt;
&lt;li&gt;主线程调用&lt;code&gt;epoll_wait&lt;/code&gt; 等待socket可写。&lt;/li&gt;
&lt;li&gt;当socket可写时, &lt;code&gt;epoll_wait&lt;/code&gt; 通知主线程。主线程往socket上写入服务器处理客户请求的结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同步I/O模拟Proactor模式的工作流程:&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1689593418479.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;线程池&#34;&gt;线程池&lt;/h2&gt;
&lt;p&gt;线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和CPU数量差不多。计算线程池中线程数目的公式并不是一个固定的标准，而是根据具体的应用场景和需求来确定的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU密集型任务：对于主要是进行CPU计算的任务，可以根据CPU核心数来设置线程数目。一般来说，线程数目可以设置为CPU核心数的1.5倍到2倍之间，以充分利用CPU资源，常用为 N+1，N为核心数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I/O密集型任务：对于主要是进行I/O操作的任务，可以根据系统的I/O设备的并发能力来设置线程数目。一般来说，线程数目可以设置为I/O设备的并发能力的倍数，以充分利用I/O资源。常用为 2*N+1，N为核心数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应时间要求：如果对系统的响应时间有较高的要求，可以根据响应时间的目标来计算线程数目。可以使用Little&#39;s Law公式：线程数目 = 并发请求数目 × 平均响应时间 / 单位时间内完成的请求数目。根据这个公式，可以根据目标响应时间和单位时间内完成的请求数目来计算线程数目。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程池中的所有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。至于主线程选择哪个子线程来为新任务服务，则有多种方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主线程使用某种算法来主动选择子线程。最简单、最常用的算法是随机算法和Round Robin (轮流选取)算法，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器的整体压力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。当有新的任务到来时,主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程将获得新任务的”接管权&amp;quot;，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在工作队列上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程池的一般模型为:&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1689593425767.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;线程池小结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用是用空间换时间，浪费服务器的硬件资源，换取运行效率。&lt;/li&gt;
&lt;li&gt;线程池是一组资源的集合, 这组资源&lt;strong&gt;在服务器启动之初就被完全创建好并初始化&lt;/strong&gt;，这称为&lt;strong&gt;静态资源&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，&lt;strong&gt;无需动态分配&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当服务器处理完一个客户连接后，可以把相关的资源放回池中，&lt;strong&gt;无需执行系统调用释放资源&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
">[C++项目] Web Server（10）：Web服务</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/VEcrG8xkE/"" data-c="
          &lt;p&gt;一个Web Server就是一个服务器软件(程序)，或者是运行这个服务器软件的硬件(计算机)。其主要功能是通过HTTP协议与客户端(通常是浏览器(Browser))进行通信，来接收，存储，处理来自客户端的HTTP请求，并对其请求做出HTTP响应，返回给客户端其请求的内容(文件、网页等)或返回一个Error信息。&lt;/p&gt;
&lt;p&gt;通常用户使用Web浏览器与相应服务器进行通信。&lt;/p&gt;
&lt;p&gt;在浏览器中键入“域名&amp;quot;或&amp;quot;IP地址:端口号”，浏览器则先将你的域名解析成相应的IP地址或者直接根据你给出的IP地址向对应的Web服务器发送一个HTTP请求。&lt;/p&gt;
&lt;p&gt;这一过程首先要通过TCP协议的三次握手建立与目标Web服务器的连接，然后HTTP协议生成针对目标Web服务器的HTTP请求报文，通过TCP、IP等协议发送到目标Web服务器上。&lt;/p&gt;
&lt;h2 id=&#34;http协议&#34;&gt;HTTP协议&lt;/h2&gt;
&lt;p&gt;超文本传输协议(Hypertext Transfer Protocol，HTTP)是一个简单的请求-响应协议，它通常运行在TCP之上。它&lt;strong&gt;指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;请求和响应消息的头以&lt;code&gt;ASCII&lt;/code&gt;形式给出; 而消息内容则具有一个类似&lt;code&gt;MIME&lt;/code&gt;的格式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MIME&lt;/code&gt;（Multipurpose Internet Mail Extensions）是一种互联网标准，用于标识在互联网上交换的多媒体文件的类型。它的中文翻译为多用途互联网邮件扩展。MIME最初是为了扩展互联网电子邮件的功能而设计的，后来被广泛应用于Web开发和其他互联网应用中。MIME类型是一种字符串标识，用于指示文件的内容类型和格式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MIME&lt;/code&gt;类型通常由两部分组成，用斜杠分隔。第一部分是主类型（top-level type），表示文件的大类别，例如文本、图像、音频、视频等。第二部分是子类型（sub-type），表示文件的具体类型，例如HTML、JPEG、PNG、MP3、MP4等。例如文本文件：text/plain、text/html、text/css、text/javascript等；图像文件：image/jpeg、image/png、image/gif等。&lt;/p&gt;
&lt;p&gt;HTTP是万维网的数据通信的基础。HTTP的发展是由蒂姆.伯纳斯-李于1989年在欧洲核子研究组织(CERN)所发起。HTTP的标准制定由万维网协会(World Wide Web Consortium，W3C)和互联网工程任务组(Internet Engineering Task Force，IETF) 进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的RFC 2616，定义了HTTP协议中现今广泛使用的一个版本 -- HTTP 1.1。&lt;/p&gt;
&lt;h3 id=&#34;概述&#34;&gt;概述&lt;/h3&gt;
&lt;p&gt;HTTP是一个客户端终端(用户)和服务器端(网站) 请求和应答的标准(TCP)。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口(默认端口为80)。&lt;/p&gt;
&lt;p&gt;我们称这个客户端为用户代理程序(user agent)。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器(origin server)。在用户代理和源服务器中间可能存在多个”中间层”，比如代理服务器、网关或者隧道(tunnel)。&lt;/p&gt;
&lt;p&gt;尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中其实并没有规定必须使用它或它支持的层。&lt;/p&gt;
&lt;p&gt;事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP 假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。&lt;/p&gt;
&lt;p&gt;通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口 (默认是80端口) 的TCP连接。HTTP 服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如&amp;quot;HTTP/1.1 200 OK&amp;quot;，以及返回的内容，如请求的文件、错误消息、或者其它信息。&lt;/p&gt;
&lt;h3 id=&#34;工作原理&#34;&gt;工作原理&lt;/h3&gt;
&lt;p&gt;HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、 协议版本、请求头部和请求数据。&lt;/p&gt;
&lt;p&gt;服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。&lt;/p&gt;
&lt;p&gt;以下是HTTP请求/响应的步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;客户端连接到Web服务器&lt;br&gt;
一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口(默认为80)建立一个TCP套接字连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发送HTTP请求&lt;br&gt;
通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器接受请求并返回HTTP响应&lt;br&gt;
Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;释放连接TCP连接&lt;br&gt;
若&lt;code&gt;connection&lt;/code&gt;模式为&lt;code&gt;close&lt;/code&gt;，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若&lt;code&gt;connection&lt;/code&gt;模式为&lt;code&gt;keepalive&lt;/code&gt;，则该连接会保持一段时间，在该时间内可以继续接收请求;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端浏览器解析HTML内容:&lt;br&gt;
客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头, 响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML,根据HTML的语法对其进行格式化,并在浏览器窗口中显示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;HTTP协议是基于TCP/IP协议之上的应用层协议,基于请求响应的模式。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。&lt;/p&gt;
&lt;h4 id=&#34;请求报文格式&#34;&gt;请求报文格式&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1689593231443.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;下面以浏览器访问百度的请求为例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;GET / HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
Cache-Control: max-age=0
Connection: keep-alive
Cookie: __bid_n=1879dc153299729a934207; BAIDU_WISE_UID=wapp_1684121762801_335; ZFY=Rxks9sSCnPIkORUAOc7O7zhQJFOpvtk02rMFJyIVNQQ:C; FPTOKEN=JsiPtl1FqJmRcljXPi4Xn9G+M5oRGiwNByeZxHnsvusctfARX2sY3r2ftEvR1jZYoxhtCVxNx7M4wy/U3eBYiZ7VG7qUn8g048nFHis0IGAA4xDUBAIPgxvJKDGm1OUFbKgm5/wKxIYBAmv1CvoKxwQS4fVObH5h5I1Kkhgfhcb5lddQfx7WhTZ7uid/kMQdU8itwMJR+qw2+Yvw0nBYL+gPaJrwwT7XALXc8emXON/pdbifGedNVntxY2TXkPwRF89My3qLtSN5xXv9R1ntouykX5qfn/Q1z/QcADKLdsVM2kq9TGlVBcvXvMpFffZ3XNvn4qtnjkioeJ9w4qMFp9dRX99M2XQm6LVg/RtSbpAIFuTWnT3/t0zT6lmP/X87qMCoFSdFUcqBz/sYBRfdPw==|Ed//EpKbIXUWIyaMWSJGQPoDqip2WtJDhPgMo9HSEOU=|10|0c3e9703287630d023700eb3a5a4fccb; shifen[579024899971_7604]=1689321737; BCLID=9021858364690105001; BDSFRCVID=Jp8OJeC629Wxl9Jf4DAQ7wmg8b6HbV3TH6_nYnCKbCQEbYhYUBhhEG0PnU8g0KFMUp9MogKK3gOTH4PF_2uxOjjg8UtVJeC6EG0Ptf8g0f5; H_BDCLCKID_SF=JnItoI_htK03q5rcbJQEbCCShGRZbTv9WDTm_D_XQ-nSbqcIjMON0j-WhftO5j57KHFe-pPKXbrZDlOo-xbGQtD4MbrP3tv33mkjbnrGfn02OpQE3J0BXt4syP4eKMRnWnnTKfA-b4ncjRcTehoM3xI8LNj405OTbIFO0KJDJCcjqR8ZDjDWDT5P; BIDUPSID=B3832D42FA4D1FDA91567025145671CD; PSTM=1689579495; BAIDUID=B3832D42FA4D1FDA843B9A299A2B843E:FG=1; BD_HOME=1; H_PS_PSSID=36542_38642_38831_39027_39023_38942_38882_38956_39009_39038_38972_38810_38986_38639_26350_39095_39100_38952; BAIDUID_BFESS=B3832D42FA4D1FDA843B9A299A2B843E:FG=1; BCLID_BFESS=9021858364690105001; BDSFRCVID_BFESS=Jp8OJeC629Wxl9Jf4DAQ7wmg8b6HbV3TH6_nYnCKbCQEbYhYUBhhEG0PnU8g0KFMUp9MogKK3gOTH4PF_2uxOjjg8UtVJeC6EG0Ptf8g0f5; H_BDCLCKID_SF_BFESS=JnItoI_htK03q5rcbJQEbCCShGRZbTv9WDTm_D_XQ-nSbqcIjMON0j-WhftO5j57KHFe-pPKXbrZDlOo-xbGQtD4MbrP3tv33mkjbnrGfn02OpQE3J0BXt4syP4eKMRnWnnTKfA-b4ncjRcTehoM3xI8LNj405OTbIFO0KJDJCcjqR8ZDjDWDT5P; BD_UPN=12314753; BA_HECTOR=ag8lah0ha0058h840g8h048o1ib9rv91o; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598
Host: www.baidu.com
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: none
Sec-Fetch-User: ?1
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.67
sec-ch-ua: &amp;quot;Not.A/Brand&amp;quot;;v=&amp;quot;8&amp;quot;, &amp;quot;Chromium&amp;quot;;v=&amp;quot;114&amp;quot;, &amp;quot;Microsoft Edge&amp;quot;;v=&amp;quot;114&amp;quot;
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: &amp;quot;Windows&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段HTTP请求报文包含了以下各项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;请求行：&lt;code&gt;GET / HTTP/1.1&lt;/code&gt;，表示使用&lt;code&gt;GET&lt;/code&gt;方法请求根路径&lt;code&gt;/&lt;/code&gt;，使用&lt;code&gt;HTTP/1.1&lt;/code&gt;协议版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求头部：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Accept&lt;/code&gt;：表示客户端可以接受的响应内容类型，包括文本、图像、音频、视频等多种类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;：表示客户端可以接受的响应内容编码方式，包括&lt;code&gt;gzip&lt;/code&gt;、&lt;code&gt;deflate&lt;/code&gt;、&lt;code&gt;br&lt;/code&gt;等多种编码方式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Accept-Language&lt;/code&gt;：表示客户端可以接受的响应内容语言，包括中文、英文等多种语言。其中的q值代表权重，即用户对语言的偏好。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Cache-Control&lt;/code&gt;：表示客户端要求服务器缓存响应的内容，这里指定为不缓存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Connection&lt;/code&gt;：表示客户端要求的连接模式，这里指定使用持久连接，即在一次TCP连接中可以发送多个HTTP请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Cookie&lt;/code&gt;：表示客户端发送的Cookie信息，用于在服务器端识别客户端身份。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Host&lt;/code&gt;：表示客户端要请求的服务器主机名和端口号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sec-Fetch-*&lt;/code&gt;：表示客户端使用了安全性增强的Fetch API，用于防止跨站点攻击。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt;：这里取值为1表示客户端要求服务器将HTTP请求升级为HTTPS请求，以提高安全性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;User-Agent&lt;/code&gt;：表示客户端使用的浏览器或其他HTTP客户端的类型和版本号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sec-ch-ua&lt;/code&gt;：表示客户端使用的浏览器或其他HTTP客户端的类型和版本号，用于防止跨站点攻击。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sec-ch-ua-mobile&lt;/code&gt;：表示客户端使用的设备是否为移动设备。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sec-ch-ua-platform&lt;/code&gt;：表示客户端使用的操作系统平台。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意 请求报文正文部分和头部直接通过空行分开 以标识正文部分&lt;/p&gt;
&lt;h4 id=&#34;响应报文格式&#34;&gt;响应报文格式&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1689593239209.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 200 OK
Bdpagetype: 1
Bdqid: 0x8b8e772e00000658
Connection: keep-alive
Content-Encoding: gzip
Content-Security-Policy: frame-ancestors &#39;self&#39; https://chat.baidu.com http://mirror-chat.baidu.com https://fj-chat.baidu.com https://hba-chat.baidu.com https://hbe-chat.baidu.com https://njjs-chat.baidu.com https://nj-chat.baidu.com https://hna-chat.baidu.com https://hnb-chat.baidu.com http://debug.baidu-int.com;
Content-Type: text/html; charset=utf-8
Date: Mon, 17 Jul 2023 07:39:53 GMT
Server: BWS/1.1
Set-Cookie: BDSVRTM=0; path=/
Set-Cookie: BD_HOME=1; path=/
Set-Cookie: H_PS_PSSID=36542_38642_38831_39027_39023_38942_38882_38956_39009_39038_38810_38986_38639_26350_39095_39100_38952; path=/; domain=.baidu.com
Strict-Transport-Security: max-age=172800
Traceid: 1689579593038918196210056106057417098840
X-Ua-Compatible: IE=Edge,chrome=1
Transfer-Encoding: chunked
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段HTTP响应报文包含了以下各项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;状态行：&lt;code&gt;HTTP/1.1 200 OK&lt;/code&gt;，表示使用&lt;code&gt;HTTP/1.1&lt;/code&gt;协议版本，响应状态码为&lt;code&gt;200&lt;/code&gt;，表示请求成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应头部：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Bdpagetype&lt;/code&gt;：表示百度页面类型，这里的值为1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Bdqid&lt;/code&gt;：表示百度查询ID，用于跟踪查询请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Connection&lt;/code&gt;：表示服务器要求客户端使用持久连接，即在一次TCP连接中可以发送多个HTTP请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;：表示响应内容的编码方式，这里的值为&lt;code&gt;gzip&lt;/code&gt;，表示使用gzip压缩算法对响应内容进行了压缩。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;：表示响应内容的安全策略，用于防止跨站点攻击。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Content-Type&lt;/code&gt;：表示响应内容的类型和字符集，这里的值为&lt;code&gt;text/html; charset=utf-8&lt;/code&gt;，表示响应内容为HTML文本，字符集为UTF-8。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Date&lt;/code&gt;：表示响应的日期和时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Server&lt;/code&gt;：表示服务器的类型和版本号，这里的值为&lt;code&gt;BWS/1.1&lt;/code&gt;，表示使用百度Web服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;：表示服务器要求客户端设置Cookie信息，这里包括了三个&lt;code&gt;Set-Cookie&lt;/code&gt;字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BDSVRTM=0; path=/&lt;/code&gt;：表示设置一个名为&lt;code&gt;BDSVRTM&lt;/code&gt;的Cookie，值为0，路径为根路径。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BD_HOME=1; path=/&lt;/code&gt;：表示设置一个名为&lt;code&gt;BD_HOME&lt;/code&gt;的Cookie，值为1，路径为根路径。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;H_PS_PSSID=&lt;/code&gt;：表示设置一个名为&lt;code&gt;H_PS_PSSID&lt;/code&gt;的Cookie，值为一串数字和下划线，路径为根路径，域名为&lt;code&gt;.baidu.com&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些Cookie信息可以帮助服务器在后续的请求中识别客户端身份和状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Strict-Transport-Security&lt;/code&gt;：表示服务器要求客户端使用HTTPS协议进行通信，并设置了一个最大有效期，这里的值为&lt;code&gt;max-age=172800&lt;/code&gt;，表示最大有效期为两天。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Traceid&lt;/code&gt;：表示跟踪ID，用于跟踪请求和响应之间的关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;X-Ua-Compatible&lt;/code&gt;：表示浏览器兼容性模式，这里的值为&lt;code&gt;IE=Edge,chrome=1&lt;/code&gt;，表示使用最新版本的IE和Chrome浏览器进行兼容性处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;响应正文：由于这个响应报文使用了&lt;code&gt;gzip&lt;/code&gt;压缩算法对响应内容进行了压缩，因此响应正文是经过压缩的HTML文本，需要进行解压缩才能查看。另外，由于这个响应报文使用了分块传输编码（&lt;code&gt;chunked&lt;/code&gt;），因此响应正文的长度是不确定的，需要根据每个分块的长度来进行解析。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意 响应报文正文部分和头部直接通过空行分开 以标识正文部分&lt;/p&gt;
&lt;h3 id=&#34;http请求方法&#34;&gt;HTTP请求方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;HTTP/1.1&lt;/code&gt;协议中共定义了八种方法(也叫”动作&amp;quot;) 来以不同方式操作指定的资源:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;GET&lt;/code&gt;：向指定的资源发出“显示”请求。使用&lt;code&gt;GET&lt;/code&gt;方法应该只用在读取数据，而不应当被用于产生“副作用&amp;quot;的操作中，例如在Web Application中。其中一个原因是&lt;code&gt;GET&lt;/code&gt;可能会被网络蜘蛛等随意访问。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HEAD&lt;/code&gt;：与&lt;code&gt;GET&lt;/code&gt;方法一样， 都是向服务器发出指定资源的请求。只不过服务器只返回响应头部信息，不传回资源的报文部分，而 GET 请求则返回完整的响应头部和响应体信息。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中”关于该资源的信息”(元信息或称元数据)。HEAD 请求通常用于获取资源的元数据，而不需要获取资源本身的情况下使用，以减少网络带宽的消耗。比如，想要检查一个文件是否存在，只要发个 HEAD 请求就可以了，没有必要用 GET 把整个文件都取下来。再比如，要检查文件是否有最新版本，同样也应该用 HEAD，服务器会在响应头里把文件的修改时间传回来。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST&lt;/code&gt;：向指定资源提交数据，请求服务器进行处理(例如提交表单或者上传文件)。数据被包含在请求报文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUT&lt;/code&gt;：向指定资源位置上传其最新内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DELETE&lt;/code&gt;：请求服务器删除Request-URI所标识的资源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TRACE&lt;/code&gt;：回显服务器收到的请求，主要用于测试或诊断。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OPTIONS&lt;/code&gt;：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用&lt;code&gt;*&lt;/code&gt;来代替资源名称，向Web服务器发送&lt;code&gt;OPTIONS&lt;/code&gt;请求，可以测试服务器功能是否正常运作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CONNECT&lt;/code&gt;： &lt;code&gt;HTTP/1.1&lt;/code&gt; 协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接(经由非加密的HTTP代理服务器)。&lt;/li&gt;
&lt;/ol&gt;
">[C++项目] Web Server（9）：HTTP协议</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/SdDvGZnq-/"" data-c="
          &lt;p&gt;一个典型的网络IO可以分为两个阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据就绪&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据读写&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而&lt;strong&gt;阻塞/非阻塞&lt;/strong&gt;与&lt;strong&gt;同步/异步IO&lt;/strong&gt;的区别就是在这两个阶段体现的&lt;/p&gt;
&lt;p&gt;注意 &lt;strong&gt;阻塞/非阻塞&lt;/strong&gt; 与 &lt;strong&gt;同步/异步&lt;/strong&gt; 两者之间是&lt;strong&gt;相互独立&lt;/strong&gt;的&lt;/p&gt;
&lt;p&gt;阻塞并不代表同步，异步也不一定非阻塞（不过一般来说，异步IO接口都会设计为非阻塞）&lt;/p&gt;
&lt;h2 id=&#34;阻塞非阻塞&#34;&gt;阻塞/非阻塞&lt;/h2&gt;
&lt;p&gt;在数据就绪阶段，根据数据未到达前的处理方式可以分为阻塞与非阻塞&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;阻塞方式：若数据未就绪，调用IO方法的线程进入阻塞状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非阻塞方式：不会改变线程的状态，通过返回值判断是否有数据到达&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过对文件描述符fd可以设置其阻塞与非阻塞属性&lt;/p&gt;
&lt;p&gt;以recv函数为例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 函数声明
ssize_ t recv(int sockfd, void *buf, size_ t len, int flags);

//使用函数
int size = recv(sockfd, buf, 1024, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;阻塞情况下，若没有数据到达，则程序被挂起，直至有数据到达&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;size==-1&lt;/code&gt;, 表示出错了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size==0&lt;/code&gt;, 对方连接关闭&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size&amp;gt;0&lt;/code&gt;, 读取到了多少的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非阻塞情况下，无论有没有数据都会直接返回，根据其返回值判断数据就绪情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;size==-1&lt;/code&gt;, 表示出错了。但是有三种错误号并不是错误，需要单独判断：
&lt;ul&gt;
&lt;li&gt;EINTR：表示程序中断返回，并不属于错误&lt;/li&gt;
&lt;li&gt;EAGAIN/EWOULDBLOCK：表示非阻塞情况下的数据已读完，并不属于错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size==0&lt;/code&gt;, 对方连接关闭&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size&amp;gt;0&lt;/code&gt;, 读取到了多少的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同步异步&#34;&gt;同步/异步&lt;/h2&gt;
&lt;p&gt;在数据读写阶段，根据读写数据是否需要等待，也即根据数据读写的方式分为同步和异步方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;同步方式：代码中主动调用同步接口读写，在读写完成前程序都必须等待。&lt;code&gt;recv&lt;/code&gt;函数就是一个典型的同步接口。同步的代码编写相对简单。注意，&lt;strong&gt;IO多路复用（&lt;code&gt;selcet&lt;/code&gt;/&lt;code&gt;poll&lt;/code&gt;/&lt;code&gt;epoll&lt;/code&gt;）都是同步的，它们是针对数据就绪阶段的设计。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非阻塞方式：代码中调用异步接口读写，将读写的任务委托给操作系统，程序可以继续往下执行，在读写任务完成后系统会按照传递的通知方式（一般为信号）主动通知程序。比如，&lt;code&gt;aio_read&lt;/code&gt;，&lt;code&gt;aio_write&lt;/code&gt;就是linux下常用的异步接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在处理IO的时候，阻塞和非阻塞都是同步IO，只有使用特殊的API接口的才是异步IO。这种特殊的IO在Linux中一般为&lt;code&gt;AIO&lt;/code&gt;，在windows下为&lt;code&gt;IOCP&lt;/code&gt;，在.NET中为&lt;code&gt;BeginInvoke/EndInvoke&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;具体来说：同步表示A向B请求调用一个网络IO接口时 (或者调用某个业务逻辑API接口时)，数据的读写都是 由请求方A自己来完成的(不管是阻塞还是非阻塞);&lt;/p&gt;
&lt;p&gt;异步表示A向B请求调用一个网络IO接口时(或者调用某个业务逻辑API接口时)，向B传入请求的事件以及事件发生时通知的方式，A就可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。&lt;/p&gt;
&lt;h2 id=&#34;linux上的五种io模型&#34;&gt;Linux上的五种IO模型&lt;/h2&gt;
&lt;p&gt;在Linux系统中，常用的五种IO模型包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;阻塞IO模型（Blocking IO Model）：在阻塞IO模型中，当应用程序发起IO操作时，程序会一直等待，直到IO操作完成并返回结果。在此期间，程序无法执行其他任务。阻塞IO模型是最简单的IO模型，但是会导致程序的性能较低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非阻塞IO模型（Non-blocking IO Model）：在非阻塞IO模型中，当应用程序发起IO操作时，程序会立即返回，而不是等待IO操作完成。在此期间，程序可以执行其他任务。应用程序需要不断地轮询IO操作的状态，直到IO操作完成并返回结果。非阻塞IO模型可以提高程序的性能，但是需要编写复杂的轮询代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IO多路复用模型（IO Multiplexing Model）：在IO复用模型中，应用程序使用select或poll等系统调用来监听多个IO操作的状态。当有IO操作完成时，程序会被唤醒，并处理已完成的IO操作。IO复用模型可以同时处理多个IO操作，提高程序的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号驱动IO模型（Signal-driven IO Model）：在信号驱动IO模型中，应用程序使用sigaction系统调用来注册一个信号处理函数。当IO操作完成时，系统会向应用程序发送一个信号，唤醒信号处理函数来处理已完成的IO操作。信号驱动IO模型可以提高程序的性能，但是需要编写复杂的信号处理代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步IO模型（Asynchronous IO Model）：在异步IO模型中，应用程序发起IO操作后，程序可以继续执行其他任务，而不需要等待IO操作完成。当IO操作完成时，系统会通知应用程序，并处理已完成的IO操作。异步IO模型可以提高程序的性能，但是需要编写复杂的异步回调函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面具体介绍下每种IO模型&lt;/p&gt;
&lt;h3 id=&#34;阻塞io&#34;&gt;阻塞IO&lt;/h3&gt;
&lt;p&gt;调用者调用了某个函数，然后就等待这个函数返回，期间什么也不做，系统内部将会不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1689328049943.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;非阻塞io&#34;&gt;非阻塞IO&lt;/h3&gt;
&lt;p&gt;非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。&lt;/p&gt;
&lt;p&gt;非阻塞I/O执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据&lt;code&gt;errno&lt;/code&gt;区分这两种情况&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;accept&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt;和&lt;code&gt;send&lt;/code&gt;, 事件未发生时, &lt;code&gt;errno&lt;/code&gt;通常被设置成&lt;code&gt;EAGAIN&lt;/code&gt;。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1689328054033.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;io复用&#34;&gt;IO复用&lt;/h3&gt;
&lt;p&gt;Linux用&lt;code&gt;select&lt;/code&gt;/&lt;code&gt;poll&lt;/code&gt;/&lt;code&gt;epoll&lt;/code&gt;函数实现IO复用模型，这些函数也会使进程阻塞，但是和阻塞IO不同的是这些函数&lt;strong&gt;可以同时阻塞多个IO操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时,才真正调用IO操作函数。&lt;/p&gt;
&lt;p&gt;IO复用并不能用于处理高并发的情况，它的作用是在单进程单线程的情况下能一次检测多个IO事件。&lt;/p&gt;
&lt;p&gt;解决高并发还是得靠多进程/多线程。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1689328059897.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;信号驱动io&#34;&gt;信号驱动IO&lt;/h3&gt;
&lt;p&gt;Linux用套接口进行信号驱动IO，通过注册安装一个信号处理函数，数据就绪前进程继续运行并不阻塞,当IO事件就绪时，进程会收到&lt;code&gt;SIGIO&lt;/code&gt;信号，接着在信号处理函数中处理IO事件。&lt;/p&gt;
&lt;p&gt;内核在第一个阶段是异步， 在第二个阶段是同步;与非阻塞IO的区别在于它提供了消息通知机制，不需&lt;br&gt;
要用户进程不断的轮询检查，减少了系统API的调用次数,提高了效率。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1689328064033.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;异步io&#34;&gt;异步IO&lt;/h3&gt;
&lt;p&gt;Linux中，可以调用异步IO接口来执行异步IO。比如，调用&lt;code&gt;aio_read&lt;/code&gt;函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1689328070587.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里介绍下&lt;code&gt;aio_read&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;aio.h&amp;gt;

int aio_read(struct aiocb *aiocbp);


struct aiocb {
  /* The order of these fields is implementation-dependent */
  int             aio_fildes;     /* File descriptor */
  off_t           aio_offset;     /* File offset */
  volatile void  *aio_buf;        /* Location of buffer */
  size_t          aio_nbytes;     /* Length of transfer */
  int             aio_reqprio;    /* Request priority */
  struct sigevent aio_sigevent;   /* Notification method */
  int             aio_lio_opcode; /* Operation to be performed; lio_listio() only */

  /* Various implementation-internal fields not shown */
};

/* Operation codes for &#39;aio_lio_opcode&#39;: */
enum { LIO_READ, LIO_WRITE, LIO_NOP };
&lt;/code&gt;&lt;/pre&gt;
">[C++项目] Web Server（8）：网络IO模型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/_UHeo9S5w/"" data-c="
          &lt;p&gt;本地套接字作用：用于本地间的进程通信&lt;/p&gt;
&lt;h2 id=&#34;本地套接字通信流程&#34;&gt;本地套接字通信流程&lt;/h2&gt;
&lt;p&gt;伪代码形式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//本地套接字通信的流程- tcp

//服务器端
1.创建监听的套接字
  int lfd = socket (AF_UNIX/AF_LOCAL, SOCK_STREAM, 0);

2.监听的套接字绑定本地的套接字文件(内核中的伪文件)-&amp;gt; server端
  struct sockaddr_un addr ;
  //绑定成功之后，指定的sun_ path中的套接字文件会自动生成。
  bind(lfd, addr, len) ;

3.监听
  listen(lfd, 100);

4.等待并接受连接请求
  struct sockaddr_un cliaddr ;
  int cfd = accept(lfd, &amp;amp;cliaddr,len); 

5.通信
  接收数据: read/recv
  发送数据: write/send

6.关闭连接
  close();


//客户端的流程
1.创建通信的套接字
  int fd = socket (AF_UNIX/AF_LOCAL, SOCK_STREAM, 0);

2.监听的套接字绑定本地的IP端口(内核中的伪文件)
  struct sockaddr_un addr;
  //绑定成功之后，指定的sun_path中的套接字文件会自动生成。
  bind(fd, addr, len);

3.连接服务器
  struct sockaddr_un serveraddr;
  connect(fd, &amp;amp;serveraddr, sizeof(serveraddr));

4.通信
接收数据: read/recv
发送数据: write/send

5.关闭连接
  close();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;本地套接字通信客户端代码&#34;&gt;本地套接字通信客户端代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/un.h&amp;gt;

int main(){
    //删除每次生成的伪文件，使得每次都可以绑定成功
    unlink(&amp;quot;client.sock&amp;quot;);

    //创建UDP套接字
    int cfd = socket(AF_LOCAL,SOCK_STREAM,0);
    
    struct sockaddr_un addr;
    addr.sun_family = AF_LOCAL;
    strcpy(addr.sun_path,&amp;quot;client.sock&amp;quot;);
  
    bind(cfd, (struct sockaddr*)&amp;amp;addr, sizeof(addr));


    struct sockaddr_un saddr;
    saddr.sun_family = AF_LOCAL;
    strcpy(saddr.sun_path,&amp;quot;server.sock&amp;quot;);
    connect(cfd,(struct sockaddr*)&amp;amp;saddr,sizeof(saddr));

    int i = 1;
    while (1) {
        
        char buf[1024]= {0}, recvbuf[1024]={0};
        sprintf(buf,&amp;quot;this is %d&amp;quot;,i++);

        send(cfd,buf,strlen(buf)+1,0);

        int len = recv(cfd, recvbuf,sizeof(recvbuf),0);
        if(len==-1){
            perror(&amp;quot;recv&amp;quot;);
            exit(-1);
        }
        else if(len==0){
            printf(&amp;quot;服务器断开连接\n&amp;quot;);
            break;
        }
        else if(len&amp;gt;0){
            printf(&amp;quot;server data: %s\n&amp;quot;,recvbuf);
        }

        sleep(1);
    }

    close(cfd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绑定的文件在sockaddr_un结构体中的sun_path成员中指定，同时本地套接字创建时会自动生成对应sun_path成员中命名的伪文件用于通信。&lt;/p&gt;
&lt;p&gt;注意该文件每次通信时需要删除，否则无法绑定成功。&lt;/p&gt;
&lt;h3 id=&#34;本地套接字通信服务器代码&#34;&gt;本地套接字通信服务器代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/un.h&amp;gt;

int main(){
    //删除每次生成的伪文件，使得每次都可以绑定成功
    unlink(&amp;quot;server.sock&amp;quot;);

    //创建UDP套接字
    int fd = socket(AF_LOCAL,SOCK_STREAM,0);
    
    struct sockaddr_un addr;
    addr.sun_family = AF_LOCAL;
    strcpy(addr.sun_path,&amp;quot;server.sock&amp;quot;);
  
    bind(fd, (struct sockaddr*)&amp;amp;addr, sizeof(addr));

    listen(fd,128);
    
    struct sockaddr_un caddr;
    int len = sizeof(caddr);
    int cfd = accept(fd,(struct sockaddr*)&amp;amp;caddr,&amp;amp;len);

    printf(&amp;quot;cilent sock filename:%s\n&amp;quot;, caddr.sun_path);

    while (1) {
        
        char buf[1024]= {0};
        int len = recv(cfd,buf,sizeof(buf),0);
        if(len==-1){
            perror(&amp;quot;recv&amp;quot;);
            exit(-1);
        }
        else if(len==0){
            printf(&amp;quot;客户端断开连接\n&amp;quot;);
            close(cfd);
            break;
        }
        else if(len&amp;gt;0){
            printf(&amp;quot;cilent data: %s\n&amp;quot;,buf);
            send(cfd,buf,len,0);
        }
    }

    close(fd);
}
&lt;/code&gt;&lt;/pre&gt;
">[C++项目] Web Server（7）：本地套接字通信</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/7upHwHnyw/"" data-c="
          &lt;p&gt;[C++项目] Web Server（7）：UDP通信&lt;/p&gt;
&lt;h2 id=&#34;udp通信&#34;&gt;UDP通信&lt;/h2&gt;
&lt;h3 id=&#34;数据传输&#34;&gt;数据传输&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
参数:
  - sockfd : 通信的fd
  - buf : 要发送的数据
  - len : 发送数据的长度
  - flags: 0
  - dest_addr : 通信的另外一端的地址信息
  - addrlen : 地址的内存大小

ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen) ;
参数:
  - sockfd : 通信的fd
  - buf : 接收数据的数组
  - len : 数组的大小
  - flags : 0
  - src_addr : 传出参数，用来保存另外一端的地址信息，可以用于判断是否是指定的IP传来的信息，不需要可以指定为NULL
  - addrlen : 地址的内存大小
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;客户端代码&#34;&gt;客户端代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(){
    //创建UDP套接字
    int fd = socket(PF_INET,SOCK_DGRAM,0);

    struct sockaddr_in saddr;
    saddr.sin_port = htons(8888);
    inet_pton(AF_INET,&amp;quot;127.0.0.1&amp;quot;,&amp;amp;saddr.sin_addr.s_addr);
    saddr.sin_family = AF_INET;
    int len = sizeof(saddr);
    int i = 0;
    while (1) {
        char buf[1024] = {0}, rebuf[1024] = {0};
        sprintf(buf,&amp;quot;this is %d&amp;quot;,i++);
        // 发送数据
        sendto(fd,buf,strlen(buf)+1,0,(struct sockaddr*)&amp;amp;saddr,len);

        //接受数据
        recvfrom(fd,rebuf,sizeof(rebuf),0,(struct sockaddr*)&amp;amp;saddr, &amp;amp;len);
        printf(&amp;quot;服务器数据：%s\n&amp;quot;,rebuf);
        sleep(1);
    }

    close(fd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;服务器端代码&#34;&gt;服务器端代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(){
    //创建UDP套接字
    int fd = socket(PF_INET,SOCK_DGRAM,0);

    struct sockaddr_in saddr;
    saddr.sin_port = htons(8888);
    saddr.sin_addr.s_addr = INADDR_ANY;
    saddr.sin_family = AF_INET;

    bind(fd, (struct sockaddr*)&amp;amp;saddr, sizeof(saddr));

    while (1) {
        char buf[1024] = {0};
        struct sockaddr_in caddr;
        int len = sizeof(caddr);

        // 接受数据
        recvfrom(fd, buf, sizeof(buf), 0, (struct sockaddr*)&amp;amp;caddr, &amp;amp;len);

        char address[20];
        printf(&amp;quot;客户端IP：%s， 端口：%d\n&amp;quot;,inet_ntop(AF_INET, &amp;amp;caddr.sin_addr.s_addr,address,sizeof(address)),ntohs(caddr.sin_port));
        printf(&amp;quot;接受数据：%s\n&amp;quot;,buf);

        // 发送数据
        sendto(fd,buf,strlen(buf)+1,0,(struct sockaddr*)&amp;amp;caddr,len);

    }

    close(fd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意 UDP通信不需要额外的操作 比如多线程或者epoll也可以接受多个客户端&lt;/p&gt;
&lt;h2 id=&#34;广播&#34;&gt;广播&lt;/h2&gt;
&lt;p&gt;广播是一种将消息发送给网络中的所有主机的通信方式。它通常使用 UDP（用户数据报协议）来实现，因为 UDP 是一种无连接的协议，可以将数据包发送到广播地址，从而达到广播的效果。&lt;/p&gt;
&lt;p&gt;在 TCP（传输控制协议）通信中，没有直接支持广播的机制。TCP 是一种面向连接的协议，它通过建立可靠的点对点连接来进行通信。每个 TCP 连接都是一个独立的双向通信通道，只有发送方和接收方之间可以进行通信。这种连接的特性使得 TCP 无法直接实现广播。&lt;/p&gt;
&lt;p&gt;如果需要在 TCP 网络中实现广播功能，可以使用其他的机制，例如在应用层上实现自定义的广播协议，或者使用多播（Multicast）来实现类似的功能。多播是一种将数据包发送给一组特定主机的通信方式，可以在 UDP 或 IP 层级上使用。&lt;/p&gt;
&lt;p&gt;在UDP通信中，可以通过设置套接字属性来使用广播。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//设置广播属性的函数
int setsockopt(int sockfd, int level, int optname, const void *optva1, socklen_t optlen) ;
  - sockfd : 文件描述符
  - level : SOL_SOCKET
  - optname : SO_BROADCAST
  - optval : int类型的值，为1表示允许广播
  - optlen : optval的大小
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更详细的对socket属性的设置可以参照&lt;a href=&#34;https://wjcsw.github.io/7A1Qz3b1L&#34;&gt;[C++项目] Web Server（4）：TCP 通信流程与端口复用&lt;/a&gt;中的说明&lt;/p&gt;
&lt;h3 id=&#34;广播的客户端的代码&#34;&gt;广播的客户端的代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(){
    //创建UDP套接字
    int fd = socket(PF_INET,SOCK_DGRAM,0);

    struct sockaddr_in saddr;
    saddr.sin_port = htons(8888);
    saddr.sin_addr.s_addr = INADDR_ANY;
    saddr.sin_family = AF_INET;

    bind(fd,(struct sockaddr*)&amp;amp;saddr,sizeof(saddr));

    int len = sizeof(saddr);
    while (1) {
        char rebuf[1024] = {0};

        //接受数据
        recvfrom(fd,rebuf,sizeof(rebuf), 0, NULL, NULL);
        printf(&amp;quot;服务器数据：%s\n&amp;quot;,rebuf);
    }

    close(fd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;广播的服务器端的代码&#34;&gt;广播的服务器端的代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(){
    //创建UDP套接字
    int fd = socket(PF_INET,SOCK_DGRAM,0);

    // 设置广播属性
    int pval = 1;
    setsockopt(fd,SOL_SOCKET,SO_BROADCAST,&amp;amp;pval,sizeof(pval));

    struct sockaddr_in addr;
    addr.sin_port = htons(8888);
    addr.sin_family = AF_INET;
    inet_pton(AF_INET,&amp;quot;192.168.112.255&amp;quot;,&amp;amp;addr.sin_addr.s_addr);

    // bind(fd, (struct sockaddr*)&amp;amp;addr, sizeof(addr));
    int len = sizeof(addr);
    int i = 1;
    while (1) {
        char buf[1024]= {0};
        sprintf(buf,&amp;quot;this is %d&amp;quot;,i++);
        // 发送数据
        sendto(fd,buf,strlen(buf)+1,0,(struct sockaddr*)&amp;amp;addr,len);
    }

    close(fd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;多播组播&#34;&gt;多播（组播）&lt;/h2&gt;
&lt;p&gt;单播地址标识单个IP接口,广播地址标识某个子网的所有IP接口,多播地址标识一组IP接口。&lt;/p&gt;
&lt;p&gt;单播和广播是寻址方案的两个极端(要么单个要么全部)，多播则意在两者之间提供一种折中方案。&lt;/p&gt;
&lt;p&gt;多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上的接口接收。&lt;/p&gt;
&lt;p&gt;另外,广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网使用。&lt;/p&gt;
&lt;p&gt;客户端需要加入多播组，才能收到多播的数据。&lt;/p&gt;
&lt;h3 id=&#34;多播地址&#34;&gt;多播地址&lt;/h3&gt;
&lt;p&gt;IP多播通信必须依赖于IP多播地址，在IPv4中它的范围从224.0.0.0 到239.255.255.255，并被划分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部链接多播地址&lt;/li&gt;
&lt;li&gt;预留多播地址&lt;/li&gt;
&lt;li&gt;管理权限多播地址&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1689150930905.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;设置多播&#34;&gt;设置多播&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int setsockopt(int sockfd， int level，int optname, const void *optval, socklen_t optlen) ; 
  //服务器设置多播的信息，外出接口
  - leve1 : IPPROTO_IP
  - optname : IP_MULTICAST_IF
  - optval : struct in_ddr
  //客户端加入到多播组:
  - leve1 : IPPROTO_IP
  - optname : IP_ADD_MEMBERSHIP
  - optval : struct ip_mreq


struct ip_mreq
{
  //组播组的IP地址
  struct in_addr imr_multiaddr;

  //本地某一网络设备接口的IP地址
  struct in_addr imr_address;

  int imr_ifindex; // 网卡编号
};

typedef uint32_t in_addr_t;
struct in_addr
{
  in_addr_t s_addr;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;多播客户端代码&#34;&gt;多播客户端代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;

int main(){
    //创建UDP套接字
    int fd = socket(PF_INET,SOCK_DGRAM,0);

    struct sockaddr_in saddr;
    saddr.sin_port = htons(8888);
    saddr.sin_addr.s_addr = INADDR_ANY;
    saddr.sin_family = AF_INET;

    bind(fd,(struct sockaddr*)&amp;amp;saddr,sizeof(saddr));

    // 加入多播组
    struct ip_mreq pval;
    inet_pton(AF_INET,&amp;quot;239.0.0.10&amp;quot;, &amp;amp;pval.imr_multiaddr.s_addr);
    pval.imr_interface.s_addr = INADDR_ANY

    setsockopt(fd,IPPROTO_IP,IP_ADD_MEMBERSHIP,&amp;amp;pval,sizeof(pval));

    int len = sizeof(saddr);
    while (1) {
        char rebuf[1024] = {0};

        //接受数据
        recvfrom(fd,rebuf,sizeof(rebuf), 0, NULL, NULL);
        printf(&amp;quot;服务器数据：%s\n&amp;quot;,rebuf);
    }

    close(fd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;多播服务器代码&#34;&gt;多播服务器代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(){
    //创建UDP套接字
    int fd = socket(PF_INET,SOCK_DGRAM,0);

    // 设置多播属性
    struct in_addr pval;
    inet_pton(AF_INET,&amp;quot;239.0.0.10&amp;quot;,&amp;amp;pval.s_addr);
    setsockopt(fd,IPPROTO_IP,IP_MULTICAST_IF,&amp;amp;pval,sizeof(pval));
    
    // 初始化客户端地址
    struct sockaddr_in addr;
    addr.sin_port = htons(8888);
    addr.sin_family = AF_INET;
    inet_pton(AF_INET,&amp;quot;239.0.0.10&amp;quot;,&amp;amp;addr.sin_addr.s_addr);

    // bind(fd, (struct sockaddr*)&amp;amp;addr, sizeof(addr));
    int len = sizeof(addr);
    int i = 1;
    while (1) {
        char buf[1024]= {0};
        sprintf(buf,&amp;quot;多播：this is %d&amp;quot;,i++);
        // 发送数据
        sendto(fd,buf,strlen(buf)+1,0,(struct sockaddr*)&amp;amp;addr,len);
        sleep(1);
    }

    close(fd);
}
&lt;/code&gt;&lt;/pre&gt;
">[C++项目] Web Server（7）：UDP通信，广播和多播</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/KrVUX1hk6/"" data-c="
          &lt;p&gt;&lt;code&gt;poll&lt;/code&gt;虽然对&lt;code&gt;selcet&lt;/code&gt;的部分缺陷做出了改进:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取消了文件描述符fd的最大数量限制&lt;/li&gt;
&lt;li&gt;fd集合不能重用的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是依然有着共同的缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次调用时都需要将fd集合从用户态拷贝至内核态&lt;/li&gt;
&lt;li&gt;内核态每次需要主动遍历集合所有fd才能知道需要检测哪些文件&lt;/li&gt;
&lt;li&gt;返回时无法得知具体是哪几个fd收到了数据，每次也都需要遍历集合中所有的fd&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;epoll&lt;/code&gt;则进一步解决了这些缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它直接在内核中构造结构体用于存储fd集合，省去了每次的拷贝&lt;/li&gt;
&lt;li&gt;它不再使用线性的数组方式储存fd，而是采用了红黑树成员&lt;code&gt;rbr&lt;/code&gt;来储存，红黑树节点上注册有回调函数，事件到来后执行回调函数&lt;/li&gt;
&lt;li&gt;将返回的结果存放在双向链表成员&lt;code&gt;rd_list&lt;/code&gt;中，从而使得用户可以直接得到获得数据的文件而无需遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关键api&#34;&gt;关键API&lt;/h2&gt;
&lt;h3 id=&#34;创建epoll实例&#34;&gt;创建epoll实例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;sys/epoll.h&amp;gt;
// 创建一个新的epoll实例。在内核中创建了一个结构体类型的数据
// 这个结构体中有两个比较重要的数据，一个是需要检测的文件描述符的信息(红黑树)
// 还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息(双向链表)。
int epoll_create(int size);
  - 参数:
    size : 目前没有意义了。随便写一个数，必须大于0
  - 返回值:
    -1 : 失败
    &amp;gt;0 : 文件描述符，用于操作epoll实例
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;epoll实例管理&#34;&gt;epoll实例管理&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef union epoll_data {
  void *ptr;
  int fd;
  uint32_t u32;
  uint64_t u64;
} epoll_data_t;

struct epoll_event {
  uint32_t events ;  /* Epoll events */
  epoll_data_t data; /* User data variable */
};

常见的Epoll events:
  - EPOLLIN
  - EPOLLOUT
  - EPOLLERR
  - EPOLLET //设置为ET模式

//对epoll实例进行管理:添加文件描述符信息，删除信息，修改信息
int epoll_ctl(int epfd， int op，int fd， struct epoll_event *event) ;
- 参数:
  - epfd: epoll实例对应的文件描述符
  - op: 要进行什么操作
    - EPOLL_CTL_ADD: 添加
    - EPOLL_CTL_MOD: 修改
    - EPOLL_CTL_DEL:删除
  - fd: 要检测的文件描述符
  - event: 检测文件描述符什么事情
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;检测epoll&#34;&gt;检测epoll&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 检测函数
int epoll_wait(int epfd， struct epoll_event *events， int maxevents， int timeout);
- 参数:
  - epfd : epoll实例对应的文件描述符
  - events : 传出参数，保存了发送了变化的文件描述符的信息
  - maxevents : 第二个参数结构体数组的大小
  - timeout : 阻塞时间
    - 0: 不阻塞
    - -1 : 阻塞，直到检测到fd数据发生变化，解除阻塞
    - &amp;gt; 0: 阻塞的时长(毫秒)

- 返回值:
  - 成功，返回发送变化的文件描述符的个数&amp;gt; 0
  - 失败-1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;epoll的工作模式&#34;&gt;epoll的工作模式&lt;/h2&gt;
&lt;p&gt;工作模式是通过epoll event来进行设置的，见上述对于epoll event的介绍&lt;/p&gt;
&lt;h3 id=&#34;lt模式水平触发&#34;&gt;LT模式(水平触发)&lt;/h3&gt;
&lt;p&gt;LT (level-triggered)是缺省的工作方式，并且同时支持block和no-block socket。&lt;/p&gt;
&lt;p&gt;在这种做法中,内核告诉你一个文件描述符是否就绪了 ，然后你可以对这个就绪的fd进行IO操作。&lt;/p&gt;
&lt;p&gt;如果你不对该文件描述作任何操作，或是未完全读完，即只要读缓冲区还有数据，内核还是会在下一次调用时继续通知你。&lt;/p&gt;
&lt;h4 id=&#34;lt模式举例&#34;&gt;LT模式举例&lt;/h4&gt;
&lt;p&gt;假设委托内核检测读事件 -&amp;gt; 则内核检测fd的读缓冲区&lt;br&gt;
读缓冲区有数据 -&amp;gt; &lt;code&gt;epoll&lt;/code&gt;检测到了会给用户通知&lt;br&gt;
a. 用户不读数据，数据一直在缓冲区，&lt;code&gt;epoll&lt;/code&gt;会一直通知&lt;br&gt;
b. 用户只读了一部分数据，&lt;code&gt;epoll&lt;/code&gt;会通知&lt;br&gt;
C. 缓冲区的数据读完了，不通知&lt;/p&gt;
&lt;h3 id=&#34;et模式边沿触发&#34;&gt;ET模式(边沿触发)&lt;/h3&gt;
&lt;p&gt;ET (edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。&lt;/p&gt;
&lt;p&gt;然后它会假设你知道文件描述符已经就绪,并且&lt;strong&gt;不会再为那个文件描述符发送更多的就绪通知&lt;/strong&gt;，直到你做了某些操作导致那个文件描述符不再为就绪状态了。&lt;/p&gt;
&lt;p&gt;但是请注意,如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。&lt;/p&gt;
&lt;p&gt;ET模式在很大程度上减少了&lt;code&gt;epoll&lt;/code&gt; 事件被重复触发的次数，因此效率要比LT模式高。&lt;/p&gt;
&lt;p&gt;但是 &lt;code&gt;epoll&lt;/code&gt; 工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。这是由于在该模式下读取数据时必须读完每个文件的数据，因为内核不会再次通知。而读操作如果不设置未未阻塞，则会导致其他任务无法运行。&lt;/p&gt;
&lt;h4 id=&#34;et模式举例&#34;&gt;ET模式举例&lt;/h4&gt;
&lt;p&gt;假设委托内核检测读事件 -&amp;gt; 则内核检测fd的读缓冲区&lt;br&gt;
读缓冲区有数据 -&amp;gt; &lt;code&gt;epoll&lt;/code&gt;检测到了会给用户通知&lt;br&gt;
a.用户不读数据，数据一致在缓冲区中，&lt;code&gt;epoll&lt;/code&gt;下次检测的时候就不通知了&lt;br&gt;
b.用户只读了一部分数据，&lt;code&gt;epoll&lt;/code&gt;不通知&lt;br&gt;
C.缓冲区的数据读完了，不通知&lt;/p&gt;
&lt;h4 id=&#34;epolloneshot事件&#34;&gt;EPOLLONESHOT事件&lt;/h4&gt;
&lt;p&gt;即使可以使用ET模式，一个socket上的某个事件还是可能被触发多次。&lt;/p&gt;
&lt;p&gt;比如一个线程在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读 (&lt;code&gt;EPOLLIN&lt;/code&gt;再次被触发)，此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个socket的局面。&lt;/p&gt;
&lt;p&gt;一个socket连接在任一时刻都只被一个线程处理， 可以使用&lt;code&gt;epoll&lt;/code&gt;的&lt;code&gt;EPOLLONESHOT&lt;/code&gt;事件实现。&lt;/p&gt;
&lt;p&gt;对于注册了&lt;code&gt;EPOLLONESHOT&lt;/code&gt;事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用&lt;code&gt;epoll_ctl&lt;/code&gt;函数重置该文件描述符上注册的&lt;code&gt;EPOLLONESHOT&lt;/code&gt;事件。&lt;/p&gt;
&lt;p&gt;这样，当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。&lt;/p&gt;
&lt;p&gt;但反过来思考，注册了&lt;code&gt;EPOLLONESHOT&lt;/code&gt;事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的&lt;code&gt;EPOLLONESHOT&lt;/code&gt;事件，以确保这个socket下一次可读时，其&lt;code&gt;EPOLLIN&lt;/code&gt;事件能被触发，进而让其他工作线程有机会继续处理这个socket。&lt;/p&gt;
&lt;h2 id=&#34;服务器端代码&#34;&gt;服务器端代码&lt;/h2&gt;
&lt;h3 id=&#34;lt-模式&#34;&gt;LT 模式&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/epoll.h&amp;gt;

int main(){
    int lfd = socket(PF_INET,SOCK_STREAM,0);

    struct sockaddr_in saddr;
    saddr.sin_port = htons(9999);
    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = INADDR_ANY;

    bind(lfd,(struct sockaddr *)&amp;amp;saddr,sizeof(saddr));

    listen(lfd, 8);

    // 创建epoll实例
    int epfd = epoll_create(100);

    // 创建检测事件
    struct epoll_event e;
    e.data.fd = lfd;
    e.events = EPOLLIN;

    // 设置检测文件
    epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;amp;e);

    struct epoll_event revents[1024];
    while (1)
    {
        int ret = epoll_wait(epfd,revents,1024,-1);
        if(ret==-1){
            perror(&amp;quot;select&amp;quot;);
            exit(-1);
        }
        else if(ret==0) continue;
        else if(ret&amp;gt;0){
            for(int i =0;i&amp;lt;ret;i++){
                if(revents[i].data.fd == lfd){
                    struct sockaddr_in caddr;
                    int len = sizeof(caddr);
                    int cfd = accept(lfd,(struct sockaddr *)&amp;amp;caddr, &amp;amp;len);

                    e.data.fd = cfd;
                    e.events = EPOLLIN | EPOLLOUT;  //同时关注读写事件
                    epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;amp;e);
                }
                else {
                    if(revents[i].events &amp;amp; EPOLLIN){
                       char buf[5] = {0};
                        int len = read(revents[i].data.fd,buf,sizeof(buf));
                        if(len==-1){
                            perror(&amp;quot;read&amp;quot;);
                            exit(-1);
                        }
                        else if(len==0){
                            printf(&amp;quot;客户端 %d 关闭\n&amp;quot;,revents[i].data.fd);
                            close(revents[i].data.fd);
                            epoll_ctl(epfd,EPOLL_CTL_DEL,revents[i].data.fd,NULL);
                        }
                        else if(len&amp;gt;0){
                            printf(&amp;quot;读取数据：%s\n&amp;quot;,buf);
                            write(revents[i].data.fd,buf,strlen(buf)+1);
                        } 
                    }
                    else if(revents[i].events &amp;amp; EPOLLOUT){
                        continue;
                    }
                }
            }
        }
        
    }
    close(lfd);
    close(epfd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种情况下，每次未读取完的数据仍旧会通知用户，每次接着读取，因此可以作用于阻塞的套接字&lt;/p&gt;
&lt;h3 id=&#34;et模式&#34;&gt;ET模式&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/epoll.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;

int main(){
    int lfd = socket(PF_INET,SOCK_STREAM,0);

    struct sockaddr_in saddr;
    saddr.sin_port = htons(9999);
    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = INADDR_ANY;

    bind(lfd,(struct sockaddr *)&amp;amp;saddr,sizeof(saddr));

    listen(lfd, 8);

    // 创建epoll实例
    int epfd = epoll_create(100);

    // 创建检测事件
    struct epoll_event e;
    e.data.fd = lfd;
    e.events = EPOLLIN;

    // 设置检测文件
    epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;amp;e);

    struct epoll_event revents[1024];
    while (1)
    {
        int ret = epoll_wait(epfd,revents,1024,-1);
        if(ret==-1){
            perror(&amp;quot;select&amp;quot;);
            exit(-1);
        }
        else if(ret==0) continue;
        else if(ret&amp;gt;0){
            for(int i =0;i&amp;lt;ret;i++){
                if(revents[i].data.fd == lfd){
                    struct sockaddr_in caddr;
                    int len = sizeof(caddr);
                    int cfd = accept(lfd,(struct sockaddr *)&amp;amp;caddr, &amp;amp;len);

                    //设置文件描述符非阻塞
                    int flag = fcntl(cfd,F_GETFL);
                    flag |= O_NONBLOCK;
                    fcntl(cfd,F_SETFL,flag);

                    e.data.fd = cfd;
                    e.events = EPOLLIN | EPOLLET;  // 设置为边沿触发 ET模式
                    epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;amp;e);
                }
                else {
                    if(revents[i].events &amp;amp; EPOLLIN){

                        // 循环读取出所有数据
                        char buf[5] = {0};
                        int len = 0;
                        while ((len = read(revents[i].data.fd,buf,sizeof(buf)))&amp;gt;0)
                        {
                            printf(&amp;quot;读取数据：%s\n&amp;quot;,buf);
                            write(revents[i].data.fd,buf,strlen(buf)+1);
                        }
                        if(len==-1){
                            // 非阻塞模式下 读取完所有数据后也会返回-1 此时错误号为EAGAIN
                            if(errno == EAGAIN){
                                printf(&amp;quot;data over\n&amp;quot;);
                            }
                            else{
                                perror(&amp;quot;read&amp;quot;);
                                exit(-1);
                            }
                            
                        }
                        else if(len==0){
                            printf(&amp;quot;客户端 %d 关闭\n&amp;quot;,revents[i].data.fd);
                            close(revents[i].data.fd);
                            epoll_ctl(epfd,EPOLL_CTL_DEL,revents[i].data.fd,NULL);
                        }
                    }
                    else if(revents[i].events &amp;amp; EPOLLOUT){
                        continue;
                    }
                }
            }
        }
        
    }
    close(lfd);
    close(epfd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先为文件描述符设置阻塞属性，然后将检测事件设置为ET模式&lt;/p&gt;
&lt;p&gt;读取时循环读取文件中的所有数据&lt;/p&gt;
">[C++项目] Web Server（6）：epoll 实现 I/O 多路复用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/Gk09nSzLE/"" data-c="
          &lt;p&gt;I/O 多路复用（也叫I/O 多路转接）使得程序能同时监听多个文件描述符，能够提高程序的性能，Linux 下实现 I/O 多路复用的系统调用主要有 &lt;code&gt;select&lt;/code&gt;、&lt;code&gt;poll&lt;/code&gt; 和 &lt;code&gt;epoll&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;常见的io模型&#34;&gt;常见的I/O模型&lt;/h2&gt;
&lt;p&gt;计算机中的I/O指的是输入（Input）与输出（Output）&lt;/p&gt;
&lt;p&gt;Input：将文件中的内容写入到内存中&lt;/p&gt;
&lt;p&gt;Output：将内存中的内容写入到文件中&lt;/p&gt;
&lt;h3 id=&#34;阻塞-io-bio&#34;&gt;阻塞 I/O （BIO）&lt;/h3&gt;
&lt;p&gt;阻塞 I/O 是最常见的 I/O 模型之一，它的特点是在阻塞 I/O 模型中，&lt;strong&gt;应用程序会一直阻塞在 I/O 操作上，直到数据准备好或超时&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;阻塞 I/O 模型的优点是简单易用，不占用CPU宝贵的时间片，适用于处理低并发量的应用程序。但是，它的缺点是同一时刻只能处理一个操作，效率低下，因为在等待 I/O 操作完成时，CPU 会一直处于空闲状态，无法处理其他任务。&lt;/p&gt;
&lt;p&gt;常见的BIO模型方法是&lt;strong&gt;通过多线程或多进程去处理客户端请求，每个线程/进程对应一个客户端&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点是可以并发处理客户端请求&lt;/li&gt;
&lt;li&gt;缺点是线程/进程本身会消耗系统资源，调度也需要额外的资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;非阻塞-ionio&#34;&gt;非阻塞 I/O（NIO）&lt;/h3&gt;
&lt;p&gt;非阻塞 I/O 是一种改进的 I/O 模型，它的特点是在进行 I/O 操作时不会阻塞应用程序，而是立即返回。在非阻塞 I/O 模型中，&lt;strong&gt;应用程序需要不断地轮询 I/O 操作的状态，直到数据准备好或发生错误&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;每次循环内的复杂度是O(n)，n为连接的客户端数，因为每次循环都得遍历所有客户端的连接以读取可能发送的数据，而事实上并不是每次循环都有数据到达。&lt;/p&gt;
&lt;p&gt;非阻塞 I/O 模型的优点是效率高，因为应用程序可以在等待 I/O 操作完成时处理其他任务。但是，它的缺点是编程复杂度高，需要不断地轮询 I/O 操作的状态，会增加代码的复杂度和维护成本。&lt;/p&gt;
&lt;h3 id=&#34;io-多路复用&#34;&gt;I/O 多路复用&lt;/h3&gt;
&lt;p&gt;I/O 多路复用是一种高效的 I/O 模型，它的特点是可以同时监视多个 I/O 操作的状态，当有数据准备好时立即返回。在 I/O 多路复用模型中，应用程序可以使用 &lt;code&gt;select()&lt;/code&gt;、&lt;code&gt;poll()&lt;/code&gt; 或 &lt;code&gt;epoll()&lt;/code&gt; 等系统调用来同时监视多个 I/O 操作的状态。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;select()&lt;/code&gt;/&lt;code&gt;poll()&lt;/code&gt;调用让应用程序可以将数据监测委托给内核，从而高效率地处理I/O操作。但是select调用只会通知有几个文件获得了数据，但具体是哪几个，还需要程序自己遍历二进制查找。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;epoll()&lt;/code&gt; 系统调用则会直接通知具体是哪几个文件获得了数据&lt;/p&gt;
&lt;p&gt;通过这些系统调用，可以将多个IO操作委托给内核，应用程序只需一次系统调用即可完成对多个IO操作的执行。&lt;/p&gt;
&lt;p&gt;I/O 多路复用模型的优点是效率高，可以同时处理多个 I/O 操作，避免了轮询的开销。但是，它的缺点是编程复杂度高，需要使用系统调用来实现，代码的复杂度和维护成本都比较高。&lt;/p&gt;
&lt;h3 id=&#34;异步-io&#34;&gt;异步 I/O&lt;/h3&gt;
&lt;p&gt;异步 I/O 是一种高级的 I/O 模型，它的特点是在进行 I/O 操作时不会阻塞应用程序，而是立即返回，并在操作完成后通知应用程序。在异步 I/O 模型中，应用程序需要使用 aio_read()、aio_write() 等系统调用来发起异步 I/O 操作，并使用回调函数来处理操作完成后的数据。&lt;/p&gt;
&lt;p&gt;异步 I/O 模型的优点是效率高，可以在不阻塞应用程序的情况下进行 I/O 操作，避免了轮询和阻塞的开销。但是，它的缺点是编程复杂度非常高，需要使用系统调用和回调函数来实现，代码的复杂度和维护成本都非常高。&lt;/p&gt;
&lt;h2 id=&#34;select&#34;&gt;select&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;select&lt;/code&gt;的流程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先要构造一个关于文件描述符的列表,将要监听的文件描述符添加到该列表中。&lt;/li&gt;
&lt;li&gt;调用一个系统函数,监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I/O操作时，该函数才返回。&lt;br&gt;
a. 这个函数是阻塞&lt;br&gt;
b. 函数对文件描述符的检测的操作是由内核完成的&lt;/li&gt;
&lt;li&gt;在返回时，它会告诉进程有多少(哪些)描述符要进行I/O操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;关键api&#34;&gt;关键API&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;sys/select.h&amp;gt;
int select(int nfds，fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout) ;
- 参数:
  - nfds : 委托内核检测的最大文件描述符的值 + 1
  - readfds : 要检测的文件描述符的读的集合,委托内核检测哪些文件描述符的读的属性
    - 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区
    - 是一个传入传出参数
    - fd_set 本质上是个长为128的long int数组，表示1024个bit位
  - writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性
    - 委托内核检测写缓冲区是不是还可以写数据(不满的就可以写)
  - exceptfds : 检测发生异常的文件描述符的集合
  - timeout : 设置的超时时间
    struct timeval {
      long tv_sec; /* seconds */
      long tv_usec; /* microseconds*/
    };
    - NULL :永久阻塞，直到检测到了文件描述符有变化
    - tv_sec=0  tv_usec=0，不阻塞
    - tv_sec &amp;gt; 0 tv_usec &amp;gt; 0，阻塞对应的时间

-返回值为一个整数n:
  - n = -1 : 失败
  - n &amp;gt; 0 : 检测的集合中有 n 个文件描述符发生了变化
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里都是对文件描述符的集合进行操作，而这些集合是用二进制位表示的，下面介绍对文件描述符的集合进行操作的函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//将参数文件描述符fd对应的标志位设置为0
void FD_CLR(int fd, fd_set *set);

//判断fd对应的标志位是0还是1，返回值: fd对应的标志位的值
int FD_ISSET(int fd, fd_set *set);

//将参数文件描述符fd对应的标志位，设置为1
void FD_SET(int fd, fd_set *set);

// fd_set一共有1024 bit，全部初始化为0
void FD_ZERO(fd_set *set) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;举例解释&#34;&gt;举例解释&lt;/h3&gt;
&lt;p&gt;假设客户端A,B,C,D连接到服务器分别对应文件描述符3, 4, 100, 101&lt;/p&gt;
&lt;p&gt;对应的我们设置对应的文件描述符集合位，接着调用&lt;code&gt;select&lt;/code&gt;检测是否有数据发送&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;fd_set reads;
FD_SET(3, &amp;amp;reads);
FD_SET(4, &amp;amp;reads);
FD_SET(100, &amp;amp;reads);
FD_SET(101, &amp;amp;reads);
select(101+1,&amp;amp;reads,NULL,NULL,NULL);

遍历每个需要的文件标志位，使用FD_ISSET判断对应文件位是否有数据
有的话则读取数据

遍历完成，在下一次检测之前，使用FD_ZERO将所有位置为0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;select&lt;/code&gt;执行的过程中，将&lt;code&gt;reads&lt;/code&gt;拷贝到内核态，处理完成后将结果又从内核态拷贝到&lt;code&gt;reads&lt;/code&gt;中&lt;/p&gt;
&lt;p&gt;返回的结果保存在传入变量&lt;code&gt;reads&lt;/code&gt;中，其中若该位被置为1则表示有数据，若为0则表示没有数据。&lt;/p&gt;
&lt;h3 id=&#34;服务器端代码&#34;&gt;服务器端代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/select.h&amp;gt;

int main(){
    int lfd = socket(PF_INET,SOCK_STREAM,0);

    struct sockaddr_in saddr;
    saddr.sin_port = htons(9999);
    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = INADDR_ANY;

    bind(lfd,(struct sockaddr *)&amp;amp;saddr,sizeof(saddr));

    listen(lfd, 8);

    fd_set rdset, tmp;
    FD_ZERO(&amp;amp;rdset);
    FD_SET(lfd,&amp;amp;rdset);

    int maxfd = lfd;
    while(1){
        tmp = rdset;
        int ret = select(maxfd+1,&amp;amp;tmp,NULL,NULL,NULL);
        if(ret==-1){
            perror(&amp;quot;select&amp;quot;);
            exit(-1);
        }
        else if(ret==0) continue;
        else if(ret&amp;gt;0){
            if(FD_ISSET(lfd,&amp;amp;tmp)){
                //表示有新的客户端连接进来
                struct sockaddr_in caddr;
                int len = sizeof(caddr);
                int cfd = accept(lfd,(struct sockaddr *)&amp;amp;caddr, &amp;amp;len);
                FD_SET(cfd,&amp;amp;rdset);
                maxfd = maxfd&amp;gt;cfd?maxfd:cfd;
            }
            
            for(int i = lfd+1;i&amp;lt;=maxfd;i++){
                if(FD_ISSET(i,&amp;amp;tmp)){
                    char buf[1024] = {0};
                    int len = read(i,buf,sizeof(buf));
                    if(len==-1){
                        perror(&amp;quot;read&amp;quot;);
                        exit(-1);
                    }
                    else if(len==0){
                        printf(&amp;quot;客户端%d关闭\n&amp;quot;,i);
                        FD_CLR(i,&amp;amp;rdset);
                        close(i);
                    }
                    else if(len&amp;gt;0){
                        printf(&amp;quot;读取数据：%s\n&amp;quot;,buf);
                        write(i,buf,strlen(buf)+1);
                    }
                }
            }
        }
    }

    close(lfd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;select&lt;/code&gt; 缺点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次调用&lt;code&gt;select&lt;/code&gt;， 都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时&lt;br&gt;
会很大&lt;/li&gt;
&lt;li&gt;同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时&lt;br&gt;
也很大&lt;/li&gt;
&lt;li&gt;select支持的文件描述符数量太小了，默认是1024&lt;/li&gt;
&lt;li&gt;fds集合不能重用，每次都需要重置&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;poll&#34;&gt;poll&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;poll&lt;/code&gt;是对&lt;code&gt;select&lt;/code&gt;的一个改进，主要区别在于将fd集合封装成一个结构体，从而使得集合可以被重用，并且也没有大小限制了&lt;/p&gt;
&lt;h3 id=&#34;关键api-2&#34;&gt;关键API&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;poll.h&amp;gt;
struct pollfd {
  int fd; /*委托内核检测的文件描述符*/
  short events; /*委托内核检测文件描述符的什么事件 */
  short revents ; /*文件描述符实际发生的事件，即返回的结果*/
};

int poll(struct pollfd *fds, nfds_t nfds, int timeout);
- 参数:
  - fds : 是一个struct pollfd 结构体数组，这是一个需要检测的文件描述符的集合
  - nfds : 这个是第一个参数数组中最后一个有效元素的下标+ 1
  - timeout : 阻塞时长
     0 : 不阻塞
    -1 : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞
    &amp;gt;0 : 阻塞的时长
- 返回值为n:
  -1 : 失败
  &amp;gt;0 : 成功，, n表示检测到集合中有n个文件描述符发生变化
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;events&lt;/code&gt;的取值如下：&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1689077282726.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果要同时检测多个事件 使用 &lt;code&gt;|&lt;/code&gt; 连接&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct pollfd myfd;
myfd.fd = 5;
myfd.events = POLLIN | POLLOUT;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;服务器端代码-2&#34;&gt;服务器端代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;poll.h&amp;gt;

int main(){
    int lfd = socket(PF_INET,SOCK_STREAM,0);

    struct sockaddr_in saddr;
    saddr.sin_port = htons(9999);
    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = INADDR_ANY;

    bind(lfd,(struct sockaddr *)&amp;amp;saddr,sizeof(saddr));

    listen(lfd, 8);

    struct pollfd fds[1024];
    for(int i=0;i&amp;lt;1024;i++){
        fds[i].fd = -1; //初始化为-1表示未打开状态
        fds[i].events = POLLIN; //初始化检测读事件，即有数据到达读缓冲区
    }
    fds[0].fd = lfd;
    int nfds = 1;
    while(1){
        //调用poll函数 检测描述符集合
        int ret = poll(fds,nfds,-1);
        if(ret==-1){
            perror(&amp;quot;select&amp;quot;);
            exit(-1);
        }
        else if(ret==0) continue;
        else if(ret&amp;gt;0){
            if(fds[0].revents &amp;amp; POLLIN){
                //表示有新的客户端连接进来
                struct sockaddr_in caddr;
                int len = sizeof(caddr);
                int cfd = accept(lfd,(struct sockaddr *)&amp;amp;caddr, &amp;amp;len);
                
                for(int i=1;i&amp;lt;1024;i++){
                    if(fds[i].fd==-1){
                        fds[i].fd = cfd;
                        fds[i].events = POLLIN;
                        if(nfds&amp;lt;i+1) nfds = i+1;
                        break;
                    }
                }
            }
            
            for(int i = 1;i&amp;lt;nfds;i++){
                if(fds[i].revents &amp;amp; POLLIN){
                    char buf[1024] = {0};
                    int len = read(fds[i].fd,buf,sizeof(buf));
                    if(len==-1){
                        perror(&amp;quot;read&amp;quot;);
                        exit(-1);
                    }
                    else if(len==0){
                        printf(&amp;quot;客户端关闭\n&amp;quot;);
                        close(fds[i].fd);
                        fds[i].fd = -1;
                    }
                    else if(len&amp;gt;0){
                        printf(&amp;quot;读取数据：%s\n&amp;quot;,buf);
                        write(fds[i].fd,buf,strlen(buf)+1);
                    }
                }
            }
        }
    }
    close(lfd);
}
&lt;/code&gt;&lt;/pre&gt;
">[C++项目] Web Server（5）：I/O 多路复用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/7A1Qz3b1L/"" data-c="
          &lt;p&gt;如何理解之前博客中的服务器和客户端的通信流程，这里以具体函数来解释整个通信过程中的状态转换&lt;/p&gt;
&lt;h2 id=&#34;三次握手与四次挥手&#34;&gt;三次握手与四次挥手&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1689061108702.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;建立连接&#34;&gt;建立连接&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1689061114316.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先服务器通过&lt;code&gt;listen&lt;/code&gt;函数进入&lt;code&gt;LISTEN&lt;/code&gt;状态&lt;/p&gt;
&lt;p&gt;接着客户端通过&lt;code&gt;connect&lt;/code&gt;函数发起连接，客户端进入&lt;code&gt;SYN_SENT&lt;/code&gt;状态&lt;/p&gt;
&lt;p&gt;服务器收到连接请求后，回复一个&lt;code&gt;ACK&lt;/code&gt;进入&lt;code&gt;SYN_RCVD&lt;/code&gt;状态&lt;/p&gt;
&lt;p&gt;客户收到服务器回复的&lt;code&gt;ACK&lt;/code&gt;后，对该&lt;code&gt;ACK&lt;/code&gt;回复一个&lt;code&gt;ACK&lt;/code&gt;，进入&lt;code&gt;ESTABLISHED&lt;/code&gt;状态&lt;/p&gt;
&lt;p&gt;服务器收到客户端回的&lt;code&gt;ACK&lt;/code&gt;后也进入&lt;code&gt;ESTABLISHED&lt;/code&gt;状态&lt;/p&gt;
&lt;p&gt;三次握手完成，连接建立成功&lt;/p&gt;
&lt;h3 id=&#34;数据传输&#34;&gt;数据传输&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1689061119570.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
连接建立完成后就可以进行客户端与服务器端的通信&lt;/p&gt;
&lt;p&gt;在之前的TCP通信实例中，就是客户端通过&lt;code&gt;write&lt;/code&gt;发送数据，服务器端通过&lt;code&gt;read&lt;/code&gt;读取数据&lt;/p&gt;
&lt;h3 id=&#34;断开连接&#34;&gt;断开连接&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1689061123357.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先客户端或服务器端任意一方都可以主动使用&lt;code&gt;close&lt;/code&gt;函数发起断开连接的请求，进入&lt;code&gt;FIN_WAIT_1&lt;/code&gt;状态&lt;/p&gt;
&lt;p&gt;另一方收到请求后回复&lt;code&gt;ACK&lt;/code&gt;并进入&lt;code&gt;CLOSE_WAIT&lt;/code&gt;状态&lt;/p&gt;
&lt;p&gt;主动断链方收到&lt;code&gt;ACK&lt;/code&gt;后进入&lt;code&gt;FIN_WAIT_2&lt;/code&gt;状态，等待被动方处理完成发送断链请求&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此时主动断链方进入&lt;strong&gt;半关闭&lt;/strong&gt;状态直至收到被动方的&lt;code&gt;FIN&lt;/code&gt;请求，此时主动断链方仍旧可以接受数据，但是不能发送数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;从程序的角度，可以使用API来控制实现半关闭/半连接状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;sys/socket.h&amp;gt;
int shutdown(int sockfd, int how);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sockfd&lt;/code&gt;:需要关闭的socket的描述符&lt;br&gt;
&lt;code&gt;how&lt;/code&gt;: 允许为&lt;code&gt;shutdown&lt;/code&gt;操作选择以下几种方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SHUT_RD&lt;/code&gt;(0):关闭&lt;code&gt;sockfd&lt;/code&gt;上的读功能，此选项将不允许&lt;code&gt;sockfd&lt;/code&gt;进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SHUT_WR&lt;/code&gt;(1): 关闭&lt;code&gt;sockfd&lt;/code&gt;的写功能，此选项将不允许&lt;code&gt;sockfd&lt;/code&gt;进行写操作。进程不能在对此套接字发出写操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SHUT_RDWR&lt;/code&gt;(2):关闭sockfd的读写功能。相当于调用&lt;code&gt;shutdown&lt;/code&gt;两次:首先是以&lt;code&gt;SHUT_RD&lt;/code&gt;，然后以&lt;code&gt;SHUT_WR&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用&lt;code&gt;close&lt;/code&gt;中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。&lt;code&gt;shutdown&lt;/code&gt; 不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。&lt;/p&gt;
&lt;p&gt;被动方处理完断链前的操作后，主动通过&lt;code&gt;close&lt;/code&gt;函数发送断链请求，进入&lt;code&gt;LASK_ACK&lt;/code&gt;状态&lt;/p&gt;
&lt;p&gt;主动断链方收到请求后，回复&lt;code&gt;ACK&lt;/code&gt;，进入&lt;code&gt;TIME_WAIT&lt;/code&gt;状态，在等待一个固定的时间（两倍报文段寿命，&lt;code&gt;2MSL&lt;/code&gt;）后自动进入&lt;code&gt;CLOSE&lt;/code&gt;状态&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里等待的原因是为了保证最后这个&lt;code&gt;ACK&lt;/code&gt;丢失后，可以收到被动方的重发请求，重发&lt;code&gt;ACK&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;被动断链方收到&lt;code&gt;ACK&lt;/code&gt;后，进入&lt;code&gt;CLOSE&lt;/code&gt;状态&lt;/p&gt;
&lt;p&gt;四次挥手完成，连接断开成功&lt;/p&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果有多个进程共享一个套接字，&lt;code&gt;close&lt;/code&gt; 每被调用1次，计数减1，直到计数为0时，也就是所用进程都调用了&lt;code&gt;close&lt;/code&gt;,套接字将被释放。&lt;/li&gt;
&lt;li&gt;在多进程中如果一个进程调用了&lt;code&gt;shutdown(sfd, SHUT_RDWR)&lt;/code&gt;后，其它的进程将无法进行通信。但如果一个进程&lt;code&gt;close(sfd)&lt;/code&gt;将不会影响到其它进程。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据传输-2&#34;&gt;数据传输&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;read&lt;/code&gt;和&lt;code&gt;write&lt;/code&gt;是linux系统对文件的读取操作，只不过在linux中万物皆文件，因此也可以用于socket通信&lt;/p&gt;
&lt;p&gt;但是socket通信还有自己专门的通信函数：&lt;code&gt;recv&lt;/code&gt;，&lt;code&gt;send&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;接受数据&#34;&gt;接受数据&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

ssize_t recv(int sockfd, void *buf, size_t len, int flags);

ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);

ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;recv()&lt;/code&gt;、&lt;code&gt;recvfrom()&lt;/code&gt;和&lt;code&gt;recvmsg()&lt;/code&gt;调用用于从套接字接收消息。 它们可用于接收无连接套接字和面向连接套接字上的数据。&lt;/p&gt;
&lt;p&gt;这三个调用在成功完成后都会返回报文的长度。如果消息太长，无法在提供的缓冲区中容纳，多余的字节可能会被丢弃，这取决于接收消息的套接字类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;recv()&lt;/code&gt; 函数只能用于从已连接的套接字（socket）接收数据。&lt;/p&gt;
&lt;p&gt;如果在套接字上没有可用的消息，接收调用将等待消息的到来，除非套接字是非阻塞的，在这种情况下返回值为-1，并且外部变量&lt;code&gt;errno&lt;/code&gt;被设置为&lt;code&gt;EAGAIN&lt;/code&gt;或&lt;code&gt;EWOULDBLOCK&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接收调用通常立刻返回任何可用的数据，直到达到请求的数量，而不是一直等待收到所请求的全部数据再一次性返回。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;recv&lt;/code&gt; 参数说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sockfd&lt;/code&gt;：表示已连接的套接字的文件描述符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buf&lt;/code&gt;：指向接收数据的缓冲区的指针。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len&lt;/code&gt;：表示接收缓冲区的大小。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flags&lt;/code&gt;：用于指定接收操作的可选标志，如 &lt;code&gt;MSG_DONTWAIT&lt;/code&gt;、&lt;code&gt;MSG_WAITALL&lt;/code&gt; 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;recv()&lt;/code&gt; 函数是一个阻塞函数，如果没有数据可接收，它会一直等待，直到有数据到达或发生错误。如果你希望在接收数据时设置超时或非阻塞模式，可以使用 &lt;code&gt;select() &lt;/code&gt;或 &lt;code&gt;fcntl()&lt;/code&gt; 函数来实现。&lt;/p&gt;
&lt;h3 id=&#34;发送数据&#34;&gt;发送数据&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

ssize_t send(int sockfd, const void *buf, size_t len, int flags);

ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);

ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;系统调用&lt;code&gt;send()&lt;/code&gt;、&lt;code&gt;sendto()&lt;/code&gt;和&lt;code&gt;sendmsg()&lt;/code&gt;用于向另一个套接字发送消息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;send()&lt;/code&gt;调用只有在套接字处于连接状态时才能使用（这样才能知道目标接收者）。 &lt;code&gt;send()&lt;/code&gt;和&lt;code&gt;write()&lt;/code&gt;的唯一区别是是否有&lt;code&gt;flags&lt;/code&gt;参数。 在&lt;code&gt;flags&lt;/code&gt;参数为零的情况下，&lt;code&gt;send()&lt;/code&gt;等同于&lt;code&gt;write()&lt;/code&gt;。 另外，下面的调用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;send(sockfd, buf, len, flags)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;sendto(sockfd, buf, len, flags, NULL, 0)；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数&lt;code&gt;sockfd&lt;/code&gt;是发送套接字的文件描述符。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;sendto()&lt;/code&gt;在连接模式(&lt;code&gt;SOCK_STREAM&lt;/code&gt;, &lt;code&gt;SOCK_SEQPACKET&lt;/code&gt;)的套接字上使用，参数&lt;code&gt;dest_addr&lt;/code&gt;和&lt;code&gt;addrlen&lt;/code&gt;将被忽略(当它们不是&lt;code&gt;NULL&lt;/code&gt;和0时，可能返回错误&lt;code&gt;EISCONN&lt;/code&gt;)、 当socket没有被连接时，将返回错误&lt;code&gt;ENOTCONN&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;否则，目标地址由&lt;code&gt;dest_addr&lt;/code&gt;给出，&lt;code&gt;addrlen&lt;/code&gt;指定其大小。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;sendmsg()&lt;/code&gt;，目标地址由&lt;code&gt;msg.msg_name&lt;/code&gt;给出，&lt;code&gt;msg.msg_namelen&lt;/code&gt;指定其大小。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;send&lt;/code&gt; 参数说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sockfd&lt;/code&gt;：表示已连接的套接字的文件描述符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buf&lt;/code&gt;：指向要发送数据的缓冲区的指针。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len&lt;/code&gt;：表示要发送的数据的大小。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flags&lt;/code&gt;：用于指定发送操作的可选标志，如 MSG_DONTWAIT、MSG_NOSIGNAL 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;send()&lt;/code&gt; 函数的返回值是实际发送的字节数，如果返回值为 -1，则表示发生了错误，可以通过 &lt;code&gt;errno&lt;/code&gt; 变量获取具体的错误信息。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;send()&lt;/code&gt; 函数可能不会立即发送所有的数据，特别是在非阻塞模式下。如果你需要确保所有数据都被发送，可以使用循环来重复调用 &lt;code&gt;send()&lt;/code&gt; 直到发送完所有数据。&lt;/p&gt;
&lt;h2 id=&#34;查看网络信息&#34;&gt;查看网络信息&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;netstat&lt;/code&gt; 命令是一个用于显示网络状态和统计信息的命令行工具。它可以显示当前打开的网络连接、监听端口、路由表、网络接口等信息，是网络故障排除和性能调优的常用工具之一。&lt;/p&gt;
&lt;p&gt;常用的参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-a：显示所有连接和监听端口。&lt;/li&gt;
&lt;li&gt;-n：以数字形式显示地址和端口号，而不是使用主机名和服务名。&lt;/li&gt;
&lt;li&gt;-p：显示与连接关联的进程信息。&lt;/li&gt;
&lt;li&gt;-r：显示路由表。&lt;/li&gt;
&lt;li&gt;-i：显示网络接口信息。&lt;/li&gt;
&lt;li&gt;-s：显示网络统计信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是一些额外的示例：&lt;/p&gt;
&lt;p&gt;显示所有 TCP 连接：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;netstat -at
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示所有 UDP 连接：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;netstat -au
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示所有监听端口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;netstat -l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示所有与进程关联的连接：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;netstat -p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查找所有使用端口号为 9999 的网络连接，并显示与之关联的进程信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;netstat -anp| grep 9999
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果有多个进程使用了该端口号，则会显示多行输出。&lt;/p&gt;
&lt;h2 id=&#34;端口复用&#34;&gt;端口复用&lt;/h2&gt;
&lt;p&gt;端口复用最常用的用途是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;防止服务器重启时之前绑定的端口还未释放&lt;/li&gt;
&lt;li&gt;程序突然退出而系统没有释放端口&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;sys/types.h&amp;gt;   
#include &amp;lt;sys/socket.h&amp;gt;

int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意 &lt;strong&gt;端口复用的设置是在服务器调用&lt;code&gt;bind&lt;/code&gt;绑定端口之前&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sockfd&lt;/code&gt;：&lt;code&gt;sockfd&lt;/code&gt;必须指向一个打开的套接字描述符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;level&lt;/code&gt;：&lt;code&gt;level&lt;/code&gt;指定系统中解释选项的代码或为通用套接字代码，或为某个特定于协议的代码(例如IPv4、IPv6、TCP或SCTP)。在设置端口复用时，设置为&lt;code&gt;SOL_SOCKET&lt;/code&gt;（端口复用的级别）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;optname&lt;/code&gt;：用于指定选项的名称，与&lt;code&gt;level&lt;/code&gt;一块使用。在设置端口复用时一般用以下两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;：允许重用本地地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SO_REUSEPORT&lt;/code&gt;：允许重用本地端口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;optval&lt;/code&gt;：&lt;code&gt;optval&lt;/code&gt;是一个指向某个变量的指针，&lt;code&gt;setsockopt&lt;/code&gt;从&lt;code&gt;*optval&lt;/code&gt;中取得选项待设置的新值，&lt;code&gt;getsockopt&lt;/code&gt;则把已获取的选项当前值存放到&lt;code&gt;*optval&lt;/code&gt;中。&lt;code&gt;*optval&lt;/code&gt;的大小由最后一个参数指定，它对于&lt;code&gt;setsockopt&lt;/code&gt;是一个值参数，对于&lt;code&gt;getsockopt&lt;/code&gt;是一个值结果参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在设置端口复用时传进去的是一个int类型的指针，其指向的变量值为1则可以复用，为0则表示不可复用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;optlen&lt;/code&gt;：指定&lt;code&gt;optval&lt;/code&gt;的大小&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成功：0&lt;/li&gt;
&lt;li&gt;失败：-1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用示例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int opval = 1;
setsockopt(lfd, SOL_SOCKET, SO_REUSEPORT, &amp;amp;opval, sizeof(opval));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下图汇总了可由&lt;code&gt;getsockcpt&lt;/code&gt;获取或由&lt;code&gt;setsockopt&lt;/code&gt;设置的选项。其中的“数据类型”列给出了指针oprval必须指向的每个选项的数据类型。我们用后跟一对花括号的记法来表示一个结构，如&lt;code&gt;1inger{}&lt;/code&gt;就表示&lt;code&gt;struct linger&lt;/code&gt;.&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1689061134614.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1689061138620.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">[C++项目] Web Server（4）：TCP 通信流程与端口复用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/vg5SEeNKH/"" data-c="
          &lt;p&gt;由于线程工作函数只能传递一个参数，而实际上可能会需要多个参数&lt;br&gt;
那么可以通过创建自定义结构体，将所有参数存入结构体中，然后用一个结构体参数传递所有参数&lt;br&gt;
这也是面向对象的编程方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct thread_args
{
    int fd; //通信的文件描述符
    pthread_t tid; //线程号
    struct sockaddr_in addr; //客户端信息
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目前通过一个死循环&lt;code&gt;while&lt;/code&gt;来实现server的持续监听和创建子线程的&lt;br&gt;
因此 直接在&lt;code&gt;while&lt;/code&gt;的局部作用域中赋值参数结构体 会导致脱离局部作用域后变量自动释放 而此时子线程仍旧在运行&lt;br&gt;
为了避免这种情况 通过全局的结构体数组来存储参数 并起到了自定义的线程池的作用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 用自己创建的线程参数数组充当线程池
struct thread_args thread_pool[128];
int max = sizeof(thread_pool)/sizeof(thread_pool[0]);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;服务器端代码&#34;&gt;服务器端代码&lt;/h2&gt;
&lt;p&gt;客户端不变&lt;br&gt;
将服务器端采用多进程方式实现并发&lt;br&gt;
总体结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;

// 由于线程工作函数只能传递一个参数，而实际上可能会需要多个参数
// 那么我们可以通过创建自定义结构体，将所有参数存入结构体中，然后用一个结构体参数传递所有参数
struct thread_args
{
    int fd; //通信的文件描述符
    pthread_t tid; //线程号
    struct sockaddr_in addr; //客户端信息
};

// 用自己创建的线程参数数组充当线程池
struct thread_args thread_pool[128];
int max = sizeof(thread_pool)/sizeof(thread_pool[0]);

void * working(void *arg){
    //子线程与客户端通信
    struct thread_args * pinfo = (struct thread_args *)arg;

    char cliIp[16];
    inet_ntop(AF_INET, &amp;amp;pinfo-&amp;gt;addr.sin_addr.s_addr, cliIp, sizeof(cliIp));
    unsigned short cliPort = ntohs(pinfo-&amp;gt;addr.sin_port);
    printf(&amp;quot;client ip is : %s, prot is %d\n&amp;quot;, cliIp, cliPort);

    // 接收客户端发来的数据
    char recvBuf[1024];
    while(1) {
        int len = read(pinfo-&amp;gt;fd, &amp;amp;recvBuf, sizeof(recvBuf));

        if(len == -1) {
            perror(&amp;quot;read&amp;quot;);
            exit(-1);
        }else if(len &amp;gt; 0) {
            printf(&amp;quot;recv client : %s\n&amp;quot;, recvBuf);
        } else if(len == 0) {
            printf(&amp;quot;client closed....\n&amp;quot;);
            break;
        }
        write(pinfo-&amp;gt;fd, recvBuf, strlen(recvBuf) + 1);
    }
    close(pinfo-&amp;gt;fd);
    pinfo-&amp;gt;fd = -1;
    bzero(&amp;amp;pinfo-&amp;gt;addr,sizeof(pinfo-&amp;gt;addr));
    pinfo-&amp;gt;tid = -1;
    printf(&amp;quot;退出后描述符为 %d\n&amp;quot;, pinfo-&amp;gt;fd);
    return NULL;

}

struct thread_args * get_thread(){
    for(int i=0;i&amp;lt;max;i++){
        if(thread_pool[i].fd==-1){
            return &amp;amp;thread_pool[i];
        }
    }
    sleep(1);
    return get_thread();
}

int main(){
    // 创建socket
    int lfd = socket(PF_INET, SOCK_STREAM, 0);
    if(lfd == -1){
        perror(&amp;quot;socket&amp;quot;);
        exit(-1);
    }

    struct sockaddr_in saddr;
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(9999);
    saddr.sin_addr.s_addr = INADDR_ANY;

    // 绑定
    int ret = bind(lfd,(struct sockaddr *)&amp;amp;saddr, sizeof(saddr));
    if(ret == -1) {
        perror(&amp;quot;bind&amp;quot;);
        exit(-1);
    }

    // 监听
    ret = listen(lfd, 128);
    if(ret == -1) {
        perror(&amp;quot;listen&amp;quot;);
        exit(-1);
    }

    //初始化自定义的线程池
    
    for(int i=0;i&amp;lt;max;i++){
        bzero(&amp;amp;thread_pool[i],sizeof(thread_pool[i]));
        thread_pool[i].fd = -1;
        thread_pool[i].tid = -1;
    }
    pthread_mutex_t lock;
    while(1){
        struct sockaddr_in client_addr;
        int len = sizeof(client_addr);
        //接受连接
        int cfd = accept(lfd,(struct sockaddr*)&amp;amp;client_addr,&amp;amp;len);

        //创建子线程
        pthread_mutex_trylock(&amp;amp;lock);
        struct thread_args * arg = get_thread(); 
        arg-&amp;gt;fd = cfd;
        memcpy(&amp;amp;arg-&amp;gt;addr,&amp;amp;client_addr,sizeof(client_addr));
        pthread_mutex_unlock(&amp;amp;lock);
        pthread_create(&amp;amp;arg-&amp;gt;tid,NULL,working,arg);
        pthread_detach(arg-&amp;gt;tid);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意 使用pthread头文件编程 编译时需要加上参数-pthread&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gcc ./server-thread.c -o server -pthread
&lt;/code&gt;&lt;/pre&gt;
">[C++项目] Web Server（3）：TCP 通信多线程并发</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/Fz_5FTIsp/"" data-c="
          &lt;p&gt;要实现TCP通信服务器处理并发的任务，使用多线程或者多进程来解决。&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个父进程，多个子进程&lt;/li&gt;
&lt;li&gt;父进程负责等待并接受客户端的连接&lt;/li&gt;
&lt;li&gt;子进程：完成通信，每次接受一个客户端连接，就创建一个子进程用于通信。&lt;/li&gt;
&lt;li&gt;每次子进程结束后，通过信号捕捉完成资源释放&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;客户端&#34;&gt;客户端&lt;/h2&gt;
&lt;p&gt;这里通过套接字来实现客户端与服务器端的连接&lt;br&gt;
注意 客户端需要指定服务器端的IP地址才能进行连接&lt;/p&gt;
&lt;h3 id=&#34;查看ip地址&#34;&gt;查看IP地址&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-she&#34;&gt;ifconfig
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过该命令可以查看到自己的IP地址，用于进行通信&lt;/p&gt;
&lt;h3 id=&#34;客户端代码&#34;&gt;客户端代码&lt;/h3&gt;
&lt;p&gt;这里不断向客户端通过write函数发送数据&lt;br&gt;
若服务器断开 则结束进程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// TCP通信的客户端
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main() {
    // 1.创建套接字
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if(fd == -1) {
        perror(&amp;quot;socket&amp;quot;);
        exit(-1);
    }

    // 2.连接服务器端
    struct sockaddr_in serveraddr;
    serveraddr.sin_family = AF_INET;
    inet_pton(AF_INET, &amp;quot;IPaddress&amp;quot;, &amp;amp;serveraddr.sin_addr.s_addr);  //这里 &amp;quot;IPaddress&amp;quot; 填写你自己服务器端的IP地址，如果是同一个机器编程就填本机IP地址即可
    serveraddr.sin_port = htons(9999);
    int ret = connect(fd, (struct sockaddr *)&amp;amp;serveraddr, sizeof(serveraddr));

    if(ret == -1) {
        perror(&amp;quot;connect&amp;quot;);
        exit(-1);
    }
    
    // 3. 通信
    char recvBuf[1024];
    int i = 0;
    while(1) {
        sprintf(recvBuf, &amp;quot;data : %d\n&amp;quot;, i++);
        // 给服务器端发送数据
        write(fd, recvBuf, strlen(recvBuf)+1);
        int len = read(fd, recvBuf, sizeof(recvBuf));
        if(len == -1) {
            perror(&amp;quot;read&amp;quot;);
            exit(-1);
        } else if(len &amp;gt; 0) {
            printf(&amp;quot;recv server : %s\n&amp;quot;, recvBuf);
        } else if(len == 0) {
            // 表示服务器端断开连接
            printf(&amp;quot;server closed...\n&amp;quot;);
            break;
        }
        sleep(1);
    }
    // 关闭连接
    close(fd);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;服务器端&#34;&gt;服务器端&lt;/h2&gt;
&lt;p&gt;为了处理子进程结束，这里使用注册了信号捕捉函数，用于捕获子进程结束信号&lt;code&gt;SIGCHLD&lt;/code&gt;并使用自定义的&lt;code&gt;recyleChild&lt;/code&gt;进行回收&lt;/p&gt;
&lt;h3 id=&#34;服务器端代码&#34;&gt;服务器端代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;wait.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;

void recyleChild(int arg) {
    while(1) {
        int ret = waitpid(-1, NULL, WNOHANG);
        if(ret == -1) {
            // 所有的子进程都回收了
            break;
        }else if(ret == 0) {
            // 还有子进程活着
            break;
        } else if(ret &amp;gt; 0){
            // 被回收了
            printf(&amp;quot;子进程 %d 被回收了\n&amp;quot;, ret);
        }
    }
}

int main() {
    struct sigaction act;
    act.sa_flags = 0;
    sigemptyset(&amp;amp;act.sa_mask);
    act.sa_handler = recyleChild;
    // 注册信号捕捉
    sigaction(SIGCHLD, &amp;amp;act, NULL);

    // 创建socket
    int lfd = socket(PF_INET, SOCK_STREAM, 0);
    if(lfd == -1){
        perror(&amp;quot;socket&amp;quot;);
        exit(-1);
    }

    struct sockaddr_in saddr;
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(9999);
    saddr.sin_addr.s_addr = INADDR_ANY;

    // 绑定
    int ret = bind(lfd,(struct sockaddr *)&amp;amp;saddr, sizeof(saddr));
    if(ret == -1) {
        perror(&amp;quot;bind&amp;quot;);
        exit(-1);
    }

    // 监听
    ret = listen(lfd, 128);
    if(ret == -1) {
        perror(&amp;quot;listen&amp;quot;);
        exit(-1);
    }

    // 不断循环等待客户端连接
    while(1) {
        struct sockaddr_in cliaddr;
        int len = sizeof(cliaddr);
        // 接受连接
        int cfd = accept(lfd, (struct sockaddr*)&amp;amp;cliaddr, &amp;amp;len);
        if(cfd == -1) {
            if(errno == EINTR) {
                continue;
            }
            perror(&amp;quot;accept&amp;quot;);
            exit(-1);
        }
        // 每一个连接进来，创建一个子进程跟客户端通信
        pid_t pid = fork();
        if(pid == 0) {
            // 子进程
            // 获取客户端的信息
            char cliIp[16];
            inet_ntop(AF_INET, &amp;amp;cliaddr.sin_addr.s_addr, cliIp, sizeof(cliIp));
            unsigned short cliPort = ntohs(cliaddr.sin_port);
            printf(&amp;quot;client ip is : %s, prot is %d\n&amp;quot;, cliIp, cliPort);

            // 接收客户端发来的数据
            char recvBuf[1024];
            while(1) {
                int len = read(cfd, &amp;amp;recvBuf, sizeof(recvBuf));
                if(len == -1) {
                    perror(&amp;quot;read&amp;quot;);
                    exit(-1);
                }else if(len &amp;gt; 0) {
                    printf(&amp;quot;recv client : %s\n&amp;quot;, recvBuf);
                } else if(len == 0) {
                    printf(&amp;quot;client closed....\n&amp;quot;);
                    break;
                }
                write(cfd, recvBuf, strlen(recvBuf) + 1);
            }
            close(cfd);
            exit(0);    // 退出当前子进程
        }
    }
    close(lfd);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">[C++项目] Web Server（2）：TCP 通信多进程并发</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/msIQ0Uw7P/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;一个Web Server就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机）。其主要功能是通过HTTP协议与客户端（通常是浏览器（Browser））进行通信，来接收，存储，处理来自客户端的HTTP请求，并对其请求做出HTTP响应，返回给客户端其请求的内容（文件、网页等）或返回一个Error信息。&lt;/p&gt;
&lt;p&gt;Web服务器端通过socket监听来自用户的请求。&lt;/p&gt;
&lt;p&gt;远端的很多用户会尝试去&lt;code&gt;connect()&lt;/code&gt;这个Web Server上正在listen的这个port，而监听到的这些连接会排队等待被&lt;code&gt;accept()&lt;/code&gt;。由于用户连接请求是随机到达的异步事件，每当监听socket（listenfd）listen到新的客户连接并且放入监听队列，我们都需要告诉我们的Web服务器有连接来了，accept这个连接，并分配一个逻辑单元来处理这个用户请求。&lt;/p&gt;
&lt;p&gt;服务器通过&lt;code&gt;epoll&lt;/code&gt;这种I/O复用技术（还有&lt;code&gt;select&lt;/code&gt;和&lt;code&gt;poll&lt;/code&gt;）来实现对监听socket（listenfd）和连接socket（客户请求）的同时监听。&lt;/p&gt;
&lt;p&gt;注意I/O复用虽然可以同时监听多个文件描述符，但是它本身是阻塞的，并且当有多个文件描述符同时就绪的时候，如果不采取额外措施，程序则只能按顺序处理其中就绪的每一个文件描述符，所以为提高效率，我们将在这部分通过线程池来实现并发（多线程并发），为每个就绪的文件描述符分配一个逻辑单元（线程）来处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;epoll_create（）&lt;/code&gt;创建一个epoll实例。其中nfd为epoll句柄，参数max_size标识这个监听的数目最大有多大，从Linux 2.6.8开始，max_size参数将被忽略，但必须大于零。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;epoll_create（）&lt;/code&gt;返回引用新epoll实例的文件描述符。该文件描述符用于随后的所有对epoll的调用接口。每创建一个epoll句柄，会占用一个fd，因此当不再需要时，应使用close关闭&lt;code&gt;epoll_create（）&lt;/code&gt;返回的文件描述符，否则可能导致fd被耗尽。当所有文件描述符引用已关闭的epoll实例，内核将销毁该实例并释放关联的资源以供重用。&lt;/p&gt;
&lt;p&gt;返回值：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;成功时，这些系统调用将返回非负文件描述符。如果出错，则返回-1，并且将&lt;code&gt;errno&lt;/code&gt;设置为指示错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-结构体&#34;&gt;1. 结构体&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef union epoll_data {   
    void *ptr;   
    int fd;  
    __uint32_t u32;  
    __uint64_t u64;
}epoll_data_t;// 保存触发事件的某个文件描述符相关的数据

struct epoll_event {  
    __uint32_t events;  /* epoll event */   
    epoll_data_t data;  /* User data variable */
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-events&#34;&gt;2. events&lt;/h3&gt;
&lt;p&gt;events:表示感兴趣的事件和被触发的事件，可取值如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;EPOLLIN: 表示对应的文件描述符可以读;
EPOLLOUT: 表示对应的文件描述符可以写;
EPOLLPRI: 表示对应的文件描述符有紧急的数可读;

EPOLLERR: 表示对应的文件描述符发生错误;
EPOLLHUP: 表示对应的文件描述符被挂断;
EPOLLET: ET的epoll工作模式; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-epoll_ctl函数&#34;&gt;3. epoll_ctl函数&lt;/h3&gt;
&lt;p&gt;声明：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;功能：用于控制某个文件描述符上的事件，可以注册事件，修改事件，删除事件。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@epfd：由&lt;code&gt;epoll_create&lt;/code&gt;生成的epoll专用的文件描述符；&lt;/li&gt;
&lt;li&gt;@op：要进行的操作，&lt;code&gt;EPOLL_CTL_ADD&lt;/code&gt;注册、&lt;code&gt;EPOLL_CTL_MOD&lt;/code&gt;修改、&lt;code&gt;EPOLL_CTL_DEL&lt;/code&gt;删除；&lt;/li&gt;
&lt;li&gt;@fd：关联的文件描述符；&lt;/li&gt;
&lt;li&gt;@event：指向&lt;code&gt;epoll_event&lt;/code&gt;的指针；&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688632215095.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;linux下进程在PCB中的文件描述符表中来保存打开的文件 前三为默认标准流 最多总共打开1024个&lt;/p&gt;
&lt;h2 id=&#34;socket&#34;&gt;socket&lt;/h2&gt;
&lt;p&gt;所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。 一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口， 是应用程序与网络协议根进行交互的接口。&lt;/p&gt;
&lt;p&gt;在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。&lt;strong&gt;本质为内核借助缓冲区形成的伪文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与管道类似的，Linux 系统将其&lt;strong&gt;封装成文件的目的是为了统一接口&lt;/strong&gt;，使得读写套接字和读写文件的操作一致。&lt;/p&gt;
&lt;p&gt;区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。&lt;/p&gt;
&lt;h3 id=&#34;网络字节序&#34;&gt;网络字节序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;大端字节序（Big Endian）：最高有效位存于最低内存地址处，最低有效位存于最高内存处；&lt;/li&gt;
&lt;li&gt;小端字节序（Little Endian）：最高有效位存于最高内存地址，最低有效位存于最低内存处。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络字节序:&lt;strong&gt;大端字节序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UDP/TCP/IP协议规定: 把接收到的第一个字节当作高位字节看待&lt;/p&gt;
&lt;h4 id=&#34;确定本机的字节序&#34;&gt;确定本机的字节序：&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* 确定你的电脑是大端字节序还是小端字节序 */ 
int check1() {  
    int i = 1; //1在内存中的表示： 0x00000001  
    char *pi = (char *)&amp;amp;i; //将int型的地址强制转换为char型  
    return *pi == 0; //如果读取到的第一个字节为1，则为小端法，为0，则为大端法 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;对字节序进行转换&#34;&gt;对字节序进行转换&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include&amp;lt;arpa/inet.h&amp;gt;  

//将主机字节序转换为网络字节序   host to network long/short   

// htonl 转ip  htons 转端口  剩下同理 

unit32_t htonl (unit32_t hostlong); 
unit16_t htons (unit16_t hostshort);  

//将网络字节序转换为主机字节序  

unit32_t ntohl (unit32_t netlong); 
unit16_t ntohs (unit16_t netshort); 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;socket地址&#34;&gt;socket地址&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;struct sockaddr&lt;/code&gt; 通用地址 和 &lt;code&gt;struct sockaddr_in&lt;/code&gt; 这两个结构体用来处理网络通信的地址。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct sockaddr {  
    sa_family_t sin_family;//地址族  常用AF_INET AF_INET6 
    char sa_data[14]; //14字节，包含套接字中的目标地址和端口信息  
};  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sockaddr&lt;/code&gt; 的缺陷是：&lt;code&gt;sa_data&lt;/code&gt;把目标地址和端口信息混在一起了&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sockaddr_in&lt;/code&gt; 解决了 &lt;code&gt;sockaddr&lt;/code&gt; 的缺陷，把 &lt;code&gt;port&lt;/code&gt; 和 &lt;code&gt;addr&lt;/code&gt; 分开储存在两个变量中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct sockaddr_in
{
    sa_family_t sin_family;  //地址族( Address Family )
    uint16_t sin_port;  //16位TCP/UDP端口号
    struct in_addr sin_addr; //32位IP地址
    char sin_zero[8]; //不使用
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该结构体中提到的另一个结构体&lt;code&gt;in_addr&lt;/code&gt;定义如下，它用来存放32位IP地址。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct in_addr
{
    In_addr_t s_addr; //32位IPV4地址
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;In_addr_t&lt;/code&gt; 就是一个32位的无符号整数&lt;/p&gt;
&lt;p&gt;为了保持前向兼容，使用时都需要强制转换成&lt;code&gt;sockaddr*&lt;/code&gt;类型使用，使用时由于前16位都是保存的地址族，那么则可以读取地址族再根据类型进行强制类型转换，变为原来的地址结构体类型使用。&lt;/p&gt;
&lt;h3 id=&#34;地址转换&#34;&gt;地址转换&lt;/h3&gt;
&lt;p&gt;通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用十六进制字符串表示 IPv6 地址。&lt;/p&gt;
&lt;p&gt;但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;in_addr_t inet_addr(const char *cp);//将IP地址从点十分格式转换成无符号长整型。 

char* inet_ntoa(struct in_addr in); //(“ntoa&amp;quot;的含义是&amp;quot;network to ascii”)  

int inet_aton(const char *cp, struct in_addr *inp);  //转换将点十分格式的ip地址为二进制并且为网络字节序，并存入指定的结构体中 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面三个都是旧式的函数，一般现在用下面两个新函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// p:点分十进制的IP字符串，n:表示network，网络字节序的整数 
int inet_pton(int af, const char *src, void *dst); 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;af&lt;/code&gt;: 地址族： ipv4 &lt;code&gt;AF_INET&lt;/code&gt; , ipv6  &lt;code&gt;AF_INET6 &lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;src&lt;/code&gt;: 需要转换的点分十进制的IP字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dst&lt;/code&gt;: 转换后的结果保存在这个里面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;inet_pton&lt;/code&gt;将点分十进制的IP地址字符串，转换成网络字节序的整数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;af&lt;/code&gt;:地址族： ipv4 &lt;code&gt;AF_INET&lt;/code&gt; , ipv6  &lt;code&gt;AF_INET6 &lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;src&lt;/code&gt;: 要转换的ip的整数的地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dst&lt;/code&gt;: 转换成IP地址字符串保存的地方&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size&lt;/code&gt;：第三个参数的大小（数组的大小）&lt;/li&gt;
&lt;li&gt;返回值：返回转换后的数据的地址（字符串），和 &lt;code&gt;dst&lt;/code&gt; 是一样的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;inet_ntop&lt;/code&gt;将网络字节序的整数，转换成点分十进制的IP地址字符串&lt;/p&gt;
&lt;h2 id=&#34;tcp通信流程&#34;&gt;tcp通信流程&lt;/h2&gt;
&lt;h3 id=&#34;服务器端&#34;&gt;服务器端&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建一个用于监听的套接字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监听：监听有客户端的连接&lt;/li&gt;
&lt;li&gt;套接字：这个套接字其实就是一个文件描述符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端连接服务器的时候使用的就是这个IP和端口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置监听，监听的fd开始工作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，accept会得到一个和客户端通信的套接字（fd）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通信&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收数据&lt;/li&gt;
&lt;li&gt;发送数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通信结束，断开连接&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;客户端&#34;&gt;客户端&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;创建一个用于通信的套接字（fd）&lt;/li&gt;
&lt;li&gt;连接服务器，需要指定连接的服务器的 IP 和 端口&lt;/li&gt;
&lt;li&gt;连接成功了，客户端可以直接和服务器通信
&lt;ul&gt;
&lt;li&gt;接收数据&lt;/li&gt;
&lt;li&gt;发送数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通信结束，断开连接&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688632221905.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;套接字相关函数&#34;&gt;套接字相关函数&lt;/h2&gt;
&lt;h4 id=&#34;引入头文件&#34;&gt;引入头文件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;sys/types.h&amp;gt; 
#include &amp;lt;sys/socket.h&amp;gt; 
#include &amp;lt;arpa/inet.h&amp;gt; // 包含了这个头文件，上面两个就可以省略 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;创建socket&#34;&gt;创建socket&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int socket(int domain, int type, int protocol); 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;功能：创建一个套接字&lt;/li&gt;
&lt;li&gt;参数：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;domain&lt;/code&gt;: 协议族
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AF_INET&lt;/code&gt; : ipv4&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AF_INET6&lt;/code&gt; : ipv6&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;, &lt;code&gt;AF_LOCAL &lt;/code&gt;: 本地套接字通信（进程间通信）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;: 通信过程中使用的协议类型
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt; : 流式协议&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCK_DGRAM&lt;/code&gt; : 报式协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protocol&lt;/code&gt; : 具体的一个协议。一般写0
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt; : 流式协议默认使用 TCP&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCK_DGRAM&lt;/code&gt; : 报式协议默认使用 UDP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;返回值：
&lt;ul&gt;
&lt;li&gt;成功：返回文件描述符，操作的就是内核缓冲区。&lt;/li&gt;
&lt;li&gt;失败：-1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;绑定端口&#34;&gt;绑定端口&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // socket命名 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;功能：绑定，将fd 和本地的IP + 端口进行绑定&lt;/li&gt;
&lt;li&gt;参数：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sockfd&lt;/code&gt; : 通过socket函数得到的文件描述符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addr&lt;/code&gt; : 需要绑定的socket地址，这个地址封装了ip和端口号的信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addrlen&lt;/code&gt; : 第二个参数结构体占的内存大小&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;监听端口&#34;&gt;监听端口&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int listen(int sockfd, int backlog); 
// 系统中的最大连接数设置/proc/sys/net/core/somaxconn 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;功能：监听这个socket上的连接&lt;/li&gt;
&lt;li&gt;参数：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sockfd&lt;/code&gt; : 通过&lt;code&gt;socket()&lt;/code&gt;函数得到的文件描述符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;backlog&lt;/code&gt; : 未连接的和已经连接的和的最大值， 5&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;接收连接&#34;&gt;接收连接&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接&lt;/li&gt;
&lt;li&gt;参数：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sockfd&lt;/code&gt; : 用于监听的文件描述符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addr&lt;/code&gt; : 传出参数，记录了连接成功后客户端的地址信息（ip，port）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addrlen&lt;/code&gt; : 指定第二个参数的对应的内存大小&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;返回值：
&lt;ul&gt;
&lt;li&gt;成功 ：用于通信的文件描述符&lt;/li&gt;
&lt;li&gt;失败 ：  -1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;发起连接&#34;&gt;发起连接&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;功能： 客户端连接服务器&lt;/li&gt;
&lt;li&gt;参数：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sockfd&lt;/code&gt; : 用于通信的文件描述符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addr&lt;/code&gt; : 客户端要连接的服务器的地址信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addrlen &lt;/code&gt;: 第二个参数的内存大小&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;返回值：
&lt;ul&gt;
&lt;li&gt;成功 ： 0&lt;/li&gt;
&lt;li&gt;失败 ： -1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;读写数据&#34;&gt;读写数据&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ssize_t write(int fd, const void *buf, size_t count); // 写数据 
ssize_t read(int fd, void *buf, size_t count); // 读数据 
&lt;/code&gt;&lt;/pre&gt;
">[C++项目] Web Server（1）：Socket 编程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/9PwMDr6Nt/"" data-c="
          &lt;p&gt;计算机图形学主要分为光栅化（openGL） 曲线曲面（几何） 光线追踪 动画与模拟&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;光栅化：简而言之 就是将三维空间的几何形体显示在屏幕上&lt;/li&gt;
&lt;li&gt;实时生成 指的是每秒钟至少生成30张画面 否则就叫离线&lt;/li&gt;
&lt;li&gt;曲线曲面：如何生成光滑的曲线曲面，如何用简单曲面生成复杂曲面，如何保持物体的拓扑结构&lt;/li&gt;
&lt;li&gt;光线追踪：生成真实的画面&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;向量&#34;&gt;向量&lt;/h2&gt;
&lt;p&gt;图形学中的向量默认是列向量，转置是行向量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2D&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mover accent=&#34;true&#34;&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;⃗&lt;/mo&gt;&lt;/mover&gt;&lt;mo&gt;⋅&lt;/mo&gt;&lt;mover accent=&#34;true&#34;&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;⃗&lt;/mo&gt;&lt;/mover&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;(&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mo&gt;⋅&lt;/mo&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;(&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\vec{a}\cdot\vec{b}=\begin{pmatrix}x_a\\y_a\end{pmatrix}\cdot\begin{pmatrix}x_b\\y_b\end{pmatrix}=x_ax_b+y_ay_b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.714em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord accent&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.714em;&#34;&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;accent-body&#34; style=&#34;left:-0.2355em;&#34;&gt;&lt;span class=&#34;overlay&#34; style=&#34;height:0.714em;width:0.471em;&#34;&gt;&lt;svg width=&#39;0.471em&#39; height=&#39;0.714em&#39; style=&#39;width:0.471em&#39; viewBox=&#39;0 0 471 714&#39; preserveAspectRatio=&#39;xMinYMin&#39;&gt;&lt;path d=&#39;M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;⋅&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.9774399999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord accent&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9774399999999999em;&#34;&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.26344em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;accent-body&#34; style=&#34;left:-0.2355em;&#34;&gt;&lt;span class=&#34;overlay&#34; style=&#34;height:0.714em;width:0.471em;&#34;&gt;&lt;svg width=&#39;0.471em&#39; height=&#39;0.714em&#39; style=&#39;width:0.471em&#39; viewBox=&#39;0 0 471 714&#39; preserveAspectRatio=&#39;xMinYMin&#39;&gt;&lt;path d=&#39;M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.40003em;vertical-align:-0.95003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;⋅&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.40003em;vertical-align:-0.95003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.73333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;3D&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mover accent=&#34;true&#34;&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;⃗&lt;/mo&gt;&lt;/mover&gt;&lt;mo&gt;⋅&lt;/mo&gt;&lt;mover accent=&#34;true&#34;&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;⃗&lt;/mo&gt;&lt;/mover&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;(&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mo&gt;⋅&lt;/mo&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;(&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\vec a\cdot\vec b=\begin{pmatrix}x_a\\y_a\\z_a\end{pmatrix}\cdot\begin{pmatrix}x_b\\y_b\\z_b\end{pmatrix}=x_ax_b+y_ay_b+z_az_b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.714em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord accent&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.714em;&#34;&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;accent-body&#34; style=&#34;left:-0.2355em;&#34;&gt;&lt;span class=&#34;overlay&#34; style=&#34;height:0.714em;width:0.471em;&#34;&gt;&lt;svg width=&#39;0.471em&#39; height=&#39;0.714em&#39; style=&#39;width:0.471em&#39; viewBox=&#39;0 0 471 714&#39; preserveAspectRatio=&#39;xMinYMin&#39;&gt;&lt;path d=&#39;M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;⋅&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.9774399999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord accent&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9774399999999999em;&#34;&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.26344em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;accent-body&#34; style=&#34;left:-0.2355em;&#34;&gt;&lt;span class=&#34;overlay&#34; style=&#34;height:0.714em;width:0.471em;&#34;&gt;&lt;svg width=&#39;0.471em&#39; height=&#39;0.714em&#39; style=&#39;width:0.471em&#39; viewBox=&#39;0 0 471 714&#39; preserveAspectRatio=&#39;xMinYMin&#39;&gt;&lt;path d=&#39;M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:3.60004em;vertical-align:-1.55002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05002em;&#34;&gt;&lt;span style=&#34;top:-2.2500000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎝&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.05002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎛&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.55002em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05em;&#34;&gt;&lt;span style=&#34;top:-4.21em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0099999999999993em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.8099999999999994em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.5500000000000007em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05002em;&#34;&gt;&lt;span style=&#34;top:-2.2500000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎠&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.05002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎞&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.55002em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;⋅&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:3.60004em;vertical-align:-1.55002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05002em;&#34;&gt;&lt;span style=&#34;top:-2.2500000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎝&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.05002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎛&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.55002em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05em;&#34;&gt;&lt;span style=&#34;top:-4.21em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0099999999999993em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.8099999999999994em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.5500000000000007em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05002em;&#34;&gt;&lt;span style=&#34;top:-2.2500000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎠&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.05002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎞&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.55002em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.73333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7777700000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;向量b在a上的投影：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;θ&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∗&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(||b||cos\theta) ∗ a&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;θ&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688543558859.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;向量&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a \times b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;×&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 也就是叉乘的结果&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;c&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 是一个同时垂直于&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的向量 常用于求法线&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mover accent=&#34;true&#34;&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;⃗&lt;/mo&gt;&lt;/mover&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mover accent=&#34;true&#34;&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;⃗&lt;/mo&gt;&lt;/mover&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;(&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\vec{a}\times\vec{b}=\begin{pmatrix}y_az_b-y_bz_a\\z_ax_b-x_az_b\\x_ay_b-y_ax_b\end{pmatrix}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.79733em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord accent&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.714em;&#34;&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;accent-body&#34; style=&#34;left:-0.2355em;&#34;&gt;&lt;span class=&#34;overlay&#34; style=&#34;height:0.714em;width:0.471em;&#34;&gt;&lt;svg width=&#39;0.471em&#39; height=&#39;0.714em&#39; style=&#39;width:0.471em&#39; viewBox=&#39;0 0 471 714&#39; preserveAspectRatio=&#39;xMinYMin&#39;&gt;&lt;path d=&#39;M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;×&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.9774399999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord accent&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9774399999999999em;&#34;&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.26344em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;accent-body&#34; style=&#34;left:-0.2355em;&#34;&gt;&lt;span class=&#34;overlay&#34; style=&#34;height:0.714em;width:0.471em;&#34;&gt;&lt;svg width=&#39;0.471em&#39; height=&#39;0.714em&#39; style=&#39;width:0.471em&#39; viewBox=&#39;0 0 471 714&#39; preserveAspectRatio=&#39;xMinYMin&#39;&gt;&lt;path d=&#39;M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:3.60004em;vertical-align:-1.55002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05002em;&#34;&gt;&lt;span style=&#34;top:-2.2500000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎝&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.05002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎛&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.55002em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05em;&#34;&gt;&lt;span style=&#34;top:-4.21em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0099999999999993em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.8099999999999994em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.5500000000000007em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05002em;&#34;&gt;&lt;span style=&#34;top:-2.2500000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎠&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.05002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎞&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.55002em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;c&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的方向可以用右手螺旋定则得到（右手坐标系下）&lt;br&gt;
四指从&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;转到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 大拇指方向就是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;c&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的方向&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688543570313.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;应用： axb 叉乘结果为正 则说明在b在a的左侧 为负在右侧&lt;/p&gt;
&lt;p&gt;接着进一步就可以判断点在图形内部还是外部了&lt;/p&gt;
&lt;p&gt;即分别计算ABxAP BCxBP CAxCP 若叉乘结果都为同号 则说明该点同时在这三个向量同侧&lt;br&gt;
也就说明在图形内部&lt;/p&gt;
&lt;p&gt;注意是哪三个向量 反着来也行 但是都要按顺序&lt;/p&gt;
&lt;h2 id=&#34;矩阵&#34;&gt;矩阵&lt;/h2&gt;
&lt;p&gt;矩阵相乘: &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;AxB = C&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;
其中&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;C[i][j]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 就等于&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的第&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;行与&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的第&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;列逐项相乘求和的结果&lt;/p&gt;
&lt;p&gt;矩阵乘法没有交换律&lt;/p&gt;
&lt;p&gt;求一个二维向量关于y轴的对称 左乘一个矩阵即可&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;(&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;(&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;(&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\begin{pmatrix}-1&amp;amp;0\\0&amp;amp;1\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix}=\begin{pmatrix}-x\\y\end{pmatrix}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.40003em;vertical-align:-0.95003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.40003em;vertical-align:-0.95003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(AB)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的转置 等于 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的转置乘&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的转置&lt;br&gt;
即&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/msup&gt;&lt;msup&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(AB)^T=B^TA^T&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.0913309999999998em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8413309999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8413309999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8413309999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8413309999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;矩阵的逆也是同理&lt;br&gt;
即&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;msup&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(AB)^{-1} = B^{-1}A^{-1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;向量的点乘和叉乘都可以表示成矩阵形式&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mover accent=&#34;true&#34;&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;⃗&lt;/mo&gt;&lt;/mover&gt;&lt;mo&gt;⋅&lt;/mo&gt;&lt;mover accent=&#34;true&#34;&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;⃗&lt;/mo&gt;&lt;/mover&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mover accent=&#34;true&#34;&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;⃗&lt;/mo&gt;&lt;/mover&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/msup&gt;&lt;mover accent=&#34;true&#34;&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;⃗&lt;/mo&gt;&lt;/mover&gt;&lt;mspace linebreak=&#34;newline&#34;&gt;&lt;/mspace&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;(&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;(&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mspace linebreak=&#34;newline&#34;&gt;&lt;/mspace&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;(&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\vec a\cdot\vec b=\vec a^T\vec b\\=\begin{pmatrix}x_a&amp;amp;y_a&amp;amp;z_a\end{pmatrix}\begin{pmatrix}x_b\\y_b\\z_b\end{pmatrix}\\=\begin{pmatrix}x_ax_b+y_ay_b+z_az_b\end{pmatrix}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.714em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord accent&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.714em;&#34;&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;accent-body&#34; style=&#34;left:-0.2355em;&#34;&gt;&lt;span class=&#34;overlay&#34; style=&#34;height:0.714em;width:0.471em;&#34;&gt;&lt;svg width=&#39;0.471em&#39; height=&#39;0.714em&#39; style=&#39;width:0.471em&#39; viewBox=&#39;0 0 471 714&#39; preserveAspectRatio=&#39;xMinYMin&#39;&gt;&lt;path d=&#39;M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;⋅&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.9774399999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord accent&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9774399999999999em;&#34;&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.26344em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;accent-body&#34; style=&#34;left:-0.2355em;&#34;&gt;&lt;span class=&#34;overlay&#34; style=&#34;height:0.714em;width:0.471em;&#34;&gt;&lt;svg width=&#39;0.471em&#39; height=&#39;0.714em&#39; style=&#39;width:0.471em&#39; viewBox=&#39;0 0 471 714&#39; preserveAspectRatio=&#39;xMinYMin&#39;&gt;&lt;path d=&#39;M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.9774399999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord accent&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.714em;&#34;&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;accent-body&#34; style=&#34;left:-0.2355em;&#34;&gt;&lt;span class=&#34;overlay&#34; style=&#34;height:0.714em;width:0.471em;&#34;&gt;&lt;svg width=&#39;0.471em&#39; height=&#39;0.714em&#39; style=&#39;width:0.471em&#39; viewBox=&#39;0 0 471 714&#39; preserveAspectRatio=&#39;xMinYMin&#39;&gt;&lt;path d=&#39;M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8413309999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord accent&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9774399999999999em;&#34;&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.26344em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;accent-body&#34; style=&#34;left:-0.2355em;&#34;&gt;&lt;span class=&#34;overlay&#34; style=&#34;height:0.714em;width:0.471em;&#34;&gt;&lt;svg width=&#39;0.471em&#39; height=&#39;0.714em&#39; style=&#39;width:0.471em&#39; viewBox=&#39;0 0 471 714&#39; preserveAspectRatio=&#39;xMinYMin&#39;&gt;&lt;path d=&#39;M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace newline&#34;&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:3.60004em;vertical-align:-1.55002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size1&#34;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8500000000000001em;&#34;&gt;&lt;span style=&#34;top:-3.01em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.35000000000000003em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8500000000000001em;&#34;&gt;&lt;span style=&#34;top:-3.01em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.35000000000000003em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8500000000000001em;&#34;&gt;&lt;span style=&#34;top:-3.01em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.35000000000000003em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size1&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05002em;&#34;&gt;&lt;span style=&#34;top:-2.2500000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎝&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.05002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎛&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.55002em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05em;&#34;&gt;&lt;span style=&#34;top:-4.21em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0099999999999993em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.8099999999999994em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.5500000000000007em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05002em;&#34;&gt;&lt;span style=&#34;top:-2.2500000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎠&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.05002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎞&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.55002em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace newline&#34;&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.20001em;vertical-align:-0.35001em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size1&#34;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8500000000000001em;&#34;&gt;&lt;span style=&#34;top:-3.01em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.35000000000000003em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size1&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mover accent=&#34;true&#34;&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;⃗&lt;/mo&gt;&lt;/mover&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mover accent=&#34;true&#34;&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;⃗&lt;/mo&gt;&lt;/mover&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;/msup&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;(&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;(&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;msub&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\vec{a}\times\vec{b}=A^*b=\begin{pmatrix}0&amp;amp;-z_a&amp;amp;y_a\\z_a&amp;amp;0&amp;amp;-x_a\\-y_a&amp;amp;x_a&amp;amp;0\end{pmatrix}\begin{pmatrix}x_b\\y_b\\z_b\end{pmatrix}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.79733em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord accent&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.714em;&#34;&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;accent-body&#34; style=&#34;left:-0.2355em;&#34;&gt;&lt;span class=&#34;overlay&#34; style=&#34;height:0.714em;width:0.471em;&#34;&gt;&lt;svg width=&#39;0.471em&#39; height=&#39;0.714em&#39; style=&#39;width:0.471em&#39; viewBox=&#39;0 0 471 714&#39; preserveAspectRatio=&#39;xMinYMin&#39;&gt;&lt;path d=&#39;M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;×&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.9774399999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord accent&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9774399999999999em;&#34;&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.26344em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;accent-body&#34; style=&#34;left:-0.2355em;&#34;&gt;&lt;span class=&#34;overlay&#34; style=&#34;height:0.714em;width:0.471em;&#34;&gt;&lt;svg width=&#39;0.471em&#39; height=&#39;0.714em&#39; style=&#39;width:0.471em&#39; viewBox=&#39;0 0 471 714&#39; preserveAspectRatio=&#39;xMinYMin&#39;&gt;&lt;path d=&#39;M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.688696em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mbin mtight&#34;&gt;∗&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:3.60004em;vertical-align:-1.55002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05002em;&#34;&gt;&lt;span style=&#34;top:-2.2500000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎝&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.05002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎛&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.55002em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05em;&#34;&gt;&lt;span style=&#34;top:-4.21em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0099999999999993em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.8099999999999994em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.5500000000000007em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05em;&#34;&gt;&lt;span style=&#34;top:-4.21em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0099999999999993em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.8099999999999994em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.5500000000000007em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05em;&#34;&gt;&lt;span style=&#34;top:-4.21em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0099999999999993em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.8099999999999994em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.5500000000000007em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05002em;&#34;&gt;&lt;span style=&#34;top:-2.2500000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎠&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.05002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎞&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.55002em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05002em;&#34;&gt;&lt;span style=&#34;top:-2.2500000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎝&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.05002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎛&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.55002em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05em;&#34;&gt;&lt;span style=&#34;top:-4.21em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0099999999999993em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.8099999999999994em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.5500000000000007em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05002em;&#34;&gt;&lt;span style=&#34;top:-2.2500000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎠&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.05002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎞&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.55002em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;齐次坐标的意义在于为了将平移坐标纳入统一的变换矩阵中&lt;br&gt;
一般用（x，y，1）表示点的齐次坐标，（x，y，0）表示向量的齐次坐标&lt;/p&gt;
&lt;h2 id=&#34;光栅化&#34;&gt;光栅化&lt;/h2&gt;
&lt;p&gt;谈到光栅化（Rasterization）我们就不得不提一下实时渲染的核心组件——图形渲染管线（The Graphics Rendering Pipeline），它的主要功能是在给定一个虚拟相机、 三维物体、光源等等的情况下生成或渲染二维图像（如下图）。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688543585055.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;实时渲染管线（Real-Time Rendering Pipeline）的各阶段是并行执行的，每个阶段都取决于上一阶段的结果。大致分为四个主要阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序阶段（Application）&lt;/li&gt;
&lt;li&gt;几何处理阶段（Geometry Processing）&lt;/li&gt;
&lt;li&gt;光栅化阶段（Rasterization）&lt;/li&gt;
&lt;li&gt;像素处理阶段（Pixel Processing）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;屏幕映射（视口变换）：对于标准立方体[-1, 1]³，先不管它的Z轴数据（由深度缓冲来处理），屏幕映射需要将X和Y轴 [-1, 1]² 映射到屏幕坐标 [0, width] x [0, height]，和MVP变换类似，通过齐次坐标的矩阵，先将 [-1, 1]² 缩放至 [width, height]&lt;/p&gt;
&lt;p&gt;因为标准立方体中心在原点，而屏幕原点在左下角，所以还需要经过一个平移使得原点坐标对齐，将标准立方体转换成屏幕空间，变为窗口坐标系，变换矩阵为：&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;[&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;M_{viewport}=\begin{bmatrix}\dfrac{width}{2}&amp;amp;0&amp;amp;0&amp;amp;\dfrac{width}{2}\\0&amp;amp;\dfrac{height}{2}&amp;amp;0&amp;amp;\dfrac{height}{2}\\0&amp;amp;0&amp;amp;1&amp;amp;0\\0&amp;amp;0&amp;amp;0&amp;amp;1\end{bmatrix}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.969438em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:6.60504em;vertical-align:-3.050045em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:3.554995em;&#34;&gt;&lt;span style=&#34;top:-0.7499750000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎣&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.9049750000000003em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎢&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.5059750000000003em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎢&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1069750000000003em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎢&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.7079750000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎢&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.308975em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎢&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-5.554995em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎡&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:3.050045em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:3.5074400000000003em;&#34;&gt;&lt;span style=&#34;top:-5.50744em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.3714399999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.37144em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.4500000000000006em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.3714399999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.9240000000000006em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.3714399999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-0.7240000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.3714399999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:3.0074399999999994em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:3.5074400000000003em;&#34;&gt;&lt;span style=&#34;top:-5.50744em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.3714399999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.4500000000000006em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.3714399999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.3714399999999998em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.9240000000000006em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.3714399999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-0.7240000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.3714399999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:3.0074399999999994em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:3.5074400000000003em;&#34;&gt;&lt;span style=&#34;top:-5.50744em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.3714399999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.4500000000000006em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.3714399999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.9240000000000006em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.3714399999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-0.7240000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.3714399999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:3.0074399999999994em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:3.5074400000000003em;&#34;&gt;&lt;span style=&#34;top:-5.50744em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.3714399999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.37144em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.4500000000000006em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.3714399999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.3714399999999998em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.9240000000000006em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.3714399999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-0.7240000000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.3714399999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:3.0074399999999994em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:3.554995em;&#34;&gt;&lt;span style=&#34;top:-0.7499750000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎦&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.9049750000000003em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎥&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.5059750000000003em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎥&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1069750000000003em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎥&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.7079750000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎥&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.308975em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎥&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-5.554995em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.1550000000000002em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎤&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:3.050045em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;如何进行光栅化&#34;&gt;如何进行光栅化&lt;/h3&gt;
&lt;p&gt;先做一个视口变换，映射到屏幕空间，到这一步的时候大家不要忘了我们此时得到的不过是屏幕空间中的一些三角而已，但是这远远不够。&lt;/p&gt;
&lt;p&gt;我们需要把这些三角形打碎打成像素并且告诉每个像素的值是多少然后显示在屏幕上。因此利用&lt;br&gt;
像素的中心对屏幕空间进行采样，遍历全部三角形中的像素，然后判断像素的中心点是否在三角形内部，如果在就赋值为1并显示。&lt;/p&gt;
&lt;p&gt;这样我们就会发现一个问题，我们想要得到的是一个三角形，但是实际得到的不完完全是一个三角形，不过的它的形状和三角形大概类似，这就是我们所说的锯齿（或者说走样）。&lt;/p&gt;
&lt;p&gt;有两个原因导致锯齿：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一是像素本身有一定的大小&lt;/li&gt;
&lt;li&gt;二是采样的速度更不上信号变化的速度（高频信号采样不足）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;采样所产生的瑕疵&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;锯齿&lt;/li&gt;
&lt;li&gt;摩尔纹&lt;/li&gt;
&lt;li&gt;车轮错觉&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何进行反走样呢&#34;&gt;如何进行反走样呢&lt;/h3&gt;
&lt;p&gt;可以在采样之前&lt;strong&gt;先做模糊再采样&lt;/strong&gt;（模糊也可以认为是低通滤波器，把三角形边界的这种高频信号给过滤掉）。&lt;/p&gt;
&lt;h3 id=&#34;为什么模糊预过滤然后采样可以进行抗锯齿&#34;&gt;为什么模糊（预过滤）然后采样可以进行抗锯齿？&lt;/h3&gt;
&lt;p&gt;模糊（Blurring/Pre-Filtering ）就是要剔除某些特定频率的内容。模糊是通过低通滤泼器把高频信号剔除从而不会产生信号混叠，从而来解决反走样的问题。&lt;/p&gt;
&lt;p&gt;人们研究出一种近似算法也就是所谓的超采样MSAA, MSAA只是一个反走样的近似，并不能严格的解决反走样的问题。&lt;/p&gt;
&lt;p&gt;MSAA的算法是将一个像素划分成许多个小像素，每个小像素都有一个中心，算面积覆盖率就是可以等同于有几个采样点在这个三角形，如果像素点足够多的话就可以取得比较好的结果。&lt;/p&gt;
&lt;p&gt;MSAA的算法是将一个像素划分成许多个小像素，每个小像素都有一个中心，算面积覆盖率就是可以等同于有几个采样点在这个三角形，如果像素点足够多的话就可以取得比较好的结果。&lt;/p&gt;
&lt;h3 id=&#34;为什么经过一系列的空间变换和视口变换得到的是一系列屏幕空间的三角形&#34;&gt;为什么经过一系列的空间变换和视口变换得到的是一系列屏幕空间的三角形 ？&lt;/h3&gt;
&lt;p&gt;这是因为三角形在图形学中可以看做是几何体的基本形状（Triangles - Fundamental Shape Primitives）&lt;/p&gt;
&lt;p&gt;那可能又有人会想为什么是三角形呢？&lt;/p&gt;
&lt;p&gt;因为三角形在图形学中有很多很好的性质：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;三角形是最基本的多边形，并且任何其他的多边形都可以拆分为三角形。&lt;/li&gt;
&lt;li&gt;三个点可以保证他在一个平面, 如果是四边形四个点就不能保证。&lt;/li&gt;
&lt;li&gt;它可以很好地用叉积判断一个点是不是在三角形内部（三角形的内外定义特别清晰）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;光线追踪&#34;&gt;光线追踪&lt;/h2&gt;
&lt;p&gt;光线追踪（Ray Tracing）算法是一种计算机三维图形渲染算法，其基本出发点就是追踪光线，模拟真实的光路和成像过程。&lt;/p&gt;
&lt;p&gt;相比于其他大部分渲染算法，光线追踪算法的优势是可以提供更为真实的光影效果，劣势是计算量巨大。&lt;/p&gt;
&lt;h3 id=&#34;算法原理&#34;&gt;算法原理&lt;/h3&gt;
&lt;p&gt;从视点出发向屏幕上每一个像素发出一条光线，追踪此光路并计算其逆向光线的方向，映射到对应的像素上。如下图，通过计算光路上颜色衰减和叠加，即可基本确定每一个像素的颜色。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688543595924.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;主要包括&lt;strong&gt;相交检测&lt;/strong&gt;、&lt;strong&gt;计算光线反射&lt;/strong&gt;和&lt;strong&gt;折射&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对反射和折射后的光线递归计算颜色再叠加起来即可算得原光线颜色。若光线未遇到任何物体则返回背景色。&lt;/p&gt;
&lt;h3 id=&#34;相交检测&#34;&gt;相交检测&lt;/h3&gt;
&lt;p&gt;大多数情况下，场景中的三维物体是由众多三角形面片组合而成的，可以视为场景中实际上有一大堆三角面片，判断光线是否与场景中的物体碰撞，实际上是计算光线与三角形相交，找出离眼睛最近的那个相交的三角形。&lt;/p&gt;
&lt;p&gt;用最土的方法就是访问每一个三角形面片，计算光线是否跟它相交，现代的方法就是借助空间上的加速结构(例如BVH和KD树)，快速找到相交的三角形。&lt;/p&gt;
&lt;h3 id=&#34;经典光线追踪&#34;&gt;经典光线追踪&lt;/h3&gt;
&lt;p&gt;经典光线追踪，光线会计算击中物体后的反射方向(很少用到折射)，通常计算的是镜面反射，得到反射方向后，光线不会继续朝新方向前进(经典光线追踪最重要的特征之一)，意味着光线发生首次碰撞后便会就此打住，不会继续前进。&lt;/p&gt;
&lt;p&gt;那么计算的反射方向是用来干嘛用呢？其实用来计算像素颜色值的，不是用来作为新的前进方向的。&lt;/p&gt;
&lt;p&gt;光线首次击中物体，那么就能得到碰撞点，然后将该点与光源连一条线(简单的是用点光源)，判断这条线能不能直达光源，也就是计算这条线有没有与其他物体发生相交，如果有相交，则说明光源射到碰撞点的光被遮挡了，那么就按照渲染方程去计算阴影下这个像素点的颜色值；如果没有发生相交，则说明光源能直接照射到碰撞点，那就计算光照下的像素点颜色。&lt;/p&gt;
&lt;p&gt;之前计算得到的光线反射方向，用来计算光源与碰撞点之间的连线在反射方向上的投影(利用向量点乘计算)，理解为光源对这条光线的贡献值。&lt;/p&gt;
&lt;h3 id=&#34;递归式光线追踪&#34;&gt;递归式光线追踪&lt;/h3&gt;
&lt;p&gt;光线在场景中会发生多次碰撞，这一点正是递归光线追踪和经典光线追踪的区别处。&lt;/p&gt;
&lt;p&gt;同样是从人眼出发发射光线，穿过屏幕进入场景中，寻找光线最近的碰撞点，这开头都和经典光线追踪一模一样。关键在找到光线的首次碰撞点后，经典光线追踪是直接利用这个点和光源一起计算像素颜色值。而递归光线追踪则是将这个碰撞点作为光线的新起点，再在这个点上计算光线的反射方向作为光线的新方向，然后继续追踪这条光线，即继续寻找这条新光线的最近碰撞点(从算法实现上，这一步可以用递归函数去实现)。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688543604179.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来，光线遇到新的碰撞点，就生成新的反射光线继续追踪，连起来看就是一条光路，而我们就是在追踪这条光路，那么这条光路最终的结局无非就是两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;光线命中光源（这时光源可以是面光源、点光源，为了提高命中率，通常选面光源），利用这条光线沿途得到的信息来计算相应像素点的颜色值，沿途的信息是指中途的碰撞点（可以知道这个碰撞点是在哪个球上，这个球是什么颜色的等等），将各个碰撞点上的信息套入渲染方程计算，其实就是将各个碰撞点对光线做出的贡献进行混合。&lt;br&gt;
例如上图中A1是红色的，A2是蓝色的，A3是绿色的，光线每碰撞一次都会乘一个衰减系数（如0.8），用来减弱后续碰撞点贡献的权重，将各个点的颜色等信息带上衰减系数一起套入渲染方程里搅浑、混合、整合一下，结果值就是我们眼睛接受到这条光线的贡献值，即相应像素点的颜色值。（从结果上看，我们现在就能从玻璃球的表面看到反射的其他玻璃球了，因为像素颜色中有其他玻璃球上碰撞点的贡献）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二个结局就是光线没有命中光线，就是光线最后没有与任何三角形面片发生相交。同样的可以像经典光线追踪一样，把这个像素点设定为黑色，或者背景颜色。在游戏场景中就是天空盒。&lt;br&gt;
那么如果我们当前场景比较密闭呢，一条光线一直在场景中不断反射，就是没有击中光源的话，那怎么办？人为给定递归终止的条件：当光线碰撞了50次还没有击中光源或者射空（即递归50层），则终止递归，按照射空去处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;光照模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lambert 模型 漫反射&lt;/li&gt;
&lt;li&gt;Phong 模型 同时考虑到了镜面反射 都是单一光源情况&lt;/li&gt;
&lt;li&gt;全局光照模型 多光源更普适&lt;/li&gt;
&lt;/ul&gt;
">图形学概念介绍</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/E9VsDWY-m/"" data-c="
          &lt;h2 id=&#34;1-搭建cs&#34;&gt;1. 搭建C/S&lt;/h2&gt;
&lt;p&gt;先实现一个简单的ECHO服务器，只需要把任何收到的数据原封不动地发回去即可&lt;/p&gt;
&lt;p&gt;客户端要做的事情也十分简单，读取用户输入的一个字符串并发送给服务端，然后把接收到的数据输出出来即可。&lt;/p&gt;
&lt;p&gt;在socket编程中，服务端和客户端是靠socket进行连接的。服务端在建立连接之前需要做的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建socket&lt;/li&gt;
&lt;li&gt;将socket与指定的IP和端口(以下简称为port)绑定&lt;/li&gt;
&lt;li&gt;让socket在绑定的端口处监听请求(等待客户端连接到服务端绑定的端口)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而客户端发送连接请求并成功连接之后，服务端便会得到客户端的套接字，于是所有的收发数据便可以在这个客户端的套接字上进行了。&lt;/p&gt;
&lt;p&gt;而收发数据其实就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收数据：使用客户端套接字拿到客户端发来的数据，并将其存于buff中。&lt;/li&gt;
&lt;li&gt;发送数据：使用客户端套接字，将buff中的数据发回去。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;什么是socket？&lt;br&gt;
socket就是套接字函数： 创建一个绑定到特定传输服务提供者的套接字。&lt;/p&gt;
&lt;p&gt;将底层复杂的协议体系，执行流程，进行了封装，封装完的结果，就是一个SOCKET了，也就是说，SOCKET是我们调用协议进行通信的操作接口。&lt;/p&gt;
&lt;p&gt;本质就是一种数据类型，到文件定义下看类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;就是一个整数(unsigned int)&lt;/li&gt;
&lt;li&gt;但是这个数是唯一的
&lt;ul&gt;
&lt;li&gt;标识着我们当前的应用程序，协议特点等信息&lt;/li&gt;
&lt;li&gt;ID，门牌号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;socket-函数参数介绍&#34;&gt;socket() 函数参数介绍&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;SOCKET WSAAPI socket(int af,//地址族规范。 地址族的可能值在Winsock2.h头文件中定义。
    int type,//新套接字的类型规范。
    int protocol//要使用的协议。
);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;af&lt;/code&gt; 当前常用的值为&lt;code&gt;AF_INET&lt;/code&gt;或&lt;code&gt;AF_INET6&lt;/code&gt;，这是IPv4和IPv6的Internet地址族格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt; 当前常用的值为&lt;code&gt;SOCK_STREAM&lt;/code&gt; 和&lt;code&gt;SOCK_DGRAM&lt;/code&gt;，分别是TCP和UDP的套接字类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SOCK_SEQPACKET&lt;/code&gt;：有序分组套接字，适用于SCTP协议&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCK_RAW&lt;/code&gt;：原始套接字，适用于绕过传输层直接与网络层协议(IPv4/IPv6)通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;protocol 如果指定的值为0，则调用者不希望指定协议，服务提供商将选择要使用的协议。常见值 &lt;code&gt;IPPROTO_ICMP&lt;/code&gt; &lt;code&gt;IPPROTO_IGMP&lt;/code&gt; &lt;code&gt;IPPROTO_TCP&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回值：&lt;br&gt;
如果没有发生错误，socket将返回一个引用新socket的描述符。否则，将返回-1，失败的时候可以通过输出&lt;code&gt;errno&lt;/code&gt;来详细查看具体错误类型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常一个内核函数运行出错的时候，它会定义全局变量&lt;code&gt;errno&lt;/code&gt;并赋值。当我们引入&lt;code&gt;errno.h&lt;/code&gt;头文件时便可以使用这个变量, 借助&lt;code&gt;strerror()&lt;/code&gt;函数，使用&lt;code&gt;strerror(errno)&lt;/code&gt;得到一个具体描述其错误的字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;sockfd = socket(AF_INET, SOCK_STREAM, 0); // 创建一个TCP连接的套接字
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在数据结构 &lt;code&gt;struct sockaddr_in&lt;/code&gt; 中， &lt;code&gt;sin_addr&lt;/code&gt; 和 &lt;code&gt;sin_port&lt;/code&gt; 需要转换为网络字节顺序，而&lt;code&gt;sin_family&lt;/code&gt; 不需要&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sin_addr&lt;/code&gt; 和 &lt;code&gt;sin_port&lt;/code&gt; 分别封装在包的 IP 和 UDP 层。因此，它们必须要是网络字节顺序。但是 sin_family 域只是被内核 (kernel) 使用来决定在数据结构中包含什么类型的地址，所以它必须是本机字节顺序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include&amp;lt;arpa/inet.h&amp;gt; 
//将主机字节序转换为网络字节序
unit32_t htonl (unit32_t hostlong);
unit16_t htons (unit16_t hostshort); 
//将网络字节序转换为主机字节序
unit32_t ntohl (unit32_t netlong);
unit16_t ntohs (unit16_t netshort);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着将套接字绑定到端口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct sockaddr_in servaddr; // 用于存放ip和端口的结构
bzero(&amp;amp;servaddr, sizeof(servaddr));    // 将该结构体的所有数据置零
servaddr.sin_family = AF_INET;    // 指定其协议族为IPv4协议族
servaddr.sin_addr.s_addr = htonl(INADDR_ANY);    // 指定IP地址为通配地址
servaddr.sin_port = htons(16555);    // 指定端口号为16555
if (-1 == bind(sockfd, (struct sockaddr*)&amp;amp;servaddr, sizeof(servaddr)))
{
    printf(&amp;quot;Bind error(%d): %s\n&amp;quot;, errno, strerror(errno));
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;INADDR_ANY&lt;/code&gt; 转换过来就是0.0.0.0，泛指本机的意思，也就是表示本机的所有IP，因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡ip地址的意思。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;connect()&lt;/code&gt; 和 &lt;code&gt;bind()&lt;/code&gt; 系统调用将套接字文件描述符“关联”到一个地址(通常是ip /端口组合)。 他们的原型是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bind()&lt;/code&gt;将套接字与其本地地址关联 (用于服务器端绑定，以便客户端可以使用该地址连接到服务器)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;connect()&lt;/code&gt;用于连接到远程&lt;code&gt;[server]&lt;/code&gt;地址，用于客户端，使用&lt;code&gt;connect [读取为：连接到服务器]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果不调用 &lt;code&gt;bind()&lt;/code&gt; ，则在调用 &lt;code&gt;connect()&lt;/code&gt; (客户端)或 &lt;code&gt;listen()&lt;/code&gt; (服务器)时，将为您隐式分配端口和地址并将其绑定到本地计算机上。 但是，这是两者的副作用，而不是目的。 以这种方式分配的端口是短暂的。&lt;/p&gt;
&lt;p&gt;这里的重要一点是，不需要绑定客户端，因为客户端连接到服务器，因此即使您使用的是临时端口，服务器也将知道客户端的地址和端口，而不是绑定到特定的端口。&lt;/p&gt;
&lt;p&gt;另一方面，尽管服务器可以在不调用 &lt;code&gt;bind() &lt;/code&gt;情况下调用&lt;code&gt; listen()&lt;/code&gt; ，但是在这种情况下，它们将需要发现分配的临时端口，并将其传达给它要连接的任何客户端。&lt;/p&gt;
&lt;p&gt;接着令服务器监听对应接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (-1 == listen(sockfd, MAXLINK))
{
    printf(&amp;quot;Listen error(%d): %s\n&amp;quot;, errno, strerror(errno));
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后持续执行操作直至退出&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;while(true)
{
    signal(SIGINT, stopServerRunning); //这句用于在输入Ctrl+C的时候关闭服务器
    //对应伪代码中的connfd . accept(sockfd);
    connfd = accept(sockfd, NULL, NULL);
    if (-1 == connfd) 
    {
        printf(&amp;quot;Accept error(%d): %s\n&amp;quot;, errno, strerror(errno));
        return -1;  
    }
    // END

    bzero(buff, BUFFSIZE);
    //对应伪代码中的recv(connfd, buff);
    recv(connfd, buff, BUFFSIZE - 1, 0);
    // END
    printf(&amp;quot;Recv: %s\n&amp;quot;, buff);
    //对应伪代码中的send(connfd, buff);
    send(connfd, buff, strlen(buff), 0);
    // END
    //对应伪代码中的close(connfd);
    close(connfd) ;
    // END
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面已经完成了对服务器的定义 类似的 我们可以定义初始客户端&lt;br&gt;
&lt;code&gt;inet_pton&lt;/code&gt;函数 将 IPv4 或 IPv6 Internet 网络地址转换为其数字二进制形式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define SERVER_IP &amp;quot;192.168.19.12&amp;quot; // 指定服务端的IP
struct sockaddr_in servaddr;
servaddr.sin_family = AF_INET;
//指定要连接的端口的ip地址 也就是将地址转换为IPv4地址 并传入servaddr.sin_addr
inet_pton(AF_INET, SERVER_IP, &amp;amp;servaddr.sin_addr)); 
servaddr.sin_port = htons(SERVER_PORT);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着调用connect函数连接服务端端口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (-1 == connect(sockfd, (struct sockaddr*)&amp;amp;servaddr, sizeof(servaddr)))
{
    printf(&amp;quot;Connect error(%d): %s\n&amp;quot;, errno, strerror(errno));
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后执行发送输出操作 使用&lt;code&gt;send&lt;/code&gt;和&lt;code&gt;recv&lt;/code&gt;发送和获取数据 &lt;code&gt;sendto&lt;/code&gt;函数一般用作UDP通信&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;send(SOCKET,BUFF,SIZE,FLAG)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数一：指定发送端套接字描述符；&lt;br&gt;
参数二：存放应用程序要发送数据的缓冲区；&lt;br&gt;
参数三：实际要发送的数据的字节数；&lt;br&gt;
参数四：一般置为0，此时&lt;code&gt;send&lt;/code&gt;为阻塞式发送，即发送不成功会一直阻塞，直到被某个信号终端终止，或者直到发送成功为止。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若指定为&lt;code&gt;MSG_NOSIGNAL&lt;/code&gt;，表示当连接被关闭时不会产生&lt;code&gt;SIGPIPE&lt;/code&gt;信号&lt;/li&gt;
&lt;li&gt;若指定为&lt;code&gt;MSG_DONTWAIT&lt;/code&gt; 表示非阻塞发送&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;recv(SOCKET,BUFF,SIZE,FLAG)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他参数类似&lt;br&gt;
参数四一般为 0，其他常见值如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MSG_PEEK：窥视传入的数据。 数据被复制到缓冲区中，但不会从输入队列中删除。&lt;/li&gt;
&lt;li&gt;MSG_OOB：处理带外(OOB)数据。&lt;/li&gt;
&lt;li&gt;MSG_WAITALL：仅当发生以下事件之一时，接收请求才会完成：
&lt;ul&gt;
&lt;li&gt;调用方提供的缓冲区已完全满。&lt;/li&gt;
&lt;li&gt;连接已关闭。&lt;/li&gt;
&lt;li&gt;该请求已被取消或发生错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;利用TCP传递信息时要注意：TCP传输是流的方式：即send 100个字节后对方如果没有及时recv取出，这时又send 100个字节，则recv有可能接收到两次发送叠加的部分或全部数据，所以在传送结构体数据时，应当发送以后睡眠一段时间，使对方recv有足够的实际取走数据，不至于两个结构体数据发生粘连，区分不出发送的是两个结构体数据。&lt;/p&gt;
&lt;p&gt;发送的数据将存放到系统缓冲区，当系统缓冲区已满时，send将返回发送的字节数，这时发送的字节数并不是SIZE大小了，同理，recv每次接受的数据也不一定是SIZE大小，而是返回的值大小的字节。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&amp;quot;Please input: &amp;quot;);
scanf(&amp;quot;%s&amp;quot;，buff);
send(sockfd，buff, strlen(buff), 0);
bzero(buff, sizeof(buff));
recv(sockfd, buff, BUFFSIZE-1， 0);
printf(&amp;quot;Recv: %s\n&amp;quot;， buff);
close(sockfd);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-搭建http服务器&#34;&gt;2. 搭建HTTP服务器&lt;/h2&gt;
&lt;p&gt;HTTP请求串其格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;方法名 URL 协议版本 //请求行
字段名:字段值 //消息报头
字段名:字段值 //消息报头
...
字段名:字段值 //消息报头
请求正文 //可选
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每一行都以&lt;code&gt;\r``\n&lt;/code&gt;结尾，表示一个换行。&lt;/p&gt;
&lt;p&gt;对应的就有一个叫做HTTP返回串的东西，这个也是有格式规定的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;协议版本 状态码 状态描述 //状态行
字段名:字段值 //消息报头
字段名:字段值 //消息报头
...
字段名:字段值 //消息报头
响应正文 //可选
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在代码中，我们可以在服务器端写一个函数用于在buff中写入这个返回串:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void
setResponse(char *buff)
{
    bzero(buff, sizeof(buff));
    strcat(buff, &amp;quot;HTTP/1.1 200 0K\r\n&amp;quot;);
    strcat(buff, &amp;quot;Connection: close\r\n&amp;quot;);
    strcat(buff, &amp;quot;\r\n&amp;quot;);
    strcat(buff, &amp;quot;Hello\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;curl&lt;/code&gt;指令可以发送一个HTTP请求(其实就是类似浏览器打开&amp;quot;http://192.168.19.12:16555/&amp;quot;的页面一样):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;curl -v &amp;quot;http://192.168.19.12:16555/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688545638564.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-压力测试&#34;&gt;3. 压力测试&lt;/h2&gt;
&lt;p&gt;服务器是HTTP服务器，故这个时候就可以直接使用Apache Bench压力测试工具了。&lt;/p&gt;
&lt;p&gt;由于这个工具的测试方式是模拟大量的HTTP请求，故无法适用于之前的裸socket服务器，所以只能测试现在的HTTP服务器。&lt;/p&gt;
&lt;p&gt;使用方法很简单，直接运行以下指令即可：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ab -c 1 -n 10000 &amp;quot;http://192.168.19.12:16555/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ab&lt;/code&gt;的原理：&lt;code&gt;ab&lt;/code&gt;命令会创建&lt;strong&gt;多个并发&lt;/strong&gt;访问线程，模拟多个访问者同时对某一URL地址进行访问。&lt;/p&gt;
&lt;p&gt;它的测试目标是基于URL的，因此，它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ab&lt;/code&gt;是一个命令行工具， ab命令对发出负载的计算机要求很低，它既不会占用很高CPU，也不会占用很多内存。但却会给目标服务器造成巨大的负载，其原理类似CC攻击。&lt;/p&gt;
&lt;p&gt;用法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ab [options] [http://]hostname[:port]/path
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-n m&lt;/code&gt; 本次测试发起的总请求数&lt;code&gt;m&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c n&lt;/code&gt; 一次产生的请求数(或并发数)&lt;code&gt;n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t n&lt;/code&gt; 测试所进行的最大秒数&lt;code&gt;n&lt;/code&gt;，默认没有时间限制。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt; 抛出异常继续执行测试任务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p file&lt;/code&gt; 包含了需要POST的数据的文件，使用方法是 &lt;code&gt;-p 111.txt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回结果比较重要的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Failed requests：失败请求数。&lt;/li&gt;
&lt;li&gt;Requests per second：每秒处理的请求数，也就是吞吐率。&lt;/li&gt;
&lt;li&gt;Transfer rate：传输速率，表示每秒收到多少的数据量。&lt;/li&gt;
&lt;li&gt;最下面的表：表示百分之xx的请求数的响应时间的分布，可以比较直观的看出请求响应时间分布。&lt;/li&gt;
&lt;/ul&gt;
">[C++项目] 简单的HTTP服务器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/1rRL-eO8e/"" data-c="
          &lt;p&gt;设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。&lt;/p&gt;
&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。&lt;/p&gt;
&lt;p&gt;这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1688119624428.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;单例模式&#34;&gt;单例模式&lt;/h2&gt;
&lt;p&gt;这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象，属于创建型模式。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;单例类只能有一个实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单例类必须自己创建自己的唯一实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单例类必须给所有其他对象提供这一实例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去&lt;code&gt;new&lt;/code&gt;，因为构造器是被&lt;code&gt;private&lt;/code&gt;修饰的，一般通过&lt;code&gt;getInstance()&lt;/code&gt;的方法来获取它们的实例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getInstance()&lt;/code&gt;的返回值是一个对象的引用，并不是一个新的实例，所以不要错误的理解成多个对象。&lt;/p&gt;
&lt;p&gt;一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见写法&lt;/strong&gt;：&lt;br&gt;
&lt;strong&gt;饿汉式&lt;/strong&gt;&lt;br&gt;
饿汉式单例模式是指&lt;strong&gt;在程序启动时就创建唯一实例&lt;/strong&gt;的单例模式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include&amp;lt;iostream&amp;gt;
using namespace std;

// 使用指针来在类内部定义存放实例的对象
class Singleton {
private:
    static Singleton* instance; // 静态成员变量，用于存储唯一实例的指针
    Singleton() {} // 私有构造函数，防止外部创建实例
public:
    static Singleton* getInstance() { // 必须得是静态成员函数，用于获取唯一实例的指针，因为不能与某一实例绑定
        return instance; // 直接返回唯一实例的指针
    }
};

// 类中的静态成员需要在类外初始化
Singleton* Singleton::instance = new Singleton(); // 在程序启动时创建唯一实例

int main() {
	Singleton* s1 = Singleton::getInstance(); // 获取唯一实例的指针
	Singleton* s2 = Singleton::getInstance(); // 再次获取唯一实例的指针
	if (s1 == s2) { // 判断两个指针是否相等，即是否为同一个实例
		cout &amp;lt;&amp;lt; &amp;quot;s1 and s2 are the same instance.&amp;quot; &amp;lt;&amp;lt; endl;
	}
	else {
		cout &amp;lt;&amp;lt; &amp;quot;s1 and s2 are different instances.&amp;quot; &amp;lt;&amp;lt; endl;
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;饿汉式单例模式的优点是实现简单，线程安全，不需要加锁等复杂操作。缺点是在程序启动时就创建实例，浪费内存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加锁的饱汉式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;mutex&amp;gt;

class Singleton {
private:
    static Singleton* instance; // 静态成员变量，用于存储唯一实例的指针
    static std::mutex mtx; // 静态成员变量，用于加锁
    Singleton() {} // 私有构造函数，防止外部创建实例
public:
    static Singleton* getInstance() { // 必须得是静态成员函数，用于获取唯一实例的指针，因为不能与某一实例绑定，由于函数为静态，被它访问的成员也都得是静态的
        std::lock_guard&amp;lt;std::mutex&amp;gt; lock(mtx); // 加锁
        if (instance == nullptr) { // 如果实例不存在，则创建一个新实例
            instance = new Singleton();
        }
        return instance; // 返回唯一实例的指针
    }
};

// 类中的静态成员需要在类外初始化
Singleton* Singleton::instance = NULL; 
mutex Singleton::mtx;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;饱汉式单例模式的优点是在第一次使用时才创建实例，避免了浪费系统资源的问题。缺点是在多线程环境下可能会出现多个线程同时调用&lt;code&gt;getInstance&lt;/code&gt;函数，导致创建多个实例的情况。为了保证线程安全，使用&lt;strong&gt;加锁&lt;/strong&gt;的方式来避免多个线程同时创建实例。&lt;/p&gt;
&lt;p&gt;这里使用&lt;code&gt;std::mutex&lt;/code&gt;来实现加锁，保证了在多线程环境下只有一个线程可以创建实例。在&lt;code&gt;getInstance&lt;/code&gt;函数中，我们使用了&lt;code&gt;std::lock_guard&lt;/code&gt;来自动加锁和解锁，避免了手动加锁和解锁的繁琐操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::lock_guard&lt;/code&gt;是一个RAII（Resource Acquisition Is Initialization）类，用于在作用域内自动获取和释放互斥锁。它可以确保在作用域结束时自动释放互斥锁，从而避免了手动释放锁的繁琐和容易出错的操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lock_guard&lt;/code&gt;是一个模板类，可以用于不同类型的互斥锁。&lt;code&gt;lock_guard&lt;/code&gt;的构造函数接受一个互斥锁的引用，并在构造函数中获取互斥锁。&lt;code&gt;lock_guard&lt;/code&gt;的析构函数会在作用域结束时自动释放互斥锁。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::lock_guard&lt;/code&gt;可以避免死锁的发生。由于&lt;code&gt;std::lock_guard&lt;/code&gt;在构造函数中获取互斥锁，因此可以确保在获取锁时不会发生死锁。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::lock_guard&lt;/code&gt;禁止拷贝和赋值操作，从而确保同一时刻只有一个&lt;code&gt;std::lock_guard&lt;/code&gt;对象可以持有互斥锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何时使用&lt;/strong&gt;：当您想控制实例数目，节省系统资源的时候。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键代码&lt;/strong&gt;：构造函数是私有的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何解决&lt;/strong&gt;：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免对资源的多重占用（比如写文件操作）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;没有接口，不能继承。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;观察者模式&#34;&gt;观察者模式&lt;/h2&gt;
&lt;p&gt;对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。观察者模式属于行为型模式。&lt;/p&gt;
&lt;p&gt;具体而言就是 观察者通过接口提供给被观察者通知消息的能力：当被观察者发生变化时，遍历所有对其的观察者，挨个调用接口通知。注意，如果顺序执行遍历，某一观察者错误会导致系统卡壳，一般采用异步方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见写法&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;


using namespace std;

class Observer { // 抽象观察者类
public:
	virtual void update() = 0; // 更新方法
};

class Subject { // 抽象主题类
private:
	vector&amp;lt;Observer*&amp;gt; observers; // 观察者列表
public:
	void attach(Observer* observer) { // 添加观察者
		observers.push_back(observer);
	}
	void detach(Observer* observer) { // 删除观察者
		for (auto it = observers.begin(); it != observers.end(); ++it) {
			if (*it == observer) {
				observers.erase(it);
				break;
			}
		}
	}
	void notify() { // 通知所有观察者
		for (auto observer : observers) {
			observer-&amp;gt;update();
		}
	}
};

class ConcreteObserver : public Observer { // 具体观察者类
private:
	string name;
public:
	void update() override { // 更新方法
		cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;quot; is notified.&amp;quot; &amp;lt;&amp;lt; endl;
	}
	ConcreteObserver(string a):name(a){}
};

int main() {
	Subject subject; // 创建主题对象
	ConcreteObserver observer1(&amp;quot;a&amp;quot;), observer2(&amp;quot;b&amp;quot;); // 创建观察者对象
	subject.attach(&amp;amp;observer1); // 添加观察者1
	subject.attach(&amp;amp;observer2); // 添加观察者2
	subject.notify(); // 通知所有观察者
	subject.detach(&amp;amp;observer2); // 删除观察者2
	subject.notify(); // 通知所有观察者
	return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;a is notified.
b is notified.
a is notified.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的示例中，我们定义了一个&lt;code&gt;Observer&lt;/code&gt;抽象观察者类和一个&lt;code&gt;Subject&lt;/code&gt;抽象主题类。&lt;code&gt;Observer&lt;/code&gt;类中定义了一个&lt;code&gt;update&lt;/code&gt;方法，用于更新观察者对象。&lt;code&gt;Subject&lt;/code&gt;类中定义了一个观察者列表，以及&lt;code&gt;attach&lt;/code&gt;、&lt;code&gt;detach&lt;/code&gt;和&lt;code&gt;notify&lt;/code&gt;三个方法，分别用于添加观察者、删除观察者和通知所有观察者。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;main&lt;/code&gt;函数中，我们创建了一个主题对象和两个观察者对象，并将观察者对象添加到主题对象的观察者列表中。然后，我们调用&lt;code&gt;notify&lt;/code&gt;方法通知所有观察者，并删除一个观察者对象，再次调用&lt;code&gt;notify&lt;/code&gt;方法通知所有观察者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键代码&lt;/strong&gt;：在抽象类里有一个数组用于存放观察者们。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;观察者和被观察者是抽象耦合的。&lt;/li&gt;
&lt;li&gt;可以建立一套触发机制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。&lt;/li&gt;
&lt;li&gt;如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。&lt;/li&gt;
&lt;li&gt;观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;装饰器模式&#34;&gt;装饰器模式&lt;/h2&gt;
&lt;p&gt;装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。&lt;/p&gt;
&lt;p&gt;这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。&lt;br&gt;
可以动态增加功能，动态撤销。就增加功能来说，装饰器模式相比生成子类更为灵活。&lt;/p&gt;
&lt;p&gt;一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。在不想增加很多子类的情况下扩展类，就可以使用装饰器模式。&lt;/p&gt;
&lt;p&gt;简单的说就是在继承类的内部定义一个基类对象，继承类中的方法通过基类对象调用基类方法，接着在此基础上扩展基类方法的功能。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

class Component { // 抽象组件类
public:
	virtual void operation() = 0; // 操作方法
};

class ConcreteComponent : public Component { // 具体组件类
public:
	void operation() override { // 实现操作方法
		cout &amp;lt;&amp;lt; &amp;quot;ConcreteComponent::operation&amp;quot; &amp;lt;&amp;lt; endl;
	}
};

class Decorator : public Component { // 抽象装饰器类
private:
	Component* component; // 持有组件对象的指针
public:
	Decorator(Component* component) { // 构造函数，传入组件对象的指针
		this-&amp;gt;component = component;
	}
	void operation() override { // 实现操作方法，调用组件对象的操作方法
		component-&amp;gt;operation();
	}
};

class ConcreteDecorator : public Decorator { // 具体装饰器类
public:
	ConcreteDecorator(Component* component) : Decorator(component) {} // 构造函数，传入组件对象的指针
	void operation() override { // 实现操作方法，调用组件对象的操作方法，并添加额外的功能
		Decorator::operation();
		cout &amp;lt;&amp;lt; &amp;quot;ConcreteDecorator::operation&amp;quot; &amp;lt;&amp;lt; endl;
	}
};

int main() {
	Component* component = new ConcreteComponent(); // 创建具体组件对象
	component-&amp;gt;operation(); // 调用具体组件对象的操作方法
	Component* decorator = new ConcreteDecorator(component); // 创建具体装饰器对象，传入具体组件对象的指针
	decorator-&amp;gt;operation(); // 调用具体装饰器对象的操作方法，实际上调用了具体组件对象的操作方法，并添加了额外的功能
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的示例中，我们定义了一个&lt;code&gt;Component&lt;/code&gt;抽象组件类和一个&lt;code&gt;ConcreteComponent&lt;/code&gt;具体组件类。&lt;code&gt;Component&lt;/code&gt;类中定义了一个操作方法，&lt;code&gt;ConcreteComponent&lt;/code&gt;类中实现了操作方法。&lt;/p&gt;
&lt;p&gt;然后，我们创建了一个&lt;code&gt;Decorator&lt;/code&gt;抽象装饰器类，它持有一个&lt;code&gt;Component&lt;/code&gt;组件对象的指针，并实现了操作方法，调用了组件对象的操作方法。接着，我们创建了一个&lt;code&gt;ConcreteDecorator&lt;/code&gt;具体装饰器类，它继承了&lt;code&gt;Decorator&lt;/code&gt;类，并在操作方法中调用了&lt;code&gt;Decorator&lt;/code&gt;类的操作方法，并添加了额外的功能。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;main&lt;/code&gt;函数中，我们创建了一个具体组件对象和一个具体装饰器对象，并将具体组件对象的指针传入具体装饰器对象的构造函数中。然后，我们调用具体组件对象的操作方法和具体装饰器对象的操作方法，实际上调用了具体组件对象的操作方法，并添加了额外的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键代码&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Component 类充当抽象角色，不应该具体实现。&lt;/li&gt;
&lt;li&gt;修饰类引用和继承 Component 类，具体扩展类重写父类方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：多层装饰比较复杂。&lt;/p&gt;
&lt;h2 id=&#34;适配器模式&#34;&gt;适配器模式&lt;/h2&gt;
&lt;p&gt;适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。&lt;/p&gt;
&lt;p&gt;这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。它将两种完全不同的事物联系到一起，就像现实生活中的变压器。&lt;/p&gt;
&lt;p&gt;适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。主要解决在软件系统中，常常要将一些&amp;quot;现存的对象&amp;quot;放到新的环境中，而新环境要求的接口是现对象不能满足的。&lt;/p&gt;
&lt;p&gt;JAVA 中的 jdbc（ Java 数据库连接）就是适配器模式的实例。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

class Target { // 目标接口
public:
	virtual void request() = 0; // 请求方法
};

class Adaptee { // 源接口
public:
	void specificRequest() { // 特殊请求方法
		cout &amp;lt;&amp;lt; &amp;quot;源接口特殊请求方法&amp;quot; &amp;lt;&amp;lt; endl;
	}
};

class Adapter : public Target { // 适配器类
private:
	Adaptee* adaptee; // 持有源接口的指针
public:
	Adapter(Adaptee* adaptee) { // 构造函数，传入源接口的指针
		this-&amp;gt;adaptee = adaptee;
	}
	void request() override { // 请求方法，调用源接口的特殊请求方法
		adaptee-&amp;gt;specificRequest();
	}
};

int main() {
	Adaptee adaptee; // 创建源接口对象
	Adapter adapter(&amp;amp;adaptee); // 创建适配器对象，传入源接口的指针
	adapter.request(); // 调用目标接口的请求方法，实际上调用了源接口的特殊请求方法
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的示例中，我们定义了一个&lt;code&gt;Target&lt;/code&gt;目标接口和一个&lt;code&gt;Adaptee&lt;/code&gt;源接口。&lt;code&gt;Target&lt;/code&gt;接口中定义了一个请求方法，&lt;code&gt;Adaptee&lt;/code&gt;接口中定义了一个特殊请求方法。&lt;/p&gt;
&lt;p&gt;然后，我们创建了一个&lt;code&gt;Adapter&lt;/code&gt;适配器类，它继承了&lt;code&gt;Target&lt;/code&gt;接口，并持有一个&lt;code&gt;Adaptee&lt;/code&gt;接口的指针。在&lt;code&gt;Adapter&lt;/code&gt;类中，我们实现了请求方法，调用了源接口的特殊请求方法。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;main&lt;/code&gt;函数中，我们创建了一个源接口对象和一个适配器对象，并将源接口的指针传入适配器对象的构造函数中。然后，我们调用目标接口的请求方法，实际上调用了适配器对象的请求方法，进而调用了源接口的特殊请求方法。&lt;/p&gt;
&lt;p&gt;实际上完成了从目标接口到源接口的转换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何解决&lt;/strong&gt;：继承或依赖（推荐）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键代码&lt;/strong&gt;：适配器类继承或依赖已有的对象，然后在适配器类中实现想要的目标接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可以让任何两个没有关联的类一起运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提高了类的复用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;增加了类的透明度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;灵活性好。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;工厂模式&#34;&gt;工厂模式&lt;/h2&gt;
&lt;p&gt;工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;/p&gt;
&lt;p&gt;在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。&lt;/p&gt;
&lt;p&gt;定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。&lt;/p&gt;
&lt;p&gt;具体而言, 先定义一个抽象的接口表示抽象产品，定义多个抽象接口的实现类表示具体产品，定义一个工厂类用来实例化抽象的接口表示生产产品&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

class Product { // 抽象产品类
public:
    virtual void use() = 0; // 使用方法
};

class ConcreteProductA : public Product { // 具体产品类A
public:
    void use() override { // 实现使用方法
        cout &amp;lt;&amp;lt; &amp;quot;ConcreteProductA::use&amp;quot; &amp;lt;&amp;lt; endl;
    }
};

class ConcreteProductB : public Product { // 具体产品类B
public:
    void use() override { // 实现使用方法
        cout &amp;lt;&amp;lt; &amp;quot;ConcreteProductB::use&amp;quot; &amp;lt;&amp;lt; endl;
    }
};

class Factory { // 抽象工厂类
public:
    virtual Product* createProduct() = 0; // 创建产品方法
};

class ConcreteFactoryA : public Factory { // 具体工厂类A
public:
    Product* createProduct() override { // 实现创建产品方法，返回具体产品类A的对象
        return new ConcreteProductA();
    }
};

class ConcreteFactoryB : public Factory { // 具体工厂类B
public:
    Product* createProduct() override { // 实现创建产品方法，返回具体产品类B的对象
        return new ConcreteProductB();
    }
};

int main() {
    Factory* factoryA = new ConcreteFactoryA(); // 创建具体工厂类A的对象
    Product* productA = factoryA-&amp;gt;createProduct(); // 使用具体工厂类A的对象创建具体产品类A的对象
    productA-&amp;gt;use(); // 调用具体产品类A的使用方法
    Factory* factoryB = new ConcreteFactoryB(); // 创建具体工厂类B的对象
    Product* productB = factoryB-&amp;gt;createProduct(); // 使用具体工厂类B的对象创建具体产品类B的对象
    productB-&amp;gt;use(); // 调用具体产品类B的使用方法
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的示例中，我们定义了一个&lt;code&gt;Product&lt;/code&gt;抽象产品类和两个&lt;code&gt;ConcreteProduct&lt;/code&gt;具体产品类。&lt;code&gt;Product&lt;/code&gt;类中定义了一个使用方法，&lt;code&gt;ConcreteProduct&lt;/code&gt;类中实现了使用方法。&lt;/p&gt;
&lt;p&gt;然后，我们创建了一个&lt;code&gt;Factory&lt;/code&gt;抽象工厂类和两个&lt;code&gt;ConcreteFactory&lt;/code&gt;具体工厂类。&lt;code&gt;Factory&lt;/code&gt;类中定义了一个创建产品方法，&lt;code&gt;ConcreteFactory&lt;/code&gt;类中实现了创建产品方法，返回具体产品类的对象。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;main&lt;/code&gt;函数中，我们创建了一个具体工厂类&lt;code&gt;A&lt;/code&gt;的对象和一个具体产品类&lt;code&gt;A&lt;/code&gt;的对象，并调用具体产品类&lt;code&gt;A&lt;/code&gt;的使用方法。然后，我们创建了一个具体工厂类&lt;code&gt;B&lt;/code&gt;的对象和一个具体产品类&lt;code&gt;B&lt;/code&gt;的对象，并调用具体产品类&lt;code&gt;B&lt;/code&gt;的使用方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键代码&lt;/strong&gt;：创建过程在其子类执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用实例&lt;/strong&gt;：Hibernate 换数据库只需换方言和驱动就可以&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要解决&lt;/strong&gt;：主要解决接口选择的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何时使用&lt;/strong&gt;：我们明确地计划不同条件下创建不同实例时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何解决&lt;/strong&gt;：让其子类实现工厂接口，返回的也是一个抽象的产品。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一个调用者想创建一个对象，只要知道其名称就可以了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;屏蔽产品的具体实现，调用者只关心产品的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。&lt;/p&gt;
&lt;p&gt;作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 &lt;code&gt;new&lt;/code&gt; 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。&lt;/p&gt;
&lt;h2 id=&#34;抽象工厂模式&#34;&gt;抽象工厂模式&lt;/h2&gt;
&lt;p&gt;抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;/p&gt;
&lt;p&gt;有四个角色，抽象工厂模式，具体工厂模式，抽象产品模式，具体产品模式。不再是由一个工厂类去实例化具体的产品，而是由抽象工厂的子类去实例化产品。可以理解为是工厂类的工厂类。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

class ProductA { // 抽象产品A类
public:
	virtual void use() = 0; // 使用方法
};

class ConcreteProductA1 : public ProductA { // 具体产品A1类
public:
	void use() override { // 实现使用方法
		cout &amp;lt;&amp;lt; &amp;quot;ConcreteProductA1::use&amp;quot; &amp;lt;&amp;lt; endl;
	}
};

class ConcreteProductA2 : public ProductA { // 具体产品A2类
public:
	void use() override { // 实现使用方法
		cout &amp;lt;&amp;lt; &amp;quot;ConcreteProductA2::use&amp;quot; &amp;lt;&amp;lt; endl;
	}
};

class ProductB { // 抽象产品B类
public:
	virtual void eat() = 0; // 吃方法
};

class ConcreteProductB1 : public ProductB { // 具体产品B1类
public:
	void eat() override { // 实现吃方法
		cout &amp;lt;&amp;lt; &amp;quot;ConcreteProductB1::eat&amp;quot; &amp;lt;&amp;lt; endl;
	}
};

class ConcreteProductB2 : public ProductB { // 具体产品B2类
public:
	void eat() override { // 实现吃方法
		cout &amp;lt;&amp;lt; &amp;quot;ConcreteProductB2::eat&amp;quot; &amp;lt;&amp;lt; endl;
	}
};

class Factory { // 抽象工厂类
public:
	virtual ProductA* createProductA() = 0; // 创建产品A方法
	virtual ProductB* createProductB() = 0; // 创建产品B方法
};

class ConcreteFactory1 : public Factory { // 具体工厂1类
public:
	ProductA* createProductA() override { // 实现创建产品A方法，返回具体产品A1类的对象
		return new ConcreteProductA1();
	}
	ProductB* createProductB() override { // 实现创建产品B方法，返回具体产品B1类的对象
		return new ConcreteProductB1();
	}
};

class ConcreteFactory2 : public Factory { // 具体工厂2类
public:
	ProductA* createProductA() override { // 实现创建产品A方法，返回具体产品A2类的对象
		return new ConcreteProductA2();
	}
	ProductB* createProductB() override { // 实现创建产品B方法，返回具体产品B2类的对象
		return new ConcreteProductB2();
	}
};

int main() {
	Factory* factory1 = new ConcreteFactory1(); // 创建具体工厂1类的对象
	ProductA* productA1 = factory1-&amp;gt;createProductA(); // 使用具体工厂1类的对象创建具体产品A1类的对象
	productA1-&amp;gt;use(); // 调用具体产品A1类的使用方法
	ProductB* productB1 = factory1-&amp;gt;createProductB(); // 使用具体工厂1类的对象创建具体产品B1类的对象
	productB1-&amp;gt;eat(); // 调用具体产品B1类的吃方法
	delete productA1; // 释放具体产品A1类的对象
	delete productB1; // 释放具体产品B1类的对象
	Factory* factory2 = new ConcreteFactory2(); // 创建具体工厂2类的对象
	ProductA* productA2 = factory2-&amp;gt;createProductA(); // 使用具体工厂2类的对象创建具体产品A2类的对象
	productA2-&amp;gt;use(); // 调用具体产品A2类的使用方法
	ProductB* productB2 = factory2-&amp;gt;createProductB(); // 使用具体工厂2类的对象创建具体产品B2类的对象
	productB2-&amp;gt;eat(); // 调用具体产品B2类的吃方法
	delete productA2; // 释放具体产品A2类的对象
	delete productB2; // 释放具体产品B2类的对象
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的示例中，我们定义了两个抽象产品类&lt;code&gt;ProductA&lt;/code&gt;和&lt;code&gt;ProductB&lt;/code&gt;，以及四个具体产品类&lt;code&gt;ConcreteProductA1&lt;/code&gt;、&lt;code&gt;ConcreteProductA2&lt;/code&gt;、&lt;code&gt;ConcreteProductB1&lt;/code&gt;和&lt;code&gt;ConcreteProductB2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ProductA&lt;/code&gt;类中定义了一个使用方法，&lt;code&gt;ProductB&lt;/code&gt;类中定义了一个吃方法，&lt;code&gt;ConcreteProduct&lt;/code&gt;类中实现了使用方法和吃方法。&lt;/p&gt;
&lt;p&gt;然后，我们创建了一个抽象工厂类&lt;code&gt;Factory&lt;/code&gt;和两个具体工厂类&lt;code&gt;ConcreteFactory1&lt;/code&gt;和&lt;code&gt;ConcreteFactory2&lt;/code&gt;。&lt;code&gt;Factory&lt;/code&gt;类中定义了一个创建产品&lt;code&gt;A&lt;/code&gt;方法和一个创建产品&lt;code&gt;B&lt;/code&gt;方法，&lt;code&gt;ConcreteFactory&lt;/code&gt;类中实现了创建产品&lt;code&gt;A&lt;/code&gt;方法和创建产品&lt;code&gt;B&lt;/code&gt;方法，返回具体产品类的对象。&lt;/p&gt;
&lt;p&gt;在main函数中，我们创建了一个&lt;code&gt;具体工厂1&lt;/code&gt;类的对象和一个具体产品&lt;code&gt;A1&lt;/code&gt;类的对象，并调用具体产品&lt;code&gt;A1&lt;/code&gt;类的使用方法，创建了一个具体产品&lt;code&gt;B1&lt;/code&gt;类的对象，并调用具体产品&lt;code&gt;B1&lt;/code&gt;类的吃方法。&lt;/p&gt;
&lt;p&gt;然后，我们创建了一个&lt;code&gt;具体工厂2&lt;/code&gt;类的对象和一个具体产品&lt;code&gt;A2&lt;/code&gt;类的对象，并调用具体产品&lt;code&gt;A2&lt;/code&gt;类的使用方法，创建了一个具体产品&lt;code&gt;B2&lt;/code&gt;类的对象，并调用具体产品&lt;code&gt;B2&lt;/code&gt;类的吃方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何解决&lt;/strong&gt;：在一个产品族里面，定义多个产品。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键代码&lt;/strong&gt;：在一个工厂里聚合多个同类产品。&lt;/p&gt;
&lt;h2 id=&#34;代理模式proxy&#34;&gt;代理模式（proxy）&lt;/h2&gt;
&lt;p&gt;在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。&lt;/p&gt;
&lt;p&gt;在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;p&gt;具体而言就是 在新类中创建原有类的私有对象 从而封装对该类的访问 这样就可以对访问加以控制。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

class Subject { // 抽象主题类
public:
	virtual void request() = 0; // 请求方法
};

class RealSubject : public Subject { // 真实主题类
public:
	void request() override { // 实现请求方法
		cout &amp;lt;&amp;lt; &amp;quot;请求成功&amp;quot; &amp;lt;&amp;lt; endl;
	}
};

class Proxy : public Subject { // 代理类
private:
	RealSubject* realSubject; // 持有真实主题对象的指针
	string name;
public:
	Proxy(string sname):name(sname){ // 构造函数，创建真实主题对象的指针
		realSubject = new RealSubject();
	}
	void request() override { // 实现请求方法，调用真实主题对象的请求方法
		if (name == &amp;quot;VIP&amp;quot;) {
			realSubject-&amp;gt;request();
		}
		else cout &amp;lt;&amp;lt; &amp;quot;无权访问&amp;quot; &amp;lt;&amp;lt; endl;
	}
};

int main() {
	Proxy* proxy1 = new Proxy(&amp;quot;cilet&amp;quot;); // 创建代理对象
	proxy1-&amp;gt;request(); // 调用代理对象的请求方法，实际上调用了真实主题对象的请求方法
	Proxy* proxy2 = new Proxy(&amp;quot;VIP&amp;quot;); // 创建代理对象
	proxy2-&amp;gt;request(); // 调用代理对象的请求方法，实际上调用了真实主题对象的请求方法
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的示例中，我们定义了一个&lt;code&gt;Subject&lt;/code&gt;抽象主题类和一个&lt;code&gt;RealSubject&lt;/code&gt;真实主题类。&lt;code&gt;Subject&lt;/code&gt;类中定义了一个请求方法，&lt;code&gt;RealSubject&lt;/code&gt;类中实现了请求方法。&lt;/p&gt;
&lt;p&gt;然后，我们创建了一个&lt;code&gt;Proxy&lt;/code&gt;代理类，它持有&lt;code&gt;RealSubject&lt;/code&gt;真实主题对象的指针，并实现了请求方法。&lt;code&gt;Proxy&lt;/code&gt;代理类添加了对真实主题对象的访问控制，只有符合条件的对象才能调用真实主题对象的请求方法。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;main&lt;/code&gt;函数中，我们创建了两个代理对象，并尝试调用了代理对象的请求方法，由于代理类进行了访问控制，实际上只有第二个对象调用了真实主题对象的请求方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何解决&lt;/strong&gt;：增加中间层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键代码&lt;/strong&gt;：实现与被代理类组合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用实例&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Windows 里面的快捷方式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;职责清晰。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高扩展性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;智能化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。&lt;/li&gt;
&lt;li&gt;实现代理模式需要额外的工作，有些代理模式的实现非常复杂。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;享元模式&#34;&gt;享元模式&lt;/h2&gt;
&lt;p&gt;享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。&lt;/p&gt;
&lt;p&gt;享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见写法&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

using namespace std;

class Flyweight { // 抽象享元类
public:
	virtual void operation() = 0; // 操作方法
};

class ConcreteFlyweight : public Flyweight { // 具体享元类
private:
	char c; // 内部状态
public:
	ConcreteFlyweight(char c) : c(c) {
		cout &amp;lt;&amp;lt; &amp;quot;构造对象 &amp;quot;&amp;lt;&amp;lt;c&amp;lt;&amp;lt;endl;
	} // 构造函数，初始化内部状态
	void operation() override { // 实现操作方法，输出内部状态
		cout &amp;lt;&amp;lt; &amp;quot;ConcreteFlyweight::operation &amp;quot; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;
	}
};

class FlyweightFactory { // 享元工厂类
private:
	map&amp;lt;char, Flyweight*&amp;gt; flyweights; // 持有享元对象的指针的map
public:
	Flyweight* getFlyweight(char c) { // 获取享元对象的方法
		if (flyweights.find(c) == flyweights.end()) { // 如果map中没有该对象，则创建一个新的对象并添加到map中
			flyweights[c] = new ConcreteFlyweight(c);
		}
		return flyweights[c]; // 返回map中的对象
	}
};

int main() {
	FlyweightFactory* factory = new FlyweightFactory(); // 创建享元工厂对象
	Flyweight* flyweight1 = factory-&amp;gt;getFlyweight(&#39;a&#39;); // 获取享元对象a
	flyweight1-&amp;gt;operation(); // 调用享元对象a的操作方法
	Flyweight* flyweight2 = factory-&amp;gt;getFlyweight(&#39;b&#39;); // 获取享元对象b
	flyweight2-&amp;gt;operation(); // 调用享元对象b的操作方法
	Flyweight* flyweight3 = factory-&amp;gt;getFlyweight(&#39;a&#39;); // 再次获取享元对象a
	flyweight3-&amp;gt;operation(); // 调用享元对象a的操作方法
	delete factory; // 释放享元工厂对象
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的示例中，我们定义了一个&lt;code&gt;Flyweight&lt;/code&gt;抽象享元类和一个&lt;code&gt;ConcreteFlyweight&lt;/code&gt;具体享元类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Flyweight&lt;/code&gt;类中定义了一个操作方法，&lt;code&gt;ConcreteFlyweight&lt;/code&gt;类中实现了操作方法，并添加了一个内部状态&lt;code&gt;c&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后，我们创建了一个&lt;code&gt;FlyweightFactory&lt;/code&gt;享元工厂类，它持有享元对象的指针的&lt;code&gt;map&lt;/code&gt;，并实现了获取享元对象的方法。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;main&lt;/code&gt;函数中，我们创建了一个享元工厂对象，并使用它来获取享元对象&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;，并调用它们的操作方法。我们还再次获取了享元对象&lt;code&gt;a&lt;/code&gt;，并调用它的操作方法。由于享元对象&lt;code&gt;a&lt;/code&gt;已经存在于map中，因此不需要创建新的对象，而是直接返回&lt;code&gt;map&lt;/code&gt;中的对象。&lt;/p&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;构造对象 a
ConcreteFlyweight::operation a
构造对象 b
ConcreteFlyweight::operation b
ConcreteFlyweight::operation a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如何解决&lt;/strong&gt;：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键代码&lt;/strong&gt;：用 HashMap 存储这些对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用实例&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。&lt;/li&gt;
&lt;li&gt;数据库的数据池。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：大大减少对象的创建，降低系统的内存，使效率提高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。&lt;/p&gt;
&lt;h2 id=&#34;相关面试题&#34;&gt;相关面试题&lt;/h2&gt;
&lt;h3 id=&#34;1-对象复用的了解零拷贝的了解&#34;&gt;1. 对象复用的了解，零拷贝的了解&lt;/h3&gt;
&lt;h4 id=&#34;对象复用&#34;&gt;对象复用&lt;/h4&gt;
&lt;p&gt;对象复用其本质是一种设计模式：Flyweight享元模式。&lt;/p&gt;
&lt;p&gt;通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。&lt;/p&gt;
&lt;h4 id=&#34;零拷贝&#34;&gt;零拷贝&lt;/h4&gt;
&lt;p&gt;零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。&lt;/p&gt;
&lt;p&gt;零拷贝技术可以减少数据拷贝和共享总线操作的次数。&lt;/p&gt;
&lt;p&gt;在C++中，&lt;code&gt;vector&lt;/code&gt;的一个成员函数&lt;code&gt;emplace_back()&lt;/code&gt;很好地体现了零拷贝技术，它跟&lt;code&gt;push_back()&lt;/code&gt;函数一样可以将一个元素插入容器尾部，区别在于：使用&lt;code&gt;push_back()&lt;/code&gt;函数需要调用拷贝构造函数和转移构造函数，而使用&lt;code&gt;emplace_back()&lt;/code&gt;插入的元素原地构造，不需要触发拷贝构造和转移构造，效率更高&lt;/p&gt;
&lt;h3 id=&#34;2-介绍面向对象的三大特性并且举例说明&#34;&gt;2. 介绍面向对象的三大特性，并且举例说明&lt;/h3&gt;
&lt;p&gt;三大特性：继承、封装和多态&lt;/p&gt;
&lt;h4 id=&#34;1继承&#34;&gt;（1）继承&lt;/h4&gt;
&lt;p&gt;让某种类型对象获得另一个类型对象的属性和方法。&lt;/p&gt;
&lt;p&gt;它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展&lt;/p&gt;
&lt;p&gt;常见的继承有三种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实现继承：指使用基类的属性和方法而无需额外编码的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（C++里好像不怎么用）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉、走路等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法&lt;/p&gt;
&lt;h4 id=&#34;2封装&#34;&gt;（2）封装&lt;/h4&gt;
&lt;p&gt;数据和代码捆绑在一起，避免外界干扰和不确定性访问。&lt;/p&gt;
&lt;p&gt;封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。&lt;/p&gt;
&lt;h4 id=&#34;3多态&#34;&gt;（3）多态&lt;/h4&gt;
&lt;p&gt;同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。&lt;/p&gt;
&lt;p&gt;多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单一句话：允许将子类类型的指针赋值给父类类型的指针&lt;/p&gt;
&lt;p&gt;实现多态有两种方式：&lt;strong&gt;覆盖（override）&lt;/strong&gt;，&lt;strong&gt;重载（overload）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;覆盖&lt;/strong&gt;：是指子类重新定义父类的虚函数的做法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重载&lt;/strong&gt;：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。例如：基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">常见的设计模式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/5aIGR-NPI/"" data-c="
          &lt;h2 id=&#34;图&#34;&gt;图&lt;/h2&gt;
&lt;p&gt;在数据结构中，图（Graph）是由一组节点和一组边组成的数据结构。节点表示图中的元素，边表示节点之间的关系。图可以用于表示各种实际问题，如社交网络、路线规划、电路设计等。&lt;/p&gt;
&lt;p&gt;图可以分为有向图和无向图两种类型。有向图中的边是有方向的，表示从一个节点到另一个节点的单向关系；无向图中的边是无方向的，表示两个节点之间的双向关系。&lt;/p&gt;
&lt;p&gt;图中的节点可以有权值，表示节点之间的距离或代价。有权图可以用于表示各种实际问题，如最短路径、最小生成树等。&lt;/p&gt;
&lt;p&gt;图可以用多种方式来表示，如邻接矩阵、邻接表等。&lt;/p&gt;
&lt;h3 id=&#34;邻接矩阵&#34;&gt;邻接矩阵&lt;/h3&gt;
&lt;p&gt;邻接矩阵是一种二维数组，用于表示节点之间的关系。邻接矩阵的行和列分别表示图中的节点，矩阵中的元素表示节点之间的边。&lt;/p&gt;
&lt;p&gt;在邻接矩阵中，如果节点i和节点j之间有边相连，则矩阵中的第i行第j列元素为1；否则，该元素为0。如果图是有权图，则矩阵中的元素可以表示边的权值。&lt;/p&gt;
&lt;p&gt;邻接矩阵的优点是可以快速地判断两个节点之间是否有边相连，以及边的权值。&lt;/p&gt;
&lt;p&gt;邻接矩阵的缺点是空间复杂度较高，需要存储所有节点之间的关系，即使节点之间没有边相连。因此，邻接矩阵不适用于表示稀疏图，即节点之间的边比较少的图。&lt;/p&gt;
&lt;h3 id=&#34;邻接表&#34;&gt;邻接表&lt;/h3&gt;
&lt;p&gt;邻接表是一种用于表示图的数据结构，它是由一组链表和一组节点组成的。每个节点表示图中的一个元素，每个链表表示一个节点的邻居节点。&lt;/p&gt;
&lt;p&gt;在邻接表中，每个节点包含两个部分：一个是节点本身的信息，如节点的编号、权值等；另一个是指向邻居节点的指针。每个链表表示一个节点的邻居节点，链表中的每个元素表示一个邻居节点，包含两个部分：一个是邻居节点的信息，如节点的编号、权值等；另一个是指向下一个邻居节点的指针。&lt;/p&gt;
&lt;p&gt;邻接表的优点是可以用较少的空间来表示稀疏图，即节点之间的边比较少的图。此外，邻接表可以快速地访问一个节点的邻居节点，以及判断两个节点之间是否有边相连。&lt;/p&gt;
&lt;p&gt;邻接表的缺点是无法快速地判断两个节点之间的边的权值。&lt;/p&gt;
&lt;h2 id=&#34;图中的最短距离&#34;&gt;图中的最短距离&lt;/h2&gt;
&lt;h3 id=&#34;求图中任意节点的距离&#34;&gt;求图中任意节点的距离&lt;/h3&gt;
&lt;p&gt;弗洛伊德算法（Floyd Algorithm），也称为插点法，是一种用于求解最短路径的动态规划算法。该算法可以在有向图或无向图中，计算任意两个节点之间的最短路径。&lt;/p&gt;
&lt;p&gt;弗洛伊德算法的基本思想是，通过不断地插入中间节点，逐步缩小两个节点之间的距离，直到找到最短路径。具体来说，算法的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始化距离矩阵D，其中&lt;code&gt;D[i][j]&lt;/code&gt;表示节点&lt;code&gt;i&lt;/code&gt;到节点&lt;code&gt;j&lt;/code&gt;的距离。如果节点&lt;code&gt;i&lt;/code&gt;和节点&lt;code&gt;j&lt;/code&gt;之间有边相连，则&lt;code&gt;D[i][j]&lt;/code&gt;为边的权值；否则，&lt;code&gt;D[i][j]&lt;/code&gt;为无穷大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于每个中间节点&lt;code&gt;k&lt;/code&gt;，依次更新距离矩阵&lt;code&gt;D&lt;/code&gt;。具体来说，对于每对节点&lt;code&gt;i&lt;/code&gt;和节点&lt;code&gt;j&lt;/code&gt;，如果从节点&lt;code&gt;i&lt;/code&gt;到节点&lt;code&gt;j&lt;/code&gt;经过中间节点&lt;code&gt;k&lt;/code&gt;的路径比直接从节点&lt;code&gt;i&lt;/code&gt;到节点&lt;code&gt;j&lt;/code&gt;的路径更短，则更新D&lt;code&gt;[i][j]&lt;/code&gt;为更短的路径长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重复步骤2，直到所有中间节点都被考虑过为止。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最终得到的距离矩阵D即为任意两个节点之间的最短路径。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;弗洛伊德算法的时间复杂度为&lt;code&gt;O(n^3)&lt;/code&gt;，其中&lt;code&gt;n&lt;/code&gt;为节点数。&lt;/p&gt;
&lt;p&gt;该算法的优点是&lt;strong&gt;可以处理带负权边的图&lt;/strong&gt;，缺点是&lt;strong&gt;空间复杂度较高&lt;/strong&gt;，需要存储距离矩阵。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688117971308.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;求单源最短路径&#34;&gt;求单源最短路径&lt;/h3&gt;
&lt;p&gt;Dijkstra算法是一种用于求解最短路径的贪心算法，可以在有向图或无向图中，计算一个节点到其他所有节点的最短路径。&lt;/p&gt;
&lt;p&gt;该算法的基本思想是，从起点开始，依次计算每个节点到起点的距离，并选择距离最短的节点作为下一个起点，直到所有节点都被考虑过为止。算法的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过Dijkstra计算图G中的最短路径时，需要指定一个起点&lt;code&gt;D&lt;/code&gt;(即从顶点&lt;code&gt;D&lt;/code&gt;开始计算)。&lt;/li&gt;
&lt;li&gt;此外，引进两个数组&lt;code&gt;S&lt;/code&gt;和&lt;code&gt;U&lt;/code&gt;。&lt;code&gt;S&lt;/code&gt;的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点&lt;code&gt;D&lt;/code&gt;的距离)。&lt;/li&gt;
&lt;li&gt;初始时，数组&lt;code&gt;S&lt;/code&gt;中只有起点&lt;code&gt;D&lt;/code&gt;；数组&lt;code&gt;U&lt;/code&gt;中是除起点D之外的顶点，并且数组&lt;code&gt;U&lt;/code&gt;中记录各顶点到起点&lt;code&gt;D&lt;/code&gt;的距离。如果顶点与起点&lt;code&gt;D&lt;/code&gt;不相邻，距离为无穷大。&lt;/li&gt;
&lt;li&gt;然后，从数组&lt;code&gt;U&lt;/code&gt;中找出路径最短的顶点&lt;code&gt;K&lt;/code&gt;，并将其加入到数组&lt;code&gt;S&lt;/code&gt;中；同时，从数组&lt;code&gt;U&lt;/code&gt;中移除顶点&lt;code&gt;K&lt;/code&gt;。接着，更新数组&lt;code&gt;U&lt;/code&gt;中的各顶点到起点&lt;code&gt;D&lt;/code&gt;的距离。&lt;/li&gt;
&lt;li&gt;重复第4步操作，直到遍历完所有顶点&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688117976678.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
">[数据结构] 图与图上的算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/2Qd1kuN6D/"" data-c="
          &lt;h2 id=&#34;b树&#34;&gt;B树&lt;/h2&gt;
&lt;p&gt;B 树又叫平衡多路查找树。B树是一种自平衡树，是AVL树的一般化，它维护有序数据并允许以对数时间进行搜索，顺序访问，插入和删除。&lt;/p&gt;
&lt;p&gt;与AVL树不同的是，B树非常适合读取和写入相对较大的数据块（如光盘）的存储系统。它通常用于数据库和文件系统。&lt;/p&gt;
&lt;p&gt;一颗&lt;code&gt;m&lt;/code&gt;阶的B树满足如下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个节点最多只有&lt;code&gt;m&lt;/code&gt;个子节点。&lt;/li&gt;
&lt;li&gt;除根节点外，每个非叶子节点具有至少有 &lt;code&gt;m/2&lt;/code&gt;（向下取整）个子节点。&lt;/li&gt;
&lt;li&gt;非叶子节点的根节点至少有两个子节点（不然就变成单支了）。&lt;/li&gt;
&lt;li&gt;有k颗子树的非叶节点有&lt;code&gt;k-1&lt;/code&gt;个键，键按照递增顺序排列。&lt;/li&gt;
&lt;li&gt;叶节点都在同一层中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意: &lt;strong&gt;B树的叶子节点指的是最下面一层的空节点&lt;/strong&gt;，代表&lt;strong&gt;查找失败的情况&lt;/strong&gt;，不计算在层高里，属于外部节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B树的阶&lt;/strong&gt;： B树中节点的子节点数目的最大值&lt;br&gt;
&lt;strong&gt;内部节点&lt;/strong&gt;：除叶子节点和根节点之外的所有节点，即拥有父节点和子节点的节点。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688116896508.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;容易知道 在具有n个关键字的B树中 具有n+1种查找失败的情况 也就是查找到任意两个相邻关键字之间的情况&lt;/p&gt;
&lt;p&gt;因此 在具有n个关键字的B树中 叶子节点有n+1个&lt;/p&gt;
&lt;p&gt;由此可以推导得到具有n个关键字的B树的最大高度和最小高度&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688116901538.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;b树的插入&#34;&gt;B树的插入&lt;/h3&gt;
&lt;p&gt;针对m阶高度h的B树，插入一个元素时，首先在B树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若该节点元素个数小于m-1，直接插入；&lt;/li&gt;
&lt;li&gt;若该节点元素个数等于m-1，引起节点分裂；以该节点中间元素为分界，取中间元素（偶数个数，中间两个随机选取）插入到父节点中；&lt;/li&gt;
&lt;li&gt;重复上面动作，直到所有节点符合B树的规则；最坏的情况一直分裂到根节点，生成新的根节点，高度增加1。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以一颗5阶B树的插入为例&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688116908088.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;b树的删除&#34;&gt;B树的删除&lt;/h3&gt;
&lt;p&gt;首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除；删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；如果没有，直接删除。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某结点中元素数目小于（m/2）, (m/2)向下取整，则需要看其某相邻兄弟结点是否丰满；&lt;br&gt;
如果丰满（结点中元素个数大于(m/2)），则向父节点借一个元素来满足条件；&lt;/li&gt;
&lt;li&gt;如果其相邻兄弟都不丰满，即其结点数目等于(m/2)，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以5阶B树为例&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688116916798.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688116920468.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;b树-2&#34;&gt;B+树&lt;/h2&gt;
&lt;p&gt;B+树是应文件系统所需而产生的B树的变形树&lt;br&gt;
一颗m阶的B+树满足如下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个节点最多只有m个子节点。&lt;/li&gt;
&lt;li&gt;除根节点外，每个非叶子节点具有至少有 m/2（向下取整）个子节点。&lt;/li&gt;
&lt;li&gt;非叶子节点的根节点至少有两个子节点。&lt;/li&gt;
&lt;li&gt;有k颗子树的非叶节点有k个键，键按照递增顺序排列。&lt;/li&gt;
&lt;li&gt;叶节点都在同一层中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;b树与b树的区别&#34;&gt;B树与B+树的区别&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;B+树&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;B树&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有m颗子树的节点中含有m个关键码&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有m颗子树的节点中含有m-1个关键码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;所有的叶子结点中包含了完整的索引信息，包括指向含有这些关键字记录的指针，中间节点每个元素不保存数据，只用来索引&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;B树中非叶子节点的关键码与叶子结点的关键码均不重复，它们共同构成全部的索引信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;所有的非叶子节点可以看成是高层索引，结点中仅含有其子 树根结点中最大(或最小)关键字&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;B树的非叶子节点包含需要查找的有效信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;b树的检索&#34;&gt;B+树的检索&lt;/h3&gt;
&lt;p&gt;在B+树中检索关键码key的方法与B树的检索方式相似，但若在内部节点中找到检索的关键码时，检索并不会结束，要继续找到B+树的叶子结点为止。&lt;/p&gt;
&lt;h3 id=&#34;b树的插入-2&#34;&gt;B+树的插入&lt;/h3&gt;
&lt;p&gt;与B树的插入操作相似，总是插到叶子结点上。&lt;/p&gt;
&lt;p&gt;当叶节点中原关键码的个数等于m时，该节点分裂成两个节点，分别使关键码的个数为 (m+1)/2 （向上取整）和 (m+1)/2 （向下取整）。&lt;/p&gt;
&lt;h3 id=&#34;b树的删除-2&#34;&gt;B+树的删除&lt;/h3&gt;
&lt;p&gt;仅在叶节点删除关键码。&lt;/p&gt;
&lt;p&gt;若因为删除操作使得节点中关键码数少于 m/2（向下取整）时，则需要调整或者和兄弟节点合并。&lt;/p&gt;
&lt;p&gt;合并的过程和B树类似，区别是父节点中作为分界的关键码不放入合并后的节点中。&lt;/p&gt;
&lt;h2 id=&#34;红黑树&#34;&gt;红黑树&lt;/h2&gt;
&lt;p&gt;红黑树是一个二叉搜索树，它在每个节点增加了一个存储位记录节点的颜色，可以是&lt;font color=Red&gt;RED&lt;/font&gt;,也可以是&lt;strong&gt;BLACK&lt;/strong&gt;；通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡（最短路径就是全黑节点，最长路径就是一个红节点一个黑节点，当从根节点到叶子节点的路径上黑色节点相同时，最长路径刚好是最短路径的两倍）。它同时满足以下特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;节点是&lt;font color=Red&gt;红色&lt;/font&gt;或&lt;strong&gt;黑色&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;根节点是&lt;strong&gt;黑色&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;叶子节点（外部节点，空节点）都是&lt;strong&gt;黑色&lt;/strong&gt;，这里的&lt;strong&gt;叶子节点指的是最底层的空节点&lt;/strong&gt;（外部节点），&lt;code&gt;null&lt;/code&gt;节点的父节点在红黑树里不将其看作叶子节点&lt;/li&gt;
&lt;li&gt;&lt;font color=Red&gt;红色&lt;/font&gt;节点的子节点都是&lt;strong&gt;黑色&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=Red&gt;红色&lt;/font&gt;节点的父节点都是&lt;strong&gt;黑色&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;从根节点到叶子节点的所有路径上不能有 2 个连续的&lt;font color=Red&gt;红色&lt;/font&gt;节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从任一节点到叶子节点的所有路径都包含相同数目的&lt;strong&gt;黑色&lt;/strong&gt;节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;红黑树与B树的等价变换：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;红黑树 和 4阶B树（2-3-4树）具有等价性&lt;/li&gt;
&lt;li&gt;黑色节点与它的红色子节点融合在一起，形成1个B树节点&lt;/li&gt;
&lt;li&gt;红黑树的黑色节点个数 与 4阶B树的节点总个数相等&lt;/li&gt;
&lt;li&gt;在所有的B树节点中，永远是黑色节点是父节点，红色节点是子节点。黑色节点在中间，红色节点在两边。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;旋转操作&#34;&gt;旋转操作&lt;/h3&gt;
&lt;p&gt;旋转操作分为左旋和右旋，左旋是将某个节点旋转为其右孩子的左孩子，而右旋是节点旋转为其左孩子的右孩子。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688116928266.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;红黑树的插入操作&#34;&gt;红黑树的插入操作&lt;/h3&gt;
&lt;p&gt;红黑树的插入过程和二叉查找树插入过程基本类似，不同的地方在于，红黑树插入新节点后，需要进行调整，以满足红黑树的性质。&lt;/p&gt;
&lt;p&gt;性质1规定红黑树节点的颜色要么是&lt;font color=Red&gt;红色&lt;/font&gt;要么是&lt;strong&gt;黑色&lt;/strong&gt;，那么在插入新节点时，这个节点应该是&lt;font color=Red&gt;红色&lt;/font&gt;，原因也不难理解。如果插入的节点是&lt;strong&gt;黑色&lt;/strong&gt;，那么这个节点所在路径比其他路径多出一个&lt;strong&gt;黑色&lt;/strong&gt;节点，这个调整起来会比较麻烦。&lt;/p&gt;
&lt;p&gt;如果插入的节点是&lt;font color=Red&gt;红色&lt;/font&gt;，此时所有路径上的&lt;strong&gt;黑色&lt;/strong&gt;节点数量不变，仅可能会出现两个连续的&lt;font color=Red&gt;红色&lt;/font&gt;节点的情况。这种情况下，通过变色和旋转进行调整即可，比之前的简单多了。&lt;/p&gt;
&lt;p&gt;所以插入的时候将节点设置为&lt;font color=Red&gt;红色&lt;/font&gt;，可以保证满足性质1、2、3、5 ，只有性质4不一定满足，需要进行相关调整。如果是添加根节点，则将节点设定为&lt;strong&gt;黑色&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;进行插入操作的时候，只会将节点插入到叶子节点中，总共就会有&lt;strong&gt;12&lt;/strong&gt;种情况，其中&lt;strong&gt;4&lt;/strong&gt;种情况满足红黑树的性质，&lt;strong&gt;8&lt;/strong&gt;种情况不满足红黑树性质。&lt;/p&gt;
&lt;h4 id=&#34;parent节点为黑色时&#34;&gt;parent节点为黑色时&lt;/h4&gt;
&lt;p&gt;这种条件下满足性质，无需调整，共四种情况&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688116939164.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;ll和rr插入情况&#34;&gt;LL和RR插入情况&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;RR情况&lt;/strong&gt;：父节点为祖父节点的右节点，插入节点为父节点的右节点&lt;br&gt;
&lt;strong&gt;LL 情况&lt;/strong&gt;：父节点为祖父节点的左节点，插入节点为父节点的左节点&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688116944222.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判定条件&lt;/strong&gt;：uncle 不是&lt;font color=Red&gt;红色&lt;/font&gt;节点。&lt;br&gt;
修复办法：旋转之后染色即可&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;parent 染成&lt;strong&gt;黑色&lt;/strong&gt;，grand 染成&lt;font color=Red&gt;红色&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;grand 进行单旋操作
&lt;ul&gt;
&lt;li&gt;LL：右旋转&lt;/li&gt;
&lt;li&gt;RR：左旋转&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;rl和lr插入情况&#34;&gt;RL和LR插入情况&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;RL情况&lt;/strong&gt;：父节点为祖父节点的右节点，插入节点为父节点的左节点&lt;br&gt;
&lt;strong&gt;LR情况&lt;/strong&gt;：父节点为祖父节点的左节点，插入节点为父节点的右节点&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688116951371.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;与RR和LL基本类似 旋转染色即可&lt;br&gt;
&lt;strong&gt;判定条件&lt;/strong&gt;：uncle 不是&lt;strong&gt;红色&lt;/strong&gt;节点。&lt;br&gt;
修复办法：旋转之后染色即可&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入节点染成&lt;strong&gt;黑色&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;grand 染成&lt;strong&gt;红色&lt;/strong&gt;，进行双旋操作
&lt;ul&gt;
&lt;li&gt;LR：parent 左旋转， grand 右旋转&lt;/li&gt;
&lt;li&gt;RL：parent 右旋转， grand 左旋转&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;上溢情况&#34;&gt;上溢情况&lt;/h4&gt;
&lt;p&gt;LL情况：父节点为祖父节点的左节点，插入节点为父节点的左节点。并且构成的新的B树节点已经超过了B树节点容量大小范围。&lt;br&gt;
&lt;strong&gt;判定条件&lt;/strong&gt;：uncle 是&lt;font color=Red&gt;红色&lt;/font&gt;节点。&lt;br&gt;
满足这个条件的就都是上溢的情况，上溢的修复只需要染色，不需要旋转。&lt;br&gt;
&lt;strong&gt;修复步骤总结&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;parent、uncle 染成&lt;strong&gt;黑色&lt;/strong&gt;，grand 向上合并&lt;/li&gt;
&lt;li&gt;将向上合并的grand染成&lt;font color=Red&gt;红色&lt;/font&gt;，相对上一层，就当做是新添加的节点，再次来一遍插入情况的判断，进行处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同理有上溢RR，LR，RL的情况&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;p&gt;插入一共有12种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;插入节点的父节点是&lt;strong&gt;黑色&lt;/strong&gt;的情况有4种&lt;br&gt;
这种情况仍然会维持红黑树的性质，则不需要进行额外处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入节点的父节点是&lt;font color=Red&gt;红色&lt;/font&gt;的情况有8种&lt;br&gt;
这种情况不满足红黑树的性质4，需要进行额外的修复处理。&lt;br&gt;
这8种情况中：&lt;br&gt;
1） 叔父节点不是&lt;font color=Red&gt;红色&lt;/font&gt;的情况有4种，这些情况都是非上溢，需要通过重新染色和旋转来进行修复&lt;br&gt;
2） 叔父节点是&lt;font color=Red&gt;红色&lt;/font&gt;的情况有4种，这些情况都是上溢的，只需要通过祖父节点上溢合并和染色即可完成修复&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;红黑树的删除操作&#34;&gt;红黑树的删除操作&lt;/h3&gt;
&lt;p&gt;在红黑树中，被删除的节点一定在最后一层。&lt;/p&gt;
&lt;h4 id=&#34;删除红色节点&#34;&gt;删除红色节点&lt;/h4&gt;
&lt;p&gt;如果删除的节点是&lt;font color=Red&gt;红色&lt;/font&gt;直接删除，不用作任何调整。因为删除最后一层的&lt;font color=Red&gt;红色&lt;/font&gt;节点，并没有影响红黑树的任何性质。&lt;/p&gt;
&lt;h4 id=&#34;删除黑色节点&#34;&gt;删除黑色节点&lt;/h4&gt;
&lt;p&gt;有3种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;拥有 2 个&lt;font color=Red&gt;红色&lt;/font&gt;子节点的&lt;strong&gt;黑色&lt;/strong&gt;节点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可能被直接删除，因为会找它的子节点替代删除，因此不用考虑这种情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拥有 1 个&lt;font color=Red&gt;红色&lt;/font&gt;子节点的&lt;strong&gt;黑色&lt;/strong&gt;节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;黑色&lt;/strong&gt;叶子节点&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;删除拥有1个font-colorred红色font子节点的黑色节点&#34;&gt;删除拥有1个&lt;font color=Red&gt;红色&lt;/font&gt;子节点的黑色节点&lt;/h5&gt;
&lt;p&gt;对于一个二叉树来说，删除一个度为1的节点（度指的是一个节点的子节点个数），将其删除后需要用它唯一的子节点来进行替换。而红黑树的这种情况的&lt;strong&gt;判定条件&lt;/strong&gt;，就是判定要替代删除节点的子节点是不是&lt;font color=Red&gt;红色&lt;/font&gt;&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688116957237.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判定条件&lt;/strong&gt;：用以替代的子节点是&lt;font color=Red&gt;红色&lt;/font&gt;节点&lt;br&gt;
&lt;strong&gt;修复步骤总结&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用删除节点的唯一子节点对其进行替代&lt;/li&gt;
&lt;li&gt;将替代节点染成&lt;strong&gt;黑色&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;删除黑色叶子节点删除节点为根节点&#34;&gt;删除黑色叶子节点——删除节点为根节点&lt;/h5&gt;
&lt;p&gt;一棵红黑树只有一个&lt;strong&gt;黑色&lt;/strong&gt;根节点（也就是唯一的一个叶子节点，整个红黑树只有这一个&lt;strong&gt;黑色&lt;/strong&gt;节点），可直接删除该节点，无需做其他操作。&lt;/p&gt;
&lt;h5 id=&#34;删除黑色叶子节点删除节点的兄弟节点为黑色&#34;&gt;删除黑色叶子节点——删除节点的兄弟节点为黑色&lt;/h5&gt;
&lt;h6 id=&#34;兄弟节点至少有1个font-colorred红色font子节点&#34;&gt;兄弟节点至少有1个&lt;font color=Red&gt;红色&lt;/font&gt;子节点&lt;/h6&gt;
&lt;p&gt;因为兄弟节点有&lt;font color=Red&gt;红色&lt;/font&gt;子节点，所以可以借出一个节点来进行修复。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688116965316.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判定条件&lt;/strong&gt;：兄弟节点至少有 1 个&lt;font color=Red&gt;红色&lt;/font&gt;子节点&lt;br&gt;
&lt;strong&gt;修复步骤总结&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进行旋转操作&lt;/li&gt;
&lt;li&gt;旋转之后的中心节点继承父节点（删除节点的父节点）的颜色&lt;/li&gt;
&lt;li&gt;旋转之后的左右节点染为&lt;strong&gt;黑色&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id=&#34;兄弟节点没有font-colorred红色font子节点&#34;&gt;兄弟节点没有&lt;font color=Red&gt;红色&lt;/font&gt;子节点&lt;/h6&gt;
&lt;p&gt;当删除节点的兄弟节点没有&lt;font color=Red&gt;红色&lt;/font&gt;节点可以借出的情况下，就需要父节点来向下合并进行修复&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688116970703.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判定条件&lt;/strong&gt;：兄弟节点没有1个&lt;font color=Red&gt;红色&lt;/font&gt;子节点&lt;br&gt;
&lt;strong&gt;修复步骤总结&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;父节点向下与兄弟节点进行合并&lt;/li&gt;
&lt;li&gt;将兄弟染成&lt;font color=Red&gt;红色&lt;/font&gt;、父节点染成黑色即可修复红黑树性质
&lt;ul&gt;
&lt;li&gt;如果父节点是&lt;strong&gt;黑色&lt;/strong&gt;，直接将父节点当成被删除的节点处理，来修复父节点的下溢情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;删除黑色叶子节点删除节点的兄弟节点为font-colorred红色font&#34;&gt;删除黑色叶子节点——删除节点的兄弟节点为&lt;font color=Red&gt;红色&lt;/font&gt;&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1688116976716.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;判定条件&lt;/strong&gt;：兄弟节点是&lt;font color=Red&gt;红色&lt;/font&gt;&lt;br&gt;
&lt;strong&gt;修复步骤总结&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;兄弟节点染成&lt;strong&gt;黑色&lt;/strong&gt;，父节点染成染成&lt;font color=Red&gt;红色&lt;/font&gt;，对父节点进行右旋&lt;/li&gt;
&lt;li&gt;于是又回到兄弟节点是&lt;strong&gt;黑色&lt;/strong&gt;的情况（侄子节点变为兄弟节点），继续使用兄弟节点为&lt;strong&gt;黑色&lt;/strong&gt;的方法进行修复&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;哈夫曼树&#34;&gt;哈夫曼树&lt;/h2&gt;
&lt;p&gt;哈夫曼树是是指&lt;strong&gt;最优m叉树&lt;/strong&gt;,也叫做严格m叉树, 即m叉树的带权路径长度达到最小。&lt;/p&gt;
&lt;p&gt;哈夫曼树（Huffman Tree）是一种特殊的二叉树，用于编码和压缩数据。哈夫曼树的构建基于哈夫曼编码算法，该算法可以根据数据的出现频率来生成最优的编码方案，以便在压缩数据时能够获得最小的压缩比。&lt;/p&gt;
&lt;p&gt;哈夫曼树的构建过程通常如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;统计数据中每个字符出现的频率，并将其存储在一个频率表中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将频率表中的每个字符和其出现频率作为一个叶子节点，构建一个森林。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从森林中选择两个频率最小的节点，将它们合并为一个新节点，并将新节点的权值设置为两个节点的权值之和。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将新节点插入森林中，并从森林中删除原来的两个节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重复步骤3和4，直到森林中只剩下一个节点，即为哈夫曼树的根节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在哈夫曼树中，每个叶子节点表示一个字符，其权值为该字符在数据中出现的频率。每个非叶子节点表示一个编码，其权值为其子节点的权值之和。哈夫曼编码是一种前缀编码，即任何一个字符的编码都不是另一个字符编码的前缀，以便在解码时能够唯一确定每个字符的编码。&lt;/p&gt;
&lt;p&gt;哈夫曼树上的节点&lt;strong&gt;度要么为0要么为满&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以&lt;code&gt;m&lt;/code&gt;叉哈夫曼树 如果有&lt;code&gt;n&lt;/code&gt;个叶子节点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其总结点数为 &lt;code&gt;n+x&lt;/code&gt; （x为满度节点数量）&lt;/li&gt;
&lt;li&gt;又可知 总结点数还可表示为 &lt;code&gt;1+m*x&lt;/code&gt; 即计算总入度+1=总分支数加上根节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此可得等式 &lt;code&gt;n+x = 1 + m*x&lt;/code&gt; 从而求解&lt;code&gt;n&lt;/code&gt;或者&lt;code&gt;m&lt;/code&gt;或&lt;code&gt;x&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;本文内容参考：&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/cy973071263/article/details/122543826&#34;&gt;红黑树详解&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/weixin_43156699/article/details/117216784&#34;&gt;B树和B+树详解&lt;/a&gt;&lt;/p&gt;
">[数据结构] 树详解：B/B+树，红黑树，哈夫曼树</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/yzVVBvRY-/"" data-c="
          &lt;h2 id=&#34;数据库&#34;&gt;数据库&lt;/h2&gt;
&lt;h4 id=&#34;连接数据库&#34;&gt;连接数据库&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql -h 10.20.66.32 -u root -p 123456
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-h&lt;/code&gt; 后面是mysqlServer所在地址，&lt;code&gt;-u&lt;/code&gt;后面是用户名，&lt;code&gt;-p&lt;/code&gt;后面是密码&lt;/p&gt;
&lt;h4 id=&#34;查看数据库表&#34;&gt;查看数据库/表&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;show databases;
show tables;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;使用数据库&#34;&gt;使用数据库&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;use test;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;查看表结构&#34;&gt;查看表结构&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;desc winton
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;建表&#34;&gt;建表&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 语法 
create table 表名称( 字段名 字段名类型 字段描述符，字段名 字段类型 字段描述符);

--下面为用例
create table t1(
    id int not null primary key, 
    name char(20) not null
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;删除表&#34;&gt;删除表&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;drop table test;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;修改表&#34;&gt;修改表&lt;/h2&gt;
&lt;h4 id=&#34;添加字段&#34;&gt;添加字段&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 语法 
alter table 表名 add(字段名 类型 描述符)；

--下面为用例
alter table t1 add(score int not null);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;移除字段&#34;&gt;移除字段&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 语法 
alter table 表名 drop colunm 字段名，drop colunm 字段名；

--下面为用例
alter table t1 drop column score;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;变更字段&#34;&gt;变更字段&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 语法 
-- 全部修改
alter table 表名 change 旧字段名 新字段名 新字段类型 新字段描述符
-- 只修改类型和约束 不修改名称
alter table 表名 modify 列名 类型及约束;

--下面为用例
alter table t1 change name score int not null;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;全字段插入&#34;&gt;全字段插入&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;insert into winton values(001,&#39;zww&#39;),(002,&#39;rs&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即插入一整条数据 可以一次插入多行&lt;/p&gt;
&lt;h4 id=&#34;个别字段插入&#34;&gt;个别字段插入&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;insert into winton(id，name) values(004，“zs”)，(005，“ls”);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即只插入该条数据的一部分字段 可以一次插入多行&lt;/p&gt;
&lt;p&gt;值的顺序与给出的列顺序对应&lt;/p&gt;
&lt;h2 id=&#34;查询表&#34;&gt;查询表&lt;/h2&gt;
&lt;h4 id=&#34;单表查询&#34;&gt;单表查询&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 语法 
select 字段一,字段二 from 表名;

--下面为用例
select * from t1;
select id from t1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;多表查询&#34;&gt;多表查询&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 语法 
select 表一字段,表二字段,表三字段,…… from 表一, 表二, 表三, ……；

--下面为用例
select t1.id,t1.score,winton.name from t1, winton;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;条件查询&#34;&gt;条件查询&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 语法 
select 表一字段，表二字段 from 表一，表二 where 条件；

--下面为用例
select * from t1 where socre&amp;gt;90;
select t1.id,t1.score,winton.name from t1,winton where t1.id=winton.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;嵌套查询&#34;&gt;嵌套查询&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 语法 
select 字段一,字段二…… from 表名 where 条件(查询);

--下面为用例
select name from winton where id=(select id from t1 where score=90);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;并查询&#34;&gt;并查询&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;(select id from t1 )union(select id from winton);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即查询结果取并集&lt;/p&gt;
&lt;h4 id=&#34;交查询&#34;&gt;交查询&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select id from t1 where id in (select id from winton);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即查询结果取交集&lt;/p&gt;
&lt;h4 id=&#34;模糊查询&#34;&gt;模糊查询&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 查询姓黄的学生
select * from students where name like ‘黄%’;

-- 查询姓黄并且“名”是一个字的学生
select * from students where name like ‘黄_’;

-- 查询姓黄或叫靖的学生
select * from students where name like ‘黄%’ or name like ‘%靖’;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;%&lt;/code&gt;表示任意多个任意字符 &lt;code&gt;_&lt;/code&gt;表示一个任意字符&lt;/p&gt;
&lt;p&gt;注：如果数据是字符型，必须使用单引号或双引号&lt;/p&gt;
&lt;h4 id=&#34;范围查询&#34;&gt;范围查询&lt;/h4&gt;
&lt;h5 id=&#34;非连续范围查询&#34;&gt;非连续范围查询&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from students where id in(1,3,8);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询编号是1或3或8的学生&lt;/p&gt;
&lt;p&gt;&lt;code&gt;in&lt;/code&gt;表示在一个非连续的范围内&lt;/p&gt;
&lt;h5 id=&#34;连续范围查询&#34;&gt;连续范围查询&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from students where id between 3 and 8 and gender=1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询编号为3至8的男生&lt;/p&gt;
&lt;p&gt;&lt;code&gt;between … and …&lt;/code&gt; 表示在一个连续的范围内&lt;/p&gt;
&lt;h4 id=&#34;连接查询&#34;&gt;连接查询&lt;/h4&gt;
&lt;h5 id=&#34;内连接&#34;&gt;内连接&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from students inner join classes on students.cls_id = classes.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内连接是等值连接，它使用“=、&amp;gt;、&amp;lt;、&amp;lt;&amp;gt;”等运算符根据每个表共有的列的值匹配的行&lt;/p&gt;
&lt;h5 id=&#34;外连接&#34;&gt;外连接&lt;/h5&gt;
&lt;p&gt;外连接查询中的&lt;code&gt;outer&lt;/code&gt;可省略&lt;/p&gt;
&lt;h5 id=&#34;左连接left-join-或-left-outer-join&#34;&gt;左连接(left join 或 left outer join)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from students as s left join classes as c on s.cls_id = c.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;左连接又称左向外连接，查询的结果集包括SQL语句中左表的所有行，以及右表中匹配的行。&lt;/p&gt;
&lt;p&gt;如果左表的某行在右表中没有匹配行，则用空值表示&lt;/p&gt;
&lt;h5 id=&#34;右连接right-join-或-right-outer-join&#34;&gt;右连接(right join 或 right outer join)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from students as s right join classes as c on s.cls_id = c.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;右连接也称右向外连接，查询的结果集包括SQL语句中右表的所有行，以及左表中匹配的行。&lt;/p&gt;
&lt;p&gt;如果右表的某行在左表中没有匹配的行，则用空值表示&lt;/p&gt;
&lt;h5 id=&#34;完全外连接full-join-或-full-outer-join&#34;&gt;完全外连接(full join 或 full outer join)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from students as s full join classes as c on s.cls_id = c.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处使用了&lt;code&gt;as&lt;/code&gt;为表起别名，目的是编写简单&lt;/p&gt;
&lt;p&gt;完全外连接，查询的结果集包括SQL语句中左表和右表的所有行。&lt;/p&gt;
&lt;p&gt;如果某行在另一个表中没有匹配行时，则用空值表示。&lt;/p&gt;
&lt;h5 id=&#34;交叉连接cross-join&#34;&gt;交叉连接(cross join)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT &amp;lt;字段名&amp;gt; FROM &amp;lt;表1&amp;gt; CROSS JOIN &amp;lt;表2&amp;gt; [WHERE子句]

-- 或者
SELECT &amp;lt;字段名&amp;gt; FROM &amp;lt;表1&amp;gt;, &amp;lt;表2&amp;gt; [WHERE子句]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回结果就是两个表的笛卡尔积，即两边依次匹配行连接在一起&lt;/p&gt;
&lt;p&gt;返回结果数量就是两个表的数据行相乘。&lt;/p&gt;
&lt;p&gt;需要注意的是，如果每个表有 1000 行，那么返回结果的数量就有 1000×1000 = 1000000 行，数据量是非常巨大的。&lt;/p&gt;
&lt;p&gt;如果在交叉连接时使用 WHERE 子句，MySQL 会&lt;strong&gt;先生成两个表的笛卡尔积&lt;/strong&gt;，然后再选择满足 WHERE 条件的记录。&lt;/p&gt;
&lt;p&gt;因此，表的数量较多时，交叉连接会非常非常慢。一般情况下不建议使用交叉连接。&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from 表1 inner/left/right join 表2 on 表1.列 运算符 表2.列;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;删除数据&#34;&gt;删除数据&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 语法 
delete from 表名 where 条件；

--下面为用例
delete from winton where id=4;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;更新数据&#34;&gt;更新数据&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 语法 
update 表名 set 更改的字段名=值 where 条件；

--下面为用例
update t1 set score=69 where id=2;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;求和&#34;&gt;求和&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select sum(score) from t1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：&lt;code&gt;sum(字段)&lt;/code&gt; 对字符串和时间无效&lt;/p&gt;
&lt;h4 id=&#34;求平均值&#34;&gt;求平均值&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select avg(score) from t1; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：&lt;code&gt;avg(字段)&lt;/code&gt;对字符串和时间无效&lt;/p&gt;
&lt;h4 id=&#34;计数&#34;&gt;计数&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select count(*) from t1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表示计算总行数&lt;/p&gt;
&lt;p&gt;注：&lt;code&gt;count(字段名)&lt;/code&gt;不包含&lt;code&gt;NULL&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;COUNT(常量)&lt;/code&gt; 和 &lt;code&gt;COUNT(*)&lt;/code&gt; 表示的是直接查询符合条件的数据库表的行数。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;COUNT(列名)&lt;/code&gt;表示的是查询符合条件的列的值不为NULL的行数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;COUNT(*)&lt;/code&gt;是SQL92定义的标准统计行数的语法，因为是标准语法，所以MySQL数据库进行过很多优化。&lt;/p&gt;
&lt;p&gt;如果表多个列并且没有主键，则 &lt;code&gt;count(1)&lt;/code&gt; 的执行效率优于 &lt;code&gt;count(*)&lt;/code&gt;&lt;br&gt;
否则基本一致&lt;/p&gt;
&lt;h2 id=&#34;常用的修饰符&#34;&gt;常用的修饰符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;distinct&lt;/code&gt; 字段中值唯一&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select distinct name from winton;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;limit&lt;/code&gt;查询结果数限制&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from winton limit 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;limit 5，5&lt;/code&gt; 第一个数表示开始位置，第二个数表示检索行数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;order by&lt;/code&gt; 排序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from winton order by name;
slelect * from winton order by name desc;
select * from winton order by name asc;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：默认是升序 desc 降序 asc 升序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;group by&lt;/code&gt; 分组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select name from winton group by name;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;创建索引&#34;&gt;创建索引&lt;/h2&gt;
&lt;h4 id=&#34;创建普通索引&#34;&gt;创建普通索引&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 语法 
create index 索引名称 on 表名 (字段一，字段二，……);

--下面为用例
create index wintonIndex on winton (name);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;创建唯一索引&#34;&gt;创建唯一索引&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 语法 
create unique index 索引名 on 表名 (字段一,字段二,……)；

--下面为用例
create unique index wintonIndex on winton (id);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意&lt;code&gt;unique index&lt;/code&gt; 要求列中数据唯一，不能出现重复。&lt;/p&gt;
&lt;h4 id=&#34;创建前缀索引&#34;&gt;创建前缀索引&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 在email列创建前缀索引 按前三个字符建立索引
CREATE INDEX idx_author_email ON author(email(3));
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;创建全文索引&#34;&gt;创建全文索引&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create fulltext index content_tag_fulltext on fulltext_test(content,tag);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;移除索引&#34;&gt;移除索引&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 语法 
drop index 索引名 on 表名；

--下面为用例
drop index wintonIndex on winton;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;建表时创建索引&#34;&gt;建表时创建索引&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;KEY | INDEX [&amp;lt;索引名&amp;gt;] [&amp;lt;索引类型&amp;gt;] (&amp;lt;列名&amp;gt;,…)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;CREATE TABLE&lt;/code&gt; 语句中添加此语句，表示在创建新表的同时创建该表的索引。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;UNIQUE [ INDEX | KEY] [&amp;lt;索引名&amp;gt;] [&amp;lt;索引类型&amp;gt;] (&amp;lt;列名&amp;gt;,…)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;CREATE TABLE&lt;/code&gt; 语句中添加此语句，表示在创建新表的同时创建该表的唯一性索引。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;FOREIGN KEY &amp;lt;索引名&amp;gt; &amp;lt;列名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;CREATE TABLE&lt;/code&gt; 语句中添加此语句，表示在创建新表的同时创建该表的外键。&lt;/p&gt;
&lt;h2 id=&#34;视图&#34;&gt;视图&lt;/h2&gt;
&lt;h4 id=&#34;创建视图&#34;&gt;创建视图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 语法 
CREATE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition

--下面为用例
create or replace view v_student as 
select Sno,Sname
from student;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;删除视图&#34;&gt;删除视图&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;drop view v_student;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;面试问题&#34;&gt;面试问题&lt;/h2&gt;
&lt;h3 id=&#34;创建字段时设置属性的区别&#34;&gt;创建字段时设置属性的区别&lt;/h3&gt;
&lt;h4 id=&#34;1-intn&#34;&gt;1、&lt;code&gt;int(N)&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;int(N)&lt;/code&gt; ，&lt;code&gt;N&lt;/code&gt; 表示最大显示宽度(字段设置&lt;code&gt;zerofill&lt;/code&gt;属性时可查看区别)，不指定&lt;code&gt;N&lt;/code&gt;时，默认为11。&lt;code&gt;N&lt;/code&gt; 的值跟 &lt;code&gt;int(N)&lt;/code&gt; 所占多少存储空间或最大能存储多大长度数据并无任何关系。也就是int(3)、int(4)、int(8) 在磁盘上都是占用 4 btyes 的存储空间。&lt;/p&gt;
&lt;p&gt;当 int 字段类型设置为无符号且填充零(UNSIGNED ZEROFILL)时，当数值位数未达到设置的显示宽度时，会在数值前面补充零直到满足设定的显示宽度，为什么会有无符号的限制呢，是因为 &lt;code&gt;ZEROFILL&lt;/code&gt; 属性会隐式地将数值转为无符号型，因此不能存储负的数值。&lt;/p&gt;
&lt;p&gt;只有给字段加了&lt;code&gt;zerofill&lt;/code&gt;参数后，如果实际插入的数据宽度小于字段设置的显示宽度N时，将自动在数字前填充0。同时，如果插入的数据宽度大于设置的显示宽度N时，不会出现数据无法插入或数据被截断的情况。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table tb2 (id1 int(3) zerofill)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-charn与-varcharn&#34;&gt;2、char(N)与 varchar(N)&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;char(N)&lt;/code&gt;和&lt;code&gt;varchar(N)&lt;/code&gt;最大的区别在于存储需求空间上的区别上，前者为固定长度，存储需求为&lt;code&gt;N&lt;/code&gt;字符长度。后者为可变长度(“var”意为“variable”，可变的)，存储需求为实际值的长度+1(如果N&amp;gt;255，则+2)。其中&lt;code&gt;N&lt;/code&gt;，不管针对char还是varcahr均有最大字符长度不允许超过&lt;code&gt;N&lt;/code&gt;的意思。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char(N)&lt;/code&gt;的N取值范围为255。&lt;br&gt;
&lt;code&gt;varchar(N)&lt;/code&gt;的N取值范围为65535，超过了自动转换为text类型。&lt;/p&gt;
&lt;h4 id=&#34;3-varchar50和varchar100是否一样&#34;&gt;3、&lt;code&gt;varchar(50)&lt;/code&gt;和&lt;code&gt;varchar(100)&lt;/code&gt;是否一样？&lt;/h4&gt;
&lt;p&gt;硬盘存储需求一样，内存需求不一样。&lt;/p&gt;
&lt;p&gt;即对于VARCHAR数据类型来说，硬盘上的存储空间是根据实际字符长度来分配存储空间的&lt;/p&gt;
&lt;p&gt;而对于内存来说，是使用&lt;code&gt;N&lt;/code&gt;个字符空间的内存块来保存值，即&lt;code&gt;varchar(50)&lt;/code&gt;占用50个字符内存空间，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;varchar(100)&lt;/code&gt;占用100个字符内存空间。&lt;/p&gt;
">[SQL] 常用SQL语句</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/Emlg-KR8j/"" data-c="
          &lt;h2 id=&#34;什么是跳表&#34;&gt;什么是跳表&lt;/h2&gt;
&lt;p&gt;跳表全称为跳跃列表，它允许快速查询，插入和删除一个有序连续元素的数据链表。跳跃列表的平均查找和插入、删除时间复杂度都是&lt;code&gt;O(logn)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集（见示意图）。&lt;/p&gt;
&lt;p&gt;一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688474803734.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;每个带有箭头的框表示一个指针, 而每行是一个稀疏子序列的链表；底部的编号框（黄色）表示有序的数据序列。&lt;/p&gt;
&lt;p&gt;查找从顶部最稀疏的子序列向下进行, 直至需要查找的元素在该层两个相邻的元素中间。&lt;/p&gt;
&lt;h2 id=&#34;跳表的演化过程&#34;&gt;跳表的演化过程&lt;/h2&gt;
&lt;p&gt;对于单链表来说，即使数据是已经排好序的，想要查询其中的一个数据，只能从头开始遍历链表，这样效率很低，时间复杂度很高，是&lt;code&gt; O(n)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们可以为链表建立一个“索引”，这样查找起来就会更快，如下图所示，我们在原始链表的基础上，每两个结点提取一个结点建立索引，我们把抽取出来的结点叫做索引层或者索引，索引中存放指向原始链表结点的指针。而通过对链表加多级索引的结构，就是跳表了&lt;/p&gt;
&lt;p&gt;跳表是&lt;strong&gt;用空间来换时间&lt;/strong&gt;。跳表的效率比链表高了，但是跳表需要额外存储多级索引，所以需要的更多的内存空间。&lt;/p&gt;
&lt;h2 id=&#34;插入节点的层数应当随机&#34;&gt;插入节点的层数应当随机&lt;/h2&gt;
&lt;p&gt;如果我们不停的向跳表中插入元素，就可能会造成两个索引点之间的结点过多的情况。&lt;/p&gt;
&lt;p&gt;结点过多的话，我们建立索引的优势也就没有了。所以我们需要维护索引与原始链表的大小平衡，也就是结点增多了，索引也相应增加，避免出现两个索引之间结点过多的情况，查找效率降低。&lt;/p&gt;
&lt;p&gt;跳表是&lt;strong&gt;通过一个随机函数&lt;/strong&gt;来维护这个平衡的，当我们向跳表中插入数据的的时候，我们可以选择同时把这个数据插入到索引里。&lt;/p&gt;
&lt;p&gt;那我们插入到哪一级的索引呢，这就需要随机函数，来决定我们插入到哪一级的索引中。&lt;br&gt;
即第一层的概率为0.5 第二层为0.25 第三层为0.125 以此类推 用奇偶性来完成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TPS&lt;/strong&gt;：&lt;br&gt;
Transactions Per Second，意思是每秒事务数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QPS&lt;/strong&gt;：&lt;br&gt;
Queries Per Second，意思是每秒查询率。&lt;/p&gt;
&lt;p&gt;跳表是链表结构，一条数据一个结点，如果最底层要存放2kw数据，且每次查询都要能达到二分查找的效果，2kw大概在2的24次方左右，所以，跳表大概高度在24层左右。最坏情况下，这24层数据会分散在不同的数据页里，也即是查一次数据会经历24次磁盘IO。&lt;/p&gt;
&lt;p&gt;因此存放同样量级的数据，B+树的高度比跳表的要少，如果放在mysql数据库上来说，就是磁盘IO次数更少，因此B+树查询更快。&lt;/p&gt;
&lt;p&gt;而针对写操作，B+树需要拆分合并索引数据页，跳表则独立插入，并根据随机函数确定层数，没有旋转和维持平衡的开销，因此跳表的写入性能会比B+树要好。&lt;/p&gt;
&lt;p&gt;redis支持多种数据结构，里面有个有序集合，也叫&lt;code&gt;ZSET&lt;/code&gt;。内部实现就是跳表。&lt;/p&gt;
&lt;h3 id=&#34;redis为什么使用跳表而不使用b树或二叉树呢&#34;&gt;redis为什么使用跳表而不使用B+树或二叉树呢？&lt;/h3&gt;
&lt;p&gt;redis 是纯纯的&lt;strong&gt;内存数据库&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;进行读写数据都是操作内存，跟磁盘没啥关系，因此也&lt;strong&gt;不存在磁盘IO&lt;/strong&gt;了，所以层高就不再是跳表的劣势了。&lt;/p&gt;
&lt;p&gt;并且前面也提到B+树是有一系列合并拆分操作的，换成红黑树或者其他AVL树的话也是各种旋转，目的也是为了保持树的平衡。&lt;/p&gt;
&lt;p&gt;而跳表插入数据时，只需要随机一下，就知道自己要不要往上加索引，根本不用考虑前后结点的感受，也就&lt;strong&gt;少了旋转平衡的开销&lt;/strong&gt;。&lt;/p&gt;
">[C++项目] 储存引擎</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/k29IoaUs5/"" data-c="
          &lt;p&gt;&lt;code&gt;CMake&lt;/code&gt;可以跨平台的生成&lt;code&gt;makefile&lt;/code&gt;，再由&lt;code&gt;make&lt;/code&gt;/&lt;code&gt;ninja&lt;/code&gt;等编译工具根据&lt;code&gt;makefile&lt;/code&gt;的规范进行编译&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CMake&lt;/code&gt;根据 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 文件执行 &lt;strong&gt;指令是大小写无关的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里以Linux下的使用来介绍CMake&lt;/p&gt;
&lt;h2 id=&#34;简单实例&#34;&gt;简单实例&lt;/h2&gt;
&lt;p&gt;一个最简单的&lt;code&gt;Cmake&lt;/code&gt;项目形如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cmake&#34;&gt;cmake_minimum_required(VERSION 3.15)
# set the project name
project(Tutorial)
# add the executable
add_executable(Tutorial tutorial.cpp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cmake_minimum_required&lt;/code&gt; 指定使用 &lt;code&gt;CMake&lt;/code&gt; 的最低版本号&lt;br&gt;
&lt;code&gt;project&lt;/code&gt; 指定项目名称&lt;br&gt;
&lt;code&gt;add_executable&lt;/code&gt; 用来生成可执行文件，需要指定生成可执行文件的名称和相关源文件(如果有多个，那么就用&lt;code&gt;空格&lt;/code&gt;隔开)。&lt;/p&gt;
&lt;p&gt;如果源文件很多，把所有源文件的名字都加进&lt;code&gt;add_executable&lt;/code&gt;将是一件烦人的工作。&lt;br&gt;
更省事的方法是使用 &lt;code&gt;aux_source_directory&lt;/code&gt; 命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;aux_source_directory(&amp;lt;dir&amp;gt; &amp;lt;variable&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名&lt;/p&gt;
&lt;h2 id=&#34;构建使用cmake&#34;&gt;构建使用cmake&lt;/h2&gt;
&lt;h3 id=&#34;使用cmake&#34;&gt;使用cmake&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cmake  &amp;lt;CMakeLists.txt文件存放的目录&amp;gt;
cmake . # CMakeLists.txt文件在当前文件夹底下
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;编译和链接&#34;&gt;编译和链接&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cmake --build  &amp;lt;生成的文件希望存放的目录&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;变量&#34;&gt;变量&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;set(SRC_LIST a.cpp b.cpp c.cpp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;set&lt;/code&gt;命令可以指定变量 类似于&lt;code&gt;makefile&lt;/code&gt;的变量&lt;br&gt;
使用时也是类似方法 &lt;code&gt;$&lt;/code&gt;加上用&lt;code&gt;{}&lt;/code&gt;括起的&lt;code&gt;变量名&lt;/code&gt; eg. &lt;code&gt;${SRC_LIST}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在CMake中，&lt;code&gt;list&lt;/code&gt;命令用于操作列表。它可以用于创建、修改和查询列表，以及将列表转换为字符串。&lt;/p&gt;
&lt;p&gt;以下是&lt;code&gt;list&lt;/code&gt;命令的一些常用用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;list(APPEND &amp;lt;list&amp;gt; &amp;lt;element1&amp;gt; [&amp;lt;element2&amp;gt; ...])&lt;/code&gt;：将一个或多个元素添加到列表的末尾。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;list(INSERT &amp;lt;list&amp;gt; &amp;lt;index&amp;gt; &amp;lt;element1&amp;gt; [&amp;lt;element2&amp;gt; ...])&lt;/code&gt;：将一个或多个元素插入到列表的指定位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;list(REMOVE_ITEM &amp;lt;list&amp;gt; &amp;lt;value1&amp;gt; [&amp;lt;value2&amp;gt; ...])&lt;/code&gt;：从列表中删除一个或多个指定的元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;list(REMOVE_DUPLICATES &amp;lt;list&amp;gt;)&lt;/code&gt;：从列表中删除重复的元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;list(GET &amp;lt;list&amp;gt; &amp;lt;index&amp;gt;)&lt;/code&gt;：获取列表中指定位置的元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;list(LENGTH &amp;lt;list&amp;gt;)&lt;/code&gt;：获取列表的长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;list(SUBLIST &amp;lt;list&amp;gt; &amp;lt;start&amp;gt; [&amp;lt;length&amp;gt;])&lt;/code&gt;：获取列表的子列表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;list(JOIN &amp;lt;glue&amp;gt; &amp;lt;list&amp;gt;)&lt;/code&gt;：将列表中的元素用指定的分隔符连接成一个字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下代码演示了如何使用list命令创建、修改和查询列表：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cmake&#34;&gt;# 创建一个空列表
set(my_list)

# 向列表中添加元素
list(APPEND my_list &amp;quot;apple&amp;quot; &amp;quot;banana&amp;quot; &amp;quot;orange&amp;quot;)

# 在列表的第二个位置插入一个元素
list(INSERT my_list 1 &amp;quot;pear&amp;quot;)

# 从列表中删除一个元素
list(REMOVE_ITEM my_list &amp;quot;banana&amp;quot;)

# 获取列表的第三个元素
list(GET my_list 2)

# 获取列表的长度
list(LENGTH my_list)

# 获取列表的子列表
list(SUBLIST my_list 1 2)

# 将列表中的元素用逗号连接成一个字符串
list(JOIN &amp;quot;,&amp;quot; my_list)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过SET指令重新定义 &lt;code&gt;EXECUTABLE_OUTPUT_PATH&lt;/code&gt; 和&lt;code&gt;LIBRARY_OUTPUT_PATH&lt;/code&gt; 变量可以指定最终生成的目标二进制的位置（&lt;code&gt;EXECUTABLE&lt;/code&gt;和&lt;code&gt;LIBRARY&lt;/code&gt;分别对应于两种最终输出的二进制形式）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出信息&#34;&gt;输出信息&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] &amp;quot;message&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;向终端输出用户定义的信息，包含三种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SEND_ERROR&lt;/code&gt; 产生错误，生成过程被跳过。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STATUS&lt;/code&gt; 输出前缀为&lt;code&gt;--d&lt;/code&gt;的信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FATAL_ERROR&lt;/code&gt; 立即终止所有的&lt;code&gt;cmake&lt;/code&gt;过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;添加搜索目录&#34;&gt;添加搜索目录&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;target_include_directories(${PROJECT_NAME} PUBLIC${PROJECT_BINARY_DIR})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;target_include_directories&lt;/code&gt; 命令可以将需要添加的头文件目录加入搜索路径&lt;/p&gt;
&lt;h3 id=&#34;添加子目录&#34;&gt;添加子目录&lt;/h3&gt;
&lt;p&gt;使用命令 &lt;code&gt;add_subdirectory&lt;/code&gt; 指明本项目包含一个子目录, 这样该子目录下的&lt;code&gt;CMakeLists.txt&lt;/code&gt; 文件和源代码也会被处理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个指令用于向当前工程添加存放源文件的子目录, 并可以指定中间二进制和目标二进制存&lt;br&gt;
放的位置。&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;source_dir&lt;/code&gt;是要添加的子目录的路径，&lt;code&gt;binary_dir&lt;/code&gt;是要生成二进制文件的路径（默认为&lt;code&gt;source_dir&lt;/code&gt;），&lt;code&gt;EXCLUDE_FROM_ALL&lt;/code&gt;表示是否将该子目录排除在所有目标之外（默认为不排除）,使用时直接写上这个变量就行，eg. &lt;code&gt;add_subdirectory(my_library EXCLUDE_FROM_ALL)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用add_subdirectory命令向CMake项目中添加一个子目录：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;# CMakeLists.txt

# 添加一个子目录
add_subdirectory(my_library)

# 在当前目录中定义一个可执行文件
add_executable(my_app main.cpp)

# 将子目录中的库添加到可执行文件中
target_link_libraries(my_app my_library)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用链接库&#34;&gt;使用链接库&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;ADD_LIBRARY(libname [SHARED|STATIC|MODULE][EXCLUDE_FROM_ALL] source1 source2 ... sourceN)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SHARED&lt;/code&gt;, 动态库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STATIC&lt;/code&gt;, 静态库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MODULE&lt;/code&gt;，在使用&lt;code&gt;dyld&lt;/code&gt;的系统有效，如果不支持&lt;code&gt;dyld&lt;/code&gt;，则被当做&lt;code&gt;SHARED&lt;/code&gt;对待。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXCLUDE_FROM_ALL&lt;/code&gt;参数的意思是这个不会被默认构建，除非有其他的组件依赖或者手工构建。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用命令 &lt;code&gt;add_library&lt;/code&gt; 将 &lt;code&gt;src&lt;/code&gt; 目录中的源文件编译为静态链接库:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;aux_source_directory(. DIR_LIB_SRCS)
add_library (MathFunctions ${DIR_LIB_SRCS})
使用命令 target_link_libraries 指明可执行文件需要连接一个链接库
target_link_libraries(my_test MathFunctions)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;配置头文件&#34;&gt;配置头文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;configure_file&lt;/code&gt; 命令用于加入一个配置头文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;configure_file (
&amp;quot;${PROJECT_SOURCE_DIR}/config.h.in&amp;quot;
&amp;quot;${PROJECT_BINARY_DIR}/config.h&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里配置头文件 &lt;code&gt;config.h&lt;/code&gt; 由 &lt;code&gt;CMake&lt;/code&gt; 从 &lt;code&gt;config.h.in&lt;/code&gt; 生成，通过这样的机制，可以通过预定义一些参数和变量来控制代码的生成。&lt;/p&gt;
&lt;h3 id=&#34;自定义编译选项&#34;&gt;自定义编译选项&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;option &lt;/code&gt;命令可以添加一个选项，并且设置默认值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;option (USE_MYMATH &amp;quot;Use provided math implementation&amp;quot; ON)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里添加了一个 &lt;code&gt;USE_MYMATH&lt;/code&gt; 选项，并且默认值为&lt;code&gt;ON&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接着在&lt;code&gt;config.h.in&lt;/code&gt;文件中使用该选项：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;#cmakedefine USE_MYMATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样 CMake 会自动根据 &lt;code&gt;CMakeLists&lt;/code&gt; 配置文件中的设置自动生成 &lt;code&gt;config.h&lt;/code&gt; 文件&lt;/p&gt;
&lt;h3 id=&#34;添加库的使用要求&#34;&gt;添加库的使用要求&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;INTERFACE&lt;/code&gt;是指消费者需要、但生产者不需要的那些东西&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;INTERFACE&lt;/code&gt;可以指定使用要求 使得任何使用该库的文件自动包含该路径&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了 &lt;code&gt;INTERFACE&lt;/code&gt;，还有&lt;code&gt;PRIVATE&lt;/code&gt; 和 &lt;code&gt;PUBLIC&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;INTERFACE&lt;/code&gt;表示消费者需要生产者不需要&lt;br&gt;
&lt;code&gt;PRIVATE&lt;/code&gt;表示消费者不需要生产者需要&lt;br&gt;
&lt;code&gt;PUBLIC&lt;/code&gt; 表示消费者和生产者都需要。&lt;/p&gt;
&lt;h2 id=&#34;如何安装&#34;&gt;如何安装&lt;/h2&gt;
&lt;p&gt;通过在bash中调用如下指令可以安装cmake目标文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cmake -D CMAKE_INSTALL_PREFIX=/usr .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在安装前，需要在&lt;code&gt;CMakeLists&lt;/code&gt;中定义好如何安装&lt;/p&gt;
&lt;p&gt;&lt;code&gt;INSTALL&lt;/code&gt;指令包含了各种类型，我们需要一个个分开解释&lt;/p&gt;
&lt;h3 id=&#34;目标文件的安装&#34;&gt;目标文件的安装&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;INSTALL(TARGETS targets ...
[
  [ARCHIVE|LIBRARY|RUNTIME]
  [DESTINATION &amp;lt;dir&amp;gt;]
  [PERMISSIONS permissions ...]
  [CONFIGURATIONS [Debug|Release|...]]
  [COMPONENT &amp;lt;component&amp;gt;]
  [OPTIONAL]
]
[...])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TARGETS后面跟的就是我们通过&lt;code&gt;ADD_EXECUTABLE&lt;/code&gt;或者&lt;code&gt;ADD_LIBRARY&lt;/code&gt;定义的目标文&lt;br&gt;
件，可能是可执行二进制、动态库、静态库。&lt;/p&gt;
&lt;p&gt;目标类型：&lt;code&gt;ARCHIVE&lt;/code&gt;特指静态库，&lt;code&gt;LIBRARY&lt;/code&gt;特指动态库，&lt;code&gt;RUNTIME&lt;/code&gt;特指可执行目标二&lt;br&gt;
进制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DESTINATION&lt;/code&gt;定义了安装的路径，如果路径以/开头，那么指的是绝对路径，这时候&lt;br&gt;
&lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt;其实就无效了。&lt;/p&gt;
&lt;p&gt;如果你希望使用&lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt;来定义安装路径，就要写成相对路径，不要以&lt;code&gt;/&lt;/code&gt;开头&lt;br&gt;
安装后的路径就是 &lt;code&gt;${CMAKE_INSTALL_PREFIX}/&amp;lt;DESTINATION定义的路径&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;INSTALL(TARGETS myrun mylib mystaticlib
RUNTIME DESTINATION bin
LIBRARY DESTINATION lib
ARCHIVE DESTINATION libstatic
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里将二进制文件&lt;code&gt;myrun&lt;/code&gt;安装到&lt;code&gt;${CMAKE_INSTALL_PREFIX}/bin&lt;/code&gt;目录&lt;br&gt;
将动态库&lt;code&gt;mylib&lt;/code&gt;安装到 &lt;code&gt;${CMAKE_INSTALL_PREFIX}/lib&lt;/code&gt;目录&lt;br&gt;
将静态库&lt;code&gt;mystaticlib&lt;/code&gt;安装到 &lt;code&gt;${CMAKE_INSTALL_PREFIX}/libstatic&lt;/code&gt;目录。&lt;/p&gt;
&lt;h2 id=&#34;为工程添加测试&#34;&gt;为工程添加测试&lt;/h2&gt;
&lt;p&gt;添加测试同样很简单。&lt;code&gt;CMake&lt;/code&gt; 提供了一个称为 &lt;code&gt;CTest&lt;/code&gt; 的测试工具。&lt;code&gt;CTest&lt;/code&gt;是&lt;code&gt;CMake&lt;/code&gt;的一个附加模块，它提供了一组工具和命令，用于自动化测试和测试结果的收集和报告。我们要做的只是在项目根目录的 &lt;code&gt;CMakeLists&lt;/code&gt; 文件中调用一系列的 &lt;code&gt;add_test&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;以下是使用CTest添加测试的一般步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;CMakeLists.txt&lt;/code&gt;文件中添加&lt;code&gt;enable_testing()&lt;/code&gt;命令，以启用&lt;code&gt;CTest&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;add_test()&lt;/code&gt;命令添加测试。该命令需要两个参数：&lt;code&gt;测试名称&lt;/code&gt;和&lt;code&gt;测试命令&lt;/code&gt;。&lt;code&gt;测试命令&lt;/code&gt;可以是任何可执行文件或脚本，用于运行测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;add_executable()&lt;/code&gt;命令定义测试可执行文件。测试可执行文件应该包含测试代码，并输出测试结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;target_link_libraries()&lt;/code&gt;命令将测试可执行文件链接到需要测试的库或可执行文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用CTest添加测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;# CMakeLists.txt

# 启用CTest
enable_testing()

# 添加一个测试 测试程序是否成功运行
add_test(test_run my_test 5 2)

# 测试帮助信息是否可以正常提示
add_test(test_usage my_test)
set_tests_properties(test_usage
  PROPERTIES PASS_REGULAR_EXPRESSION &amp;quot;Usage: .* base exponent&amp;quot;)

# 测试 5 的平方
add_test(test_5_2 my_test 5 2)
set_tests_properties(test_5_2
  PROPERTIES PASS_REGULAR_EXPRESSION &amp;quot;is 25&amp;quot;)

# 测试 10 的 5 次方
add_test(test_10_5 my_test 10 5)
set_tests_properties(test_10_5
  PROPERTIES PASS_REGULAR_EXPRESSION &amp;quot;is 100000&amp;quot;)

# 测试 2 的 10 次方
add_test (test_2_10 my_test 2 10)
set_tests_properties(test_2_10
  PROPERTIES PASS_REGULAR_EXPRESSION &amp;quot;is 1024&amp;quot;)

# 定义测试可执行文件
add_executable(my_test my_test.cpp)

# 将测试可执行文件链接到需要测试的库或可执行文件
target_link_libraries(my_test my_library)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;test_run&lt;/code&gt; 用来测试程序是否成功运行并返回 0 值&lt;br&gt;
使用&lt;code&gt;set_tests_properties()&lt;/code&gt;命令设置了测试属性，将&lt;code&gt;PASS_REGULAR_EXPRESSION&lt;/code&gt;属性设置为一个正则表达式，用于匹配测试输出中的帮助信息是否包含后面跟着的字符串。&lt;/p&gt;
&lt;p&gt;我们可以使用&lt;code&gt;marco&lt;/code&gt;命令定义一个宏来简化测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;# 定义一个宏，用来简化测试工作
macro (do_test arg1 arg2 result)
  add_test(test_${arg1}_${arg2} my_test ${arg1} ${arg2})
  set_tests_properties (test_${arg1}_${arg2}
    PROPERTIES PASS_REGULAR_EXPRESSION ${result})
endmacro (do_test)

# 使用该宏进行一系列的数据测试
do_test(5 2 &amp;quot;is 25&amp;quot;)
do_test (10 5 &amp;quot;is 100000&amp;quot;)
do_test (2 10 &amp;quot;is 1024&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码定义了一个名为&lt;code&gt;do_test&lt;/code&gt;的宏，用于添加测试和设置测试属性。该宏接受三个参数：&lt;code&gt;arg1&lt;/code&gt;、&lt;code&gt;arg2&lt;/code&gt;和&lt;code&gt;result&lt;/code&gt;，分别表示测试的输入参数和期望输出结果。&lt;/p&gt;
&lt;p&gt;在宏的实现中，我们首先使用&lt;code&gt;add_test()&lt;/code&gt;命令添加一个名为&lt;code&gt;test_${arg1}_${arg2}&lt;/code&gt;的测试，并指定测试命令为&lt;code&gt;my_test&lt;/code&gt;，输入参数为&lt;code&gt;${arg1}&lt;/code&gt;和&lt;code&gt;${arg2}&lt;/code&gt;。然后，我们使用&lt;code&gt;set_tests_properties()&lt;/code&gt;命令设置测试属性，将&lt;code&gt;PASS_REGULAR_EXPRESSION&lt;/code&gt;属性设置为&lt;code&gt;${result}&lt;/code&gt;，用于匹配测试输出中的期望结果。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;add_custom_target()&lt;/code&gt;命令可以添加自定义测试目标，如代码覆盖率测试、性能测试等。自定义测试目标是一种特殊的目标，它不会生成任何实际的输出文件，而是用于运行测试命令和收集测试结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码覆盖率&lt;/strong&gt;是一种衡量软件测试质量的指标，用于评估测试是否覆盖了被测试代码的所有执行路径。它通常用百分比表示，表示被测试代码中被测试的部分占总代码量的比例。&lt;br&gt;
常见的代码覆盖率指标包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;语句覆盖率（Statement Coverage）：测试覆盖了被测试代码中的所有语句的比例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分支覆盖率（Branch Coverage）：测试覆盖了被测试代码中的所有分支的比例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数覆盖率（Function Coverage）：测试覆盖了被测试代码中的所有函数的比例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;条件覆盖率（Condition Coverage）：测试覆盖了被测试代码中的所有条件的比例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路径覆盖率（Path Coverage）：测试覆盖了被测试代码中的所有执行路径的比例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是使用&lt;code&gt;add_custom_target()&lt;/code&gt;命令添加自定义测试目标的一般步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;add_custom_target()&lt;/code&gt;命令添加自定义测试目标。该命令需要两个参数：目标名称和测试命令。测试命令可以是任何可执行文件或脚本，用于运行测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;add_dependencies()&lt;/code&gt;命令将自定义测试目标添加到CTest的测试目标中。这样，当我们运行ctest命令时，CTest会自动运行自定义测试目标，并将测试结果收集到CTest的测试报告中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;# CMakeLists.txt

# 添加一个自定义测试目标，用于运行代码覆盖率测试
add_custom_target(coverage
  COMMAND lcov --directory . --capture --output-file coverage.info
  COMMAND genhtml coverage.info --output-directory coverage-report
  WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
  COMMENT &amp;quot;Generating code coverage report&amp;quot;
)

# 将自定义测试目标添加到CTest的测试目标中
add_dependencies(test coverage)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，我们使用&lt;code&gt;add_custom_target()&lt;/code&gt;命令添加一个名为&lt;code&gt;coverage&lt;/code&gt;的自定义测试目标，并指定测试命令为运行代码覆盖率测试的命令。&lt;/p&gt;
&lt;p&gt;这个命令使用&lt;code&gt;lcov&lt;/code&gt;工具和&lt;code&gt;genhtml&lt;/code&gt;工具生成代码覆盖率报告，并将报告输出到&lt;code&gt;coverage-report&lt;/code&gt;目录中。我们还使用&lt;code&gt;WORKING_DIRECTORY&lt;/code&gt;选项指定工作目录为&lt;code&gt;CMake&lt;/code&gt;的二进制目录，以便正确地生成测试报告。&lt;/p&gt;
&lt;p&gt;最后，我们使用&lt;code&gt;add_dependencies()&lt;/code&gt;命令将自定义测试目标&lt;code&gt;coverage&lt;/code&gt;添加到&lt;code&gt;CTest&lt;/code&gt;的测试目标&lt;code&gt;test&lt;/code&gt;中，以便&lt;code&gt;CTest&lt;/code&gt;能够自动运行代码覆盖率测试，并将测试结果收集到测试报告中。&lt;/p&gt;
&lt;h2 id=&#34;支持-gdb&#34;&gt;支持 gdb&lt;/h2&gt;
&lt;p&gt;让 CMake 支持 gdb 的设置也很容易，只需要指定 Debug 模式下开启 &lt;code&gt;-g&lt;/code&gt; 选项：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;set(CMAKE_BUILD_TYPE &amp;quot;Debug&amp;quot;)
set(CMAKE_CXX_FLAGS_DEBUG &amp;quot;$ENV{CXXFLAGS} -O0 -Wall -g -ggdb&amp;quot;)
set(CMAKE_CXX_FLAGS_RELEASE &amp;quot;$ENV{CXXFLAGS} -O3 -Wall&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码设置了CMake的构建类型为&lt;code&gt;Debug&lt;/code&gt;，并分别设置了&lt;code&gt;CMAKE_CXX_FLAGS_DEBUG&lt;/code&gt;和&lt;code&gt;CMAKE_CXX_FLAGS_RELEASE&lt;/code&gt;变量，用于指定不同构建类型下的编译选项。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Debug&lt;/code&gt;构建类型下，我们设置了以下编译选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$ENV{CXXFLAGS}&lt;/code&gt;：从环境变量&lt;code&gt;CXXFLAGS&lt;/code&gt;中获取其他编译选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-O0&lt;/code&gt;：关闭优化，以便在调试时能够更好地查看代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-Wall&lt;/code&gt;：开启所有警告，以便在编译时能够发现潜在的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-g&lt;/code&gt;：生成调试信息，以便在调试时能够更好地查看代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-ggdb&lt;/code&gt;：生成gdb专属调试信息，以便在使用gdb调试器时能够更好地查看代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;code&gt;Release&lt;/code&gt;构建类型下，我们设置了以下编译选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$ENV{CXXFLAGS}&lt;/code&gt;：从环境变量&lt;code&gt;CXXFLAGS&lt;/code&gt;中获取其他编译选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-O3&lt;/code&gt;：开启最高级别的优化，以便在发布时能够获得最佳的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-&lt;code&gt;Wall&lt;/code&gt;：开启所有警告，以便在编译时能够发现潜在的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些编译选项可以帮助我们在不同的构建类型下编译和调试代码，并优化代码的性能和质量。在实际使用中，我们可以根据具体的项目需求和编译环境来调整这些编译选项，并使用其他选项和工具来进一步优化代码的性能和质量。&lt;/p&gt;
&lt;h2 id=&#34;生成安装包&#34;&gt;生成安装包&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;CPack&lt;/code&gt; ，它同样也是由 CMake 提供的一个工具，专门用于打包。首先在顶层的&lt;code&gt;CMakeLists.txt&lt;/code&gt; 文件尾部添加下面几行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#构建一个CPack安装包
include(InstallRequiredSystemLibraries)
set(CPACK_RESOURCE_FILE_LICENSE
  &amp;quot;${CMAKE_CURRENT_SOURCE_DIR}/License. txt&amp;quot;)
set(CPACK_PACKAGE_VERSION_MAJOR &amp;quot;${Demo_VERSION_MAJOR}&amp;quot; )
set(CPACK_PACKAGE__VERSION_MINOR &amp;quot;${Demo_VERSION_MINOR}&amp;quot;)
include(CPack)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码使用了&lt;code&gt;CPack&lt;/code&gt;模块来生成软件包，并设置了一些软件包相关的属性。&lt;/p&gt;
&lt;p&gt;首先，我们使用&lt;code&gt;include(InstallRequiredSystemLibraries)&lt;/code&gt;命令来包含&lt;code&gt;InstallRequiredSystemLibraries&lt;/code&gt;模块，以便在安装软件包时自动安装所需的系统库。&lt;/p&gt;
&lt;p&gt;然后，我们使用&lt;code&gt;set()&lt;/code&gt;命令设置了以下软件包属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CPACK_RESOURCE_FILE_LICENSE&lt;/code&gt;：指定软件包的许可证文件路径。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CPACK_PACKAGE_VERSION_MAJOR&lt;/code&gt;：指定软件包的主版本号，通常表示重大更新或功能变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CPACK_PACKAGE_VERSION_MINOR&lt;/code&gt;：指定软件包的次版本号，通常表示小的更新或修复。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，我们使用&lt;code&gt;include(CPack)&lt;/code&gt;命令包含&lt;code&gt;CPack&lt;/code&gt;模块，以便生成软件包。&lt;code&gt;CPack&lt;/code&gt;模块提供了许多选项和变量，可以帮助我们生成各种类型的软件包，如ZIP、TGZ、RPM、DEB等。我们可以根据具体的需求和环境来调整这些选项和变量，以生成符合要求的软件包。&lt;/p&gt;
&lt;p&gt;请注意，这段代码中的变量&lt;code&gt;${Demo_VERSION_MAJOR}&lt;/code&gt;和&lt;code&gt;${Demo_VERSION_MINOR}&lt;/code&gt;是由&lt;code&gt;configure_file()&lt;/code&gt;命令生成的，用于指定软件包的版本号。在实际使用中，我们需要根据具体的项目需求和版本管理策略来设置软件包的版本号，并使用适当的选项和工具来生成和发布软件包。&lt;/p&gt;
&lt;p&gt;接着在bash下调用&lt;code&gt;cpack&lt;/code&gt;即可生成安装包&lt;br&gt;
生成二进制安装包&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cpack -C CPackConfig.cmake
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成源码安装包&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cpack -C CPackSourceConfig.cmake
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-C&lt;/code&gt;选项是&lt;code&gt;CPack&lt;/code&gt;命令的一个选项，用于指定&lt;code&gt;CPack&lt;/code&gt;的配置文件。该选项后面需要跟一个配置文件的路径或名称，以便&lt;code&gt;CPack&lt;/code&gt;使用该配置文件来生成软件包。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;cpack -C CPackConfig.cmake&lt;/code&gt;命令将使用名为C&lt;code&gt;PackConfig.cmake&lt;/code&gt;的配置文件来生成软件包。该配置文件通常包含了软件包的属性、组件、文件列表、安装目录等信息，以便根据这些信息来生成符合要求的软件包。&lt;/p&gt;
&lt;p&gt;请注意，&lt;code&gt;-C&lt;/code&gt;选项是&lt;code&gt;CPack&lt;/code&gt;命令的一个必需选项，如果没有指定该选项，&lt;code&gt;CPack&lt;/code&gt;将无法生成软件包。&lt;/p&gt;
&lt;p&gt;其他一些常用的选项:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-G &amp;lt;generator&amp;gt;&lt;/code&gt;：指定要使用的生成器，如ZIP、TGZ、RPM、DEB等。可以使用&lt;code&gt;cpack --help&lt;/code&gt;命令查看可用的生成器列表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-B &amp;lt;build-dir&amp;gt;&lt;/code&gt;：指定生成软件包的临时构建目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-R &amp;lt;regex&amp;gt;&lt;/code&gt;：指定一个正则表达式，用于选择要打包的文件和目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-D &amp;lt;variable&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;：设置CPack变量的值，用于覆盖CMakeLists.txt文件中的默认设置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-V&lt;/code&gt;：显示详细的CPack生成过程和输出信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--config &amp;lt;config-file&amp;gt;&lt;/code&gt;：指定CPack的配置文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--verbose&lt;/code&gt;：显示更详细的输出信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--help&lt;/code&gt;：显示CPack的帮助信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">[Linux] CMake</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/jHrl_01Gh/"" data-c="
          &lt;p&gt;如果程序包含很多个源文件，用gcc命令逐个去编译时，就发现很容易混乱而且工作量大，所以就出现了&lt;code&gt;make&lt;/code&gt;工具&lt;/p&gt;
&lt;p&gt;&lt;code&gt;make&lt;/code&gt;工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式——通过调用&lt;code&gt;makefile&lt;/code&gt;文件中用户指定的命令来进行编译和链接的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;makefile&lt;/code&gt;关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为&lt;code&gt;makefile&lt;/code&gt;就像一个&lt;code&gt;Shell&lt;/code&gt;脚本一样，其中也可以执行操作系统的命令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;makefile&lt;/code&gt;命令中就包含了调用&lt;code&gt;gcc&lt;/code&gt;（也可以是别的编译器）去编译某个源文件的命令。但是当工程非常大的时候，手写&lt;code&gt;makefile&lt;/code&gt;也是非常麻烦的，而且如果换了个平台&lt;code&gt;makefile&lt;/code&gt;又要重新修改，这时候就出现了&lt;code&gt;Cmake&lt;/code&gt;这个工具。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cmake&lt;/code&gt;就可以更加简单的生成&lt;code&gt;makefile&lt;/code&gt;文件给&lt;code&gt;make&lt;/code&gt;用。当然&lt;code&gt;cmake&lt;/code&gt;还可以跨平台生成对应平台能用的&lt;code&gt;makefile&lt;/code&gt;，我们就不用再自己去修改了。&lt;code&gt;cmake&lt;/code&gt;根据一个叫&lt;code&gt;CMakeLists.txt&lt;/code&gt;文件（学名：组态档）去生成&lt;code&gt;makefile&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;总的来说 就是由&lt;code&gt;cmake&lt;/code&gt;来跨平台生成&lt;code&gt;makefile&lt;/code&gt;，再由&lt;code&gt;make/ninja&lt;/code&gt;等编译工具根据&lt;code&gt;makefile&lt;/code&gt;的规范进行编译&lt;/p&gt;
&lt;h2 id=&#34;语法规则&#34;&gt;语法规则&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Makefile&lt;/code&gt;的规则:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;target ... : prerequisites ...
  command
  ... 
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;targets&lt;/code&gt;是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;command&lt;/code&gt;是命令行，如果其不与&lt;code&gt;target:prerequisites&lt;/code&gt;在一行，那么，必须以&lt;code&gt;[Tab键]&lt;/code&gt;开头，如果和&lt;code&gt;prerequisites&lt;/code&gt;在一行，那么可以用分号做为分隔。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;prerequisites&lt;/code&gt;也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是&lt;code&gt;过时的&lt;/code&gt;，被认为是需要重生成的。&lt;/p&gt;
&lt;p&gt;如果命令太长，可以使用反斜框（&lt;code&gt;/&lt;/code&gt;）作为换行符。&lt;code&gt;make&lt;/code&gt;对一行上有多少个字符没有限制。&lt;/p&gt;
&lt;p&gt;规则告诉&lt;code&gt;make&lt;/code&gt;两件事，&lt;strong&gt;文件的依赖关系&lt;/strong&gt;和&lt;strong&gt;如何成成目标文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一般来说，&lt;code&gt;make&lt;/code&gt;会以&lt;code&gt;UNIX&lt;/code&gt;的标准&lt;code&gt;Shell&lt;/code&gt;，也就是&lt;code&gt;/bin/sh&lt;/code&gt;来执行命令。&lt;/p&gt;
&lt;p&gt;文件的依赖关系，也就是说，&lt;code&gt;target&lt;/code&gt;这一个或多个的目标文件依赖于&lt;code&gt;prerequisites&lt;/code&gt;中的文件，其生成规则定义在&lt;code&gt;command&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;说白一点就是说，&lt;code&gt;prerequisites&lt;/code&gt;中如果有一个以上的文件比&lt;code&gt;target&lt;/code&gt;文件要新的话，&lt;code&gt;command&lt;/code&gt;所定义的命令就会被执行。这就是&lt;code&gt;Makefile&lt;/code&gt;的规则。也就是&lt;code&gt;Makefile&lt;/code&gt;中最核心&lt;br&gt;
的内容。&lt;/p&gt;
&lt;p&gt;我们可以在一个&lt;code&gt;makefile&lt;/code&gt;中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，清除中间文件等等。&lt;br&gt;
可以定义一个目标文件其冒号后什么也没有，那么，&lt;code&gt;make&lt;/code&gt;就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在&lt;code&gt;make&lt;/code&gt;命令后明显得指出这个&lt;code&gt;lable&lt;/code&gt;(也就是target)的名字。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688097949330.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
其中&lt;code&gt;clean&lt;/code&gt;为清除中间文件的命令 调用时使用&lt;code&gt;make clean&lt;/code&gt;调用&lt;/p&gt;
&lt;h3 id=&#34;编译makefile&#34;&gt;编译makefile&lt;/h3&gt;
&lt;p&gt;在默认的方式下，也就是我们只输入&lt;code&gt;make&lt;/code&gt;命令。那么，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;make&lt;/code&gt;默认会在当前目录下找名字叫&lt;code&gt;Makefile&lt;/code&gt;或&lt;code&gt;makefile&lt;/code&gt;的文件。要指定特定的&lt;code&gt;Makefile&lt;/code&gt;，你可以使用&lt;code&gt;make&lt;/code&gt;的&lt;code&gt;-f&lt;/code&gt;和&lt;code&gt;--file&lt;/code&gt;参数，如：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make -f Make.Linux
make --file Make.AIX
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;如果找到&lt;code&gt;makefile&lt;/code&gt;文件，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到&lt;code&gt;demo.out&lt;/code&gt;这个文件，并把这个文件作为最终的目标文件。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;demo.out&lt;/code&gt;文件不存在，或是&lt;code&gt;demo.out&lt;/code&gt;所依赖的后面的 &lt;code&gt;.o&lt;/code&gt; 文件的文件修改时间要比这个目标文件新，那么，他就会执行后面所定义的命令来生成&lt;code&gt;demo.out&lt;/code&gt;这个文件。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;demo.ou&lt;/code&gt;t所依赖的&lt;code&gt;.o&lt;/code&gt;文件也不存在，那么&lt;code&gt;make&lt;/code&gt;会在当前文件中找目标为&lt;code&gt;.o&lt;/code&gt;文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）&lt;/li&gt;
&lt;li&gt;当然，找到最后你的&lt;code&gt;C&lt;/code&gt;源文件和&lt;code&gt;H&lt;/code&gt;头文件是存在的啦，于是&lt;code&gt;make&lt;/code&gt;会生成 &lt;code&gt;.o&lt;/code&gt; 文件，然后再用 .&lt;code&gt;o &lt;/code&gt;文件完成&lt;code&gt;make&lt;/code&gt;的终极任务，也就是执行文件&lt;code&gt;demo.out&lt;/code&gt;了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这就是整个&lt;code&gt;make&lt;/code&gt;的依赖性，&lt;code&gt;make&lt;/code&gt;会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么&lt;code&gt;make&lt;/code&gt;就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，&lt;code&gt;make&lt;/code&gt;会忽略。&lt;/p&gt;
&lt;h3 id=&#34;具体规则&#34;&gt;具体规则&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Makefile&lt;/code&gt;里主要包含了五个东西：&lt;strong&gt;变量定义、显式规则、隐晦规则、文件指示和注释&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;变量的定义&lt;/strong&gt;。&lt;code&gt;Makefile&lt;/code&gt;中的变量其实就是C/C++中的宏，当&lt;code&gt;Makefile&lt;/code&gt;被执行时，其中的变量都会被扩展到相应的引用位置上。&lt;br&gt;
例如上面我们需要编辑的文件有两个 那么我们可以将其定义为 &lt;code&gt;objects = test.o demo.o&lt;/code&gt; 以帮助我们在更多文件时减少重复使用。使用变量时，通过&lt;code&gt;$(变量名)&lt;/code&gt;调用。Eg. &lt;code&gt;$(objects)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用关键字 &lt;code&gt;wildcard&lt;/code&gt;可以让通配符在变量中展开&lt;br&gt;
在Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数&lt;code&gt;wildcard&lt;/code&gt;，它的用法是：&lt;code&gt;$(wildcard PATTERN...)&lt;/code&gt; 。&lt;br&gt;
在Makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。如果不存在任何符合此模式的文件，函数会忽略模式字符并返回空。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;objects := $(wildcard *.o) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里，&lt;code&gt;objects&lt;/code&gt;的值是所有&lt;code&gt;.o&lt;/code&gt;的文件名的集合&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;显式规则&lt;/strong&gt;。显式规则说明了，如何生成一个或多的的目标文件。这是由&lt;code&gt;Makefile&lt;/code&gt;的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。 刚才写的形似&lt;code&gt;shell&lt;/code&gt;脚本的&lt;code&gt;Makefile&lt;/code&gt;全部都是显示规则。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隐晦规则&lt;/strong&gt;。由于我们的&lt;code&gt;make&lt;/code&gt;有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写&lt;code&gt;Makefile&lt;/code&gt;，这是由&lt;code&gt;make&lt;/code&gt;所支持的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件指示&lt;/strong&gt;。其包括了三个部分
&lt;ul&gt;
&lt;li&gt;第一个是在一个&lt;code&gt;Makefile&lt;/code&gt;中引用另一个Makefile，就像C语言中的include一样&lt;/li&gt;
&lt;li&gt;第二个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样&lt;/li&gt;
&lt;li&gt;第三个就是定义一个多行的命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注释&lt;/strong&gt;。Makefile中只有行注释，和UNIX的&lt;code&gt;Shell&lt;/code&gt;脚本一样，其注释是用&lt;code&gt;#&lt;/code&gt;字符，这个就像C/C++中的&lt;code&gt;//&lt;/code&gt;一样。如果你要在你的&lt;code&gt;Makefile&lt;/code&gt;中使用&lt;code&gt;#&lt;/code&gt;字符，可以用反斜框进行转义，如：`/#``。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;make&lt;/code&gt;很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个&lt;code&gt;[.o]&lt;/code&gt;文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。&lt;/p&gt;
&lt;p&gt;只要&lt;code&gt;make&lt;/code&gt;看到一个&lt;code&gt;[.o]&lt;/code&gt;文件，它就会自动的把&lt;code&gt;[.c]&lt;/code&gt;文件加在依赖关系中,并且命令 &lt;code&gt;gcc -c xx.c&lt;/code&gt; 也会被推导出来，于是，我们的makefile再也不用写得上面这么复杂。&lt;/p&gt;
&lt;p&gt;同时 也可以将多个目标文件写在一起共享同一个依赖&lt;/p&gt;
&lt;p&gt;为了避免和文件重名的情况，我们可以使用一个特殊的标记&lt;code&gt;.PHONY&lt;/code&gt;来显示地指明一个目标是&lt;code&gt;伪目标&lt;/code&gt;，向&lt;code&gt;make&lt;/code&gt;说明，不管是否有这个文件，这个目标就是&lt;code&gt;伪目标&lt;/code&gt;。&lt;br&gt;
&lt;code&gt;.PHONY&lt;/code&gt;表示，&lt;code&gt;clean&lt;/code&gt;是个伪目标文件&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688097941130.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rm&lt;/code&gt;命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.SUFFIXES&lt;/code&gt;: 用于配置&amp;quot;后缀规则&amp;quot;。后缀规则是&lt;code&gt;.a&lt;/code&gt; &lt;code&gt;.b&lt;/code&gt;形式的规则，例如在&lt;code&gt;.f .o&lt;/code&gt;规则中到的规则。它们是一种告诉&lt;code&gt;make&lt;/code&gt;的方法，只要您看到例如&lt;code&gt;.f&lt;/code&gt;文件(源文件)，就可以按照该规则从其中创建&lt;code&gt;.o&lt;/code&gt;文件(目标文件).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;.SUFFIXES：.c .o
.c.o:
gcc -c -o $@ $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这等效于%形成模式规则：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;%.o: %.c
gcc -c -o $@ $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;Makefile&lt;/code&gt;使用&lt;code&gt;include&lt;/code&gt;关键字可以把别的&lt;code&gt;Makefile&lt;/code&gt;包含进来，这很像C语言的&lt;code&gt;#include&lt;/code&gt;，被包含的文件会原模原样的放在当前文件的包含位置。&lt;br&gt;
&lt;code&gt;include&lt;/code&gt;的语法是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;include &amp;lt;filename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;filename&lt;/code&gt;可以是当前操作系统Shell的文件模式（可以保含路径和通配符）&lt;/p&gt;
&lt;h3 id=&#34;执行步骤&#34;&gt;执行步骤&lt;/h3&gt;
&lt;p&gt;GNU的&lt;code&gt;make&lt;/code&gt;工作时的执行步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读入所有的&lt;code&gt;Makefile&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;读入被&lt;code&gt;include&lt;/code&gt;的其它&lt;code&gt;Makefile&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;初始化文件中的变量。&lt;/li&gt;
&lt;li&gt;推导隐晦规则，并分析所有规则。&lt;/li&gt;
&lt;li&gt;为所有的目标文件创建依赖关系链。&lt;/li&gt;
&lt;li&gt;根据依赖关系，决定哪些目标要重新生成。&lt;/li&gt;
&lt;li&gt;执行生成命令。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;预定义变量&#34;&gt;预定义变量&lt;/h2&gt;
&lt;p&gt;常用的预定义变量:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$*&lt;/code&gt; 不包含扩展名的目标文件名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$+&lt;/code&gt; 所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&amp;lt;&lt;/code&gt; 第一个依赖文件的名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$?&lt;/code&gt; 所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$@&lt;/code&gt; 目前规则中所有的目标的集合。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$^&lt;/code&gt; 所有的依赖文件，以空格分开，不包含重复的依赖文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$%&lt;/code&gt; 如果目标是归档成员，则该变量表示目标的归档成员名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件搜索&#34;&gt;文件搜索&lt;/h2&gt;
&lt;p&gt;可以通过 定义特殊变量&lt;code&gt;VPATH&lt;/code&gt;，&lt;code&gt;make&lt;/code&gt;就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。&lt;br&gt;
目录由&lt;code&gt;:&lt;/code&gt;分隔。（当然，当前目录永远是最高优先搜索的地方）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;VPATH = src : ../header
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一个设置文件搜索路径的方法是使用&lt;code&gt;make&lt;/code&gt;的&lt;code&gt;vpath&lt;/code&gt;&lt;strong&gt;关键字&lt;/strong&gt;（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为符合模式&lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;的文件指定搜索目录&lt;code&gt;&amp;lt;directories&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;vpath &amp;lt;pattern&amp;gt; &amp;lt;directories&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;清除符合模式&lt;pattern&gt;的文件的搜索目录。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;vpath &amp;lt;pattern&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;清除所有已被设置好了的文件搜索目录。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;vpath
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;vapth&lt;/code&gt;使用方法中的&lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;需要包含&lt;code&gt;%&lt;/code&gt;字符。&lt;code&gt;%&lt;/code&gt;的意思是匹配零或若干字符，例如，&lt;code&gt;%.h&lt;/code&gt;表示所有以&lt;code&gt;.h&lt;/code&gt;结尾的文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;指定了要搜索的文件集，而&lt;code&gt;&amp;lt;directories&amp;gt;&lt;/code&gt;则指定了&lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;的文件集的搜索的目录。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;vpath %.h ../headers
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该语句表示，要求&lt;code&gt;make&lt;/code&gt;在&lt;code&gt;../headers&lt;/code&gt;目录下搜索所有以&lt;code&gt;.h&lt;/code&gt;结尾的文件。（如果某文件在当前目录没有找到的话）&lt;/p&gt;
&lt;h2 id=&#34;静态模式&#34;&gt;静态模式&lt;/h2&gt;
&lt;p&gt;静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;&amp;lt;targets ...&amp;gt;: &amp;lt;target-pattern&amp;gt;: &amp;lt;prereq-patterns ...&amp;gt;
  &amp;lt;commands&amp;gt;
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;targets&lt;/code&gt;定义了一系列的目标文件，可以有通配符。是目标的一个集合。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;target-parrtern&lt;/code&gt;是指明了&lt;code&gt;targets&lt;/code&gt;的模式，也就是目标集模式，是从&lt;code&gt;targets&lt;/code&gt;中取出的目标集。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;prereq-parrterns&lt;/code&gt;是目标的依赖模式，它对&lt;code&gt;target-parrtern&lt;/code&gt;形成的模式再进行一次依赖目标的定义。即对&lt;code&gt;targets&lt;/code&gt;中取出的目标集更改&lt;code&gt;%&lt;/code&gt;后内容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;objects = foo.o bar.o
all: $(objects)
$(objects): %.o: %.c
$(CC) -c $(CFLAGS) $&amp;lt; -o $@
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的例子中，指明了我们的目标从&lt;code&gt;$object&lt;/code&gt;中获取，&lt;code&gt;%.o&lt;/code&gt;表明要所有以&lt;code&gt;.o&lt;/code&gt;结尾的目标，也就是&lt;code&gt;foo.o&lt;/code&gt; &lt;code&gt;bar.o&lt;/code&gt;，也就是变量&lt;code&gt;$object&lt;/code&gt;集合的模式&lt;/p&gt;
&lt;p&gt;而依赖模式&lt;code&gt;%.c&lt;/code&gt;则取模式&lt;code&gt;%.o&lt;/code&gt;的&lt;code&gt;%&lt;/code&gt;，也就是&lt;code&gt;foo bar&lt;/code&gt;，并为其加下&lt;code&gt;.c&lt;/code&gt;的后缀，于是，我们的依赖目标就是&lt;code&gt;foo.c bar.c&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;命令中的&lt;code&gt;$&amp;lt;&lt;/code&gt;和&lt;code&gt;$@&lt;/code&gt;则是自动化变量，&lt;code&gt;$&amp;lt;&lt;/code&gt;表示所有的依赖目标集（也就是&lt;code&gt;foo.c bar.c&lt;/code&gt;），&lt;code&gt;$@&lt;/code&gt;表示目标集（也就是&lt;code&gt;foo.o bar.o&lt;/code&gt;）。&lt;/p&gt;
&lt;h2 id=&#34;书写命令&#34;&gt;书写命令&lt;/h2&gt;
&lt;p&gt;通常，&lt;code&gt;make&lt;/code&gt;会把其要执行的命令行在命令执行前输出到屏幕上。当我们用&lt;code&gt;@&lt;/code&gt;字符在命令行前，那么，这个命令将不被&lt;code&gt;make&lt;/code&gt;显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;@echo 正在编译XXX模块......
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当&lt;code&gt;make&lt;/code&gt;执行时，会输出&lt;code&gt;正在编译XXX模块......&lt;/code&gt;字串，但不会输出命令，如果没有&lt;code&gt;@&lt;/code&gt;，那么，&lt;code&gt;make&lt;/code&gt;将输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo 正在编译XXX模块......
正在编译XXX模块......
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;make&lt;/code&gt;执行时，带入make参数&lt;code&gt;-n&lt;/code&gt;或&lt;code&gt;--just-print&lt;/code&gt;，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的&lt;code&gt;Makefile&lt;/code&gt;，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。&lt;/p&gt;
&lt;p&gt;如果要让上一条命令的结果应用在下一条命令时，你应该&lt;strong&gt;使用分号分隔这两条命令&lt;/strong&gt;。比如你的第一条命令是&lt;code&gt;cd&lt;/code&gt;命令，你希望第二条命令得在&lt;code&gt;cd&lt;/code&gt;之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。&lt;/p&gt;
&lt;p&gt;每当命令运行完后，&lt;code&gt;make&lt;/code&gt;会检测每个命令的返回码，如果命令返回成功，那么&lt;code&gt;make&lt;/code&gt;会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么&lt;code&gt;make&lt;/code&gt;就会终止执行当前规则，这将有可能终止所有规则的执行。&lt;/p&gt;
&lt;p&gt;但有些时候，命令的出错并不表示就是错误的。例如&lt;code&gt;mkdir&lt;/code&gt;命令，我们一定需要建立一个目录，如果目录不存在，那么&lt;code&gt;mkdir&lt;/code&gt;就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用&lt;code&gt;mkdir&lt;/code&gt;的意思就是一定要有这样的一个目录，于是我们就不希望&lt;code&gt;mkdir&lt;/code&gt;出错而终止规则的运行。&lt;/p&gt;
&lt;p&gt;为了做到这一点，需要忽略命令的出错，我们可以在&lt;code&gt;Makefile&lt;/code&gt;的命令行前加一个减号&lt;code&gt;-&lt;/code&gt;（在&lt;code&gt;Tab&lt;/code&gt;键之后），标记为不管命令出不出错都认为是成功的。&lt;/p&gt;
&lt;h3 id=&#34;嵌套执行make&#34;&gt;嵌套执行make&lt;/h3&gt;
&lt;p&gt;在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的&lt;code&gt;Makefile&lt;/code&gt;，这有利于让我们的Makefile变得更加地简洁&lt;/p&gt;
&lt;p&gt;例如，我们有一个子目录叫&lt;code&gt;subdir&lt;/code&gt;，这个目录下有个&lt;code&gt;Makefile&lt;/code&gt;文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;subsystem:
cd subdir &amp;amp;&amp;amp; $(MAKE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们把这个&lt;code&gt;Makefile&lt;/code&gt;叫做&lt;code&gt;总控Makefile&lt;/code&gt;，&lt;code&gt;总控Makefile&lt;/code&gt;的变量可以传递到下级的&lt;code&gt;Makefile&lt;/code&gt;中（如果你显示的声明），但是不会覆盖下层的&lt;code&gt;Makefile&lt;/code&gt;中所定义的变量，除非指定了&lt;code&gt;-e&lt;/code&gt;参数。&lt;/p&gt;
&lt;p&gt;如果你要传递变量到&lt;code&gt;下级Makefile&lt;/code&gt;中，那么你可以使用这样的声明：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;export &amp;lt;variable ...&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你要传递所有的变量，那么，只要一个&lt;code&gt;export&lt;/code&gt;就行了，后面什么也不用跟。&lt;/p&gt;
&lt;p&gt;如果你不想让某些变量传递到&lt;code&gt;下级Makefile&lt;/code&gt;中，那么你可以这样声明：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;unexport &amp;lt;variable ...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;定义命令包&#34;&gt;定义命令包&lt;/h3&gt;
&lt;p&gt;如果&lt;code&gt;Makefile&lt;/code&gt;中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以&lt;code&gt;define&lt;/code&gt;开始，以&lt;code&gt;endef&lt;/code&gt;结束，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;define run-yacc
yacc $(firstword $^)
mv y.tab.c $@
endef
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里，&lt;code&gt;run-yacc&lt;/code&gt;是这个命令包的名字，其不要和&lt;code&gt;Makefile&lt;/code&gt;中的变量重名。在&lt;code&gt;define&lt;/code&gt;和&lt;code&gt;endef&lt;/code&gt;中间的两行就是命令序列。&lt;/p&gt;
&lt;h3 id=&#34;变量值的替换&#34;&gt;变量值的替换。&lt;/h3&gt;
&lt;p&gt;我们可以替换变量中的共有的部分，其格式是&lt;code&gt;$(var:a=b)&lt;/code&gt;或是&lt;code&gt;${var:a=b}&lt;/code&gt;，其意思是，把变量&lt;code&gt;var&lt;/code&gt;中所有以&lt;code&gt;a&lt;/code&gt;字串&lt;code&gt;结尾&lt;/code&gt;的&lt;code&gt;a&lt;/code&gt;替换成&lt;code&gt;b&lt;/code&gt;字串。这里的&lt;code&gt;结尾&lt;/code&gt;意思是&lt;code&gt;空格&lt;/code&gt;或是&lt;code&gt;结束符&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;foo := a.o b.o c.o
bar := $(foo:.o=.c)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个示例中，我们先定义了一个&lt;code&gt;$(foo)&lt;/code&gt;变量，而第二行的意思是把&lt;code&gt;$(foo)&lt;/code&gt;中所有以&lt;code&gt;.o&lt;/code&gt;字串&lt;code&gt;结尾&lt;/code&gt;全部替换成&lt;code&gt;.c&lt;/code&gt;，所以我们的&lt;code&gt;$(bar)&lt;/code&gt;的值就是&lt;code&gt;a.c b.c c.c&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们可以使用&lt;code&gt;+=&lt;/code&gt;操作符给变量追加值，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;objects = main.o foo.o bar.o utils.o
objects += another.o
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们的&lt;code&gt;$(objects)&lt;/code&gt;值就变成：&lt;code&gt;main.o foo.o bar.o utils.o another.o&lt;/code&gt;（&lt;code&gt;another.o&lt;/code&gt;被追加进去了）&lt;/p&gt;
&lt;h3 id=&#34;局部变量&#34;&gt;局部变量&lt;/h3&gt;
&lt;p&gt;前面我们所讲的在&lt;code&gt;Makefile&lt;/code&gt;中定义的变量都是&lt;code&gt;全局变量&lt;/code&gt;，在整个文件，我们都可以访问这些变量。&lt;/p&gt;
&lt;p&gt;同样 我们也可以为某个目标设置&lt;code&gt;局部变量&lt;/code&gt;, 它可以和&lt;code&gt;全局变量&lt;/code&gt;同名, 它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;&amp;lt;target ...&amp;gt; : &amp;lt;variable-assignment&amp;gt;
&amp;lt;target ...&amp;gt; : overide &amp;lt;variable-assignment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果设置了这样一个局部变量，这个变量会作用到&lt;strong&gt;由这个目标所引发的所有的规则中去&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;prog : CFLAGS = -g
prog : prog.o foo.o bar.o
$(CC) $(CFLAGS) prog.o foo.o bar.o
prog.o : prog.c
$(CC) $(CFLAGS) prog.c
foo.o : foo.c
$(CC) $(CFLAGS) foo.c
bar.o : bar.c
$(CC) $(CFLAGS) bar.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个示例中，不管全局的&lt;code&gt;$(CFLAGS)&lt;/code&gt;的值是什么，在&lt;code&gt;prog&lt;/code&gt;目标，以及其所引发的所有规则中（&lt;code&gt;prog.o foo.o bar.o&lt;/code&gt;的规则），&lt;code&gt;$(CFLAGS)&lt;/code&gt;的值都是&lt;code&gt;-g&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;模式变量&#34;&gt;模式变量&lt;/h3&gt;
&lt;p&gt;局部变量可以定义在某个目标上，模式变量的好处就是，我们可以给定一种&lt;code&gt;模式&lt;/code&gt;，可以把变量定义在符合这种模式的所有目标上。&lt;/p&gt;
&lt;p&gt;可以以如下方式给所有以&lt;code&gt;.o&lt;/code&gt;结尾的目标定义目标变量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;%.o : CFLAGS = -O
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;条件判断&#34;&gt;条件判断&lt;/h3&gt;
&lt;p&gt;使用条件判断，可以让&lt;code&gt;make&lt;/code&gt;根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;ifeq ($(CC),gcc)
  libs=$(libs_for_gcc)
else
  libs=$(normal_libs)
endif
foo: $(objects)
  $(CC) -o foo $(objects) $(libs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ifneq ifeq&lt;/code&gt;  测试两个变量是否相等&lt;br&gt;
&lt;code&gt;ifdef ifndef&lt;/code&gt; 测试一个变量是否有值，其并不会把变量扩展到当前位置&lt;/p&gt;
&lt;h2 id=&#34;使用函数&#34;&gt;使用函数&lt;/h2&gt;
&lt;p&gt;函数调用，很像变量的使用，也是以&lt;code&gt;$&lt;/code&gt;来标识的，其语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;$(&amp;lt;function&amp;gt; &amp;lt;arguments&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;function&amp;gt;&lt;/code&gt;就是函数名，&lt;code&gt;make&lt;/code&gt;支持的函数不多。&lt;code&gt;&amp;lt;arguments&amp;gt;&lt;/code&gt;是函数的参数，参数间以逗号&lt;code&gt;,&lt;/code&gt;分隔，而函数名和参数之间以&lt;code&gt;空格&lt;/code&gt;分隔。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;comma:= ,
empty:=
space:= $(empty) $(empty)
foo:= a b c
bar:= $(subst $(space),$(comma),$(foo))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;$(comma)&lt;/code&gt;的值是一个逗号。&lt;br&gt;
&lt;code&gt;$(space)&lt;/code&gt;使用了&lt;code&gt;$(empty)&lt;/code&gt;定义了一个空格&lt;br&gt;
&lt;code&gt;$(foo)&lt;/code&gt;的值是&lt;code&gt;a b c&lt;/code&gt;&lt;br&gt;
&lt;code&gt;$(bar)&lt;/code&gt;的定义调用了函数&lt;code&gt;subst&lt;/code&gt;，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把&lt;code&gt;$(foo)&lt;/code&gt;中的所有&lt;code&gt;空格&lt;/code&gt;替换成&lt;code&gt;逗号&lt;/code&gt;，所以&lt;code&gt;$(bar)&lt;/code&gt;的值是&lt;code&gt;a,b,c&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;字符串函数&#34;&gt;字符串函数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;$(subst &amp;lt;from&amp;gt;,&amp;lt;to&amp;gt;,&amp;lt;text&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把字串&lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt;中的&lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt;字符串替换成&lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt;并返回被替换过后的字符串&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;$(patsubst &amp;lt;pattern&amp;gt;,&amp;lt;replacement&amp;gt;,&amp;lt;text&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查找&lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt;中的单词（单词以&lt;code&gt;空格&lt;/code&gt;、&lt;code&gt;Tab&lt;/code&gt;或&lt;code&gt;回车&lt;/code&gt; &lt;code&gt;换行&lt;/code&gt;分隔）是否符合模式&lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;，如果匹配的话，则以&lt;code&gt;&amp;lt;replacement&amp;gt;&lt;/code&gt;替换。返回被替换过后的字符串&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;$(strip &amp;lt;string&amp;gt;) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;去掉&lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;字串中开头和结尾的空字符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;$(findstring &amp;lt;find&amp;gt;,&amp;lt;in&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在字串&lt;code&gt;&amp;lt;in&amp;gt;&lt;/code&gt;中查找&lt;code&gt;&amp;lt;find&amp;gt;&lt;/code&gt;字串。如果找到，那么返回&lt;code&gt;&amp;lt;find&amp;gt;&lt;/code&gt;，否则返回空字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;$(word &amp;lt;n&amp;gt;,&amp;lt;text&amp;gt;) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取字符串&lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt;中第&lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt;个单词。（从一开始）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;$(sort &amp;lt;list&amp;gt;) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给字符串&lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;中的单词排序（升序）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;$(foreach &amp;lt;var&amp;gt;,&amp;lt;list&amp;gt;,&amp;lt;text&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把参数&lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;中的单词逐一取出放到参数&lt;code&gt;&amp;lt;var&amp;gt;&lt;/code&gt;所指定的变量中，然后再执行&lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt;所包含的表达式。&lt;br&gt;
每一次&lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt;会返回一个字符串，循环过程中，&lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt;的所返回的每个字符串会以空格分隔，最后当整个循环结束时，&lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是&lt;code&gt;foreach&lt;/code&gt;函数的返回值。所以，&lt;code&gt;&amp;lt;var&amp;gt;&lt;/code&gt;最好是一个变量名，&lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;可以是一个表达式，而&lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt;中一般会使用&lt;code&gt;&amp;lt;var&amp;gt;&lt;/code&gt;这个参数来依次枚举&lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;中的单词。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;names := a b c d
files := $(foreach n,$(names),$(n).o)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;$(name)&lt;/code&gt;中的单词会被挨个取出，并存到变量&lt;code&gt;n&lt;/code&gt;中，&lt;code&gt;$(n).o&lt;/code&gt;每次根据&lt;code&gt;$(n)&lt;/code&gt;计算出一个值，这些值以空格分隔，最后作为&lt;code&gt;foreach&lt;/code&gt;函数的返回，所以，$(files)的值是&lt;code&gt;a.o b.o c.o d.o&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;注意，&lt;code&gt;foreach&lt;/code&gt;中的&lt;code&gt;&amp;lt;var&amp;gt;&lt;/code&gt;参数是一个临时的局部变量，&lt;code&gt;foreach&lt;/code&gt;函数执行完后，参数&lt;code&gt;&amp;lt;var&amp;gt;&lt;/code&gt;的变量将不在作用，其作用域只在&lt;code&gt;foreach&lt;/code&gt;函数当中。&lt;/p&gt;
">[Linux] MakeFile</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/8u9sIpSyq/"" data-c="
          &lt;p&gt;&lt;code&gt;Git&lt;/code&gt;是一个&lt;strong&gt;开源的分布式版本控制系统&lt;/strong&gt;，可以有效、高速地处理从很小到非常大的项目版本管理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版本控制&lt;/strong&gt;最主要的功能就是&lt;strong&gt;追踪文件的变更&lt;/strong&gt;。&lt;br&gt;
它将什么时候、什么人更改了文件的什么内容等信息忠实地了记录下来。每一次文件的改变，文件的版本号都将增加。&lt;/p&gt;
&lt;p&gt;除了记录版本变更外，版本控制的另一个重要功能是并行开发。软件开发往往是多人协同作业，版本控制可以有效地解决版本的同步以及不同开发者之间的开发通信问题，提高协同开发的效率。&lt;/p&gt;
&lt;p&gt;主要功能:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;检入检出控制：&lt;strong&gt;同步控制的实质是版本的检入检出控制&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;检入&lt;/strong&gt;就是把软件配置项从用户的工作环境存入到软件配置库的过程，&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;检出&lt;/strong&gt;就是把软件配置项从软件配置库中取出的过程。&lt;/li&gt;
&lt;li&gt;检入是检出的逆过程。同步控制可用来确保由不同的人并发执行的修改不会产生混乱。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分支与合并&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;版本分支&lt;/strong&gt;（以一个已有分支的特定版本为起点，但是独立发展的版本序列）的人工方法就是从主版本——称为主干上拷贝一份，并做上标记。在实行了版本控制后，版本的分支也是一份拷贝，这时的拷贝过程和标记动作由版本控制系统完成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;版本合并&lt;/strong&gt;（来自不同分支的两个版本合并为其中一个分支的新版本）有两种途径，一是将版本A的内容附加到版本B中；另一种是合并版本A和版本B的内容，形成新的版本C。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;历史记录：版本的历史记录有助于对软件配置项进行审核，有助于追踪问题的来源。历史记录包括版本号、版本修改时间、版本修改者、版本修改描述等最基本的内容，还可以有其他一些辅助性内容，比如版本的文件大小和读写属性。 如果我们开发中的新版本发现不适合用户的体验，这时候就可以找到历史记录的响应版本号，回退到历史记录版本！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置git&#34;&gt;配置GIT&lt;/h2&gt;
&lt;p&gt;首先需要确定版本控制人信息 以追踪变更者&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提交信息版本操作者信息：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config --global user.name &amp;quot;Ziph&amp;quot; #【用户名】
git config --global user.email &amp;quot;mylifes1110@163.com&amp;quot; #【邮箱】
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看信息：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config -l
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;仓库&#34;&gt;仓库&lt;/h2&gt;
&lt;p&gt;版本库又名仓库，英文名repository，可以简单理解成一个目录，这个目录里面的所有文件都可以被&lt;code&gt;Git&lt;/code&gt;管理起来，每个文件的修改、删除，&lt;code&gt;Git&lt;/code&gt;都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;工作区&lt;/strong&gt;：由我们使用命令&lt;code&gt;git init&lt;/code&gt;初始化的一个本地文件夹，而初始化后的这个文件夹就被称为工作区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;暂存区&lt;/strong&gt;：由我们使用命令&lt;code&gt;git add .&lt;/code&gt;把文件添加到暂存区，而被添加的位置则是工作区中 &lt;code&gt;.git&lt;/code&gt;目录中的&lt;code&gt;index&lt;/code&gt;文件，所以这也叫做&lt;strong&gt;索引&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;版本库&lt;/strong&gt;：工作区中会有一个隐藏的&lt;code&gt;.git&lt;/code&gt;文件夹，这个不算是工作区，而&lt;strong&gt;是Git的版本库&lt;/strong&gt;，版本库中记录了我们提交过的所有版本，也就是说版本库管理着我们的所有内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分支&lt;/strong&gt;： 版本库中包含若干分支，提交后的文件就会存储在分支中，而开始的时候版本库中只会有一个主分支&lt;code&gt;master&lt;/code&gt;/&lt;code&gt;main&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在使用git来管理本地仓库时，每次对工作区中的内容做的任何变化都需要&lt;code&gt;add&lt;/code&gt;（添加）和&lt;code&gt;commit&lt;/code&gt;（提交）操作来同步&lt;code&gt;git&lt;/code&gt;版本库，只有做了添加和提交操作, &lt;code&gt;git&lt;/code&gt;才能管理我们的工作区。&lt;/p&gt;
&lt;h3 id=&#34;创建版本库&#34;&gt;创建版本库&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先创建或找到一个文件夹，打开命令窗口切换到该路径下，输入&lt;code&gt;git init&lt;/code&gt;执行初始化本地工作区，在该工作区内会初始化生成一个&lt;code&gt;.git&lt;/code&gt;目录，而该目录就是版本库，它保存着仓库的所有信息。&lt;/p&gt;
&lt;p&gt;所有有关仓库的指令，如关联远程仓库，克隆等，都必须在已经被&lt;code&gt;git init&lt;/code&gt;的文件夹下进行。&lt;/p&gt;
&lt;h3 id=&#34;添加文件&#34;&gt;添加文件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add 文件列表
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先在工作区中放入一个文件，然后在命令行窗口中执行&lt;code&gt;git add 文件名&lt;/code&gt;即可向暂存区中添加一个文件。类似的，&lt;code&gt;git add 文件名1 文件名2 …&lt;/code&gt; 即可向暂存区中添加多个文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git add 文件夹名&lt;/code&gt; 即可向暂存区中添加该文件夹以及文件夹内的所有内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git add .&lt;/code&gt;命令添加工作区中的所有内容到暂存区。&lt;/p&gt;
&lt;h3 id=&#34;提交文件&#34;&gt;提交文件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git commit 文件列表 -m message
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;git commit 文件名1 文件名2 -m &amp;quot;本次提交的描述信息&amp;quot;&lt;/code&gt;来提交文件。&lt;br&gt;
注意提交的描述信息是为了记录本次提交而方便查找，所以尽量能明确反映本次提交。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git commit . -m &amp;quot;本次提交的描述信息&amp;quot;&lt;/code&gt; 命令来提交所有工作区的文件文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;使用git commit -a -m &amp;quot;本次添加并提交的描述信息&amp;quot;&lt;/code&gt;命令来自动添加和提交所有文件。&lt;/p&gt;
&lt;h4 id=&#34;修补提交&#34;&gt;修补提交&lt;/h4&gt;
&lt;p&gt;提交后发现有问题，比如注释忘记修改，⽐如提交描述不够详细等等。可以执行&lt;code&gt;git commit -- amend -m&amp;quot;描述信息&amp;quot;&lt;/code&gt;来再次提交替换上次提交选项&lt;br&gt;
&lt;code&gt;-m &lt;/code&gt;让 &lt;code&gt;git&lt;/code&gt; 将 本次提交的描述信息 记录到项目的历史记录中。&lt;/p&gt;
&lt;p&gt;对于向&lt;code&gt;git&lt;/code&gt;提交后的文件，删除和修改我们只需要重新提交即可。也就是说，我们挪动或删除了工作区中的文件或更改了工作区中的目录结构，都需要重新向&lt;code&gt;git&lt;/code&gt;添加和提交你所变动的文件。&lt;/p&gt;
&lt;h3 id=&#34;文件状态&#34;&gt;文件状态&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;git status&lt;/code&gt; 命令查看文件的状态 是否已提交 是否添加追踪等等&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688040644847.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;在Git中，分支是项目的版本。上图为&lt;code&gt;git status&lt;/code&gt; 命令返回的状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一行表示位于分支master上。&lt;/li&gt;
&lt;li&gt;第二行Git指出了项目中未被跟踪的文件，这里还没有添加需要跟踪的文件。&lt;/li&gt;
&lt;li&gt;第三行被告知没有将任何东西添加到当前提交中，但我们可能需要将未跟踪的文件加入到仓库中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;细节&lt;/strong&gt;： 可以使用 &lt;code&gt;git diff&lt;/code&gt; 命令来比对工作区内文件的变动状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比对&lt;/strong&gt;： 使用 &lt;code&gt;git diff 文件名&lt;/code&gt; 命令来比对工作区和暂存区（若暂存区没有则比对分支）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比对工作区与分支的最新结果： 使用 &lt;code&gt;git diff HEAD -- 文件名&lt;/code&gt; 命令来比对工作区和分支的最新结果&lt;/li&gt;
&lt;li&gt;比对暂存区与分支的最新结果： 使用 &lt;code&gt;git diff --staged 文件名&lt;/code&gt; 命令来比对暂存区与分支的最新结果&lt;/li&gt;
&lt;li&gt;注意： &lt;code&gt;git diff HEAD -- 文件名&lt;/code&gt;命令中&lt;code&gt;--&lt;/code&gt;与&lt;code&gt;文件名&lt;/code&gt;之间必须要有一个空格，不要写错！&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;日志操作&#34;&gt;日志操作&lt;/h3&gt;
&lt;p&gt;每次提交，&lt;code&gt;git&lt;/code&gt;都会随着提交的变动来记录版本变化，所以在工作区中的所有操作都会留下日志。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;查看所有提交日志&lt;/strong&gt;： 使用 &lt;code&gt;git log &lt;/code&gt;命令来显示从最早的提交点到当前提交点的所有日志&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查看执行条数的提交日志&lt;/strong&gt;： 使用 &lt;code&gt;git log -数量&lt;/code&gt; 命令来显示最近指定数量条的提交日志&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简洁日志显示&lt;/strong&gt;： 使用 &lt;code&gt;git log --oneline&lt;/code&gt; 命令来显示比较简洁的提交日志&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图形化显示分支走向&lt;/strong&gt;： 使用 &lt;code&gt;git log --oneline --graph&lt;/code&gt; 命令来图形化显示分支走向&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git log&lt;/code&gt; 命令显示的&lt;code&gt;提交ID&lt;/code&gt;是很长的字符串，而使用&lt;code&gt;git log --onelin&lt;/code&gt;e命令来简洁显示的提交ID是一个7位的字符串&lt;br&gt;
我们使用ID的时候并不需要使用很长的ID来操作，而&lt;strong&gt;一般使用前7位&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;版本回退&#34;&gt;版本回退&lt;/h3&gt;
&lt;p&gt;每次修改文件并添加和提交。&lt;code&gt;git&lt;/code&gt;都会记录一个版本，如果有需要可以回退到之前的数据版本状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;回退上一个版本&lt;/strong&gt;： 使用 &lt;code&gt;git reset --hard HEAD~&lt;/code&gt; 命令来回退到上一个版本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回退上上个版本&lt;/strong&gt;： 使用 &lt;code&gt;git reset --hard HEAD~~&lt;/code&gt; 命令来回退到上上个版本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回退到上某数量个版本&lt;/strong&gt;： 使用 &lt;code&gt;git reset --hard HEAD~数量&lt;/code&gt; 命令来回退到上某数量个版本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回退到某次提交时的版本&lt;/strong&gt;： 使用 &lt;code&gt;git reset --hard commitID&lt;/code&gt; 命令来回退到某次提交时的版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回退版本并不会删除任何版本，所以版本之间可以来回切换&lt;/p&gt;
&lt;h3 id=&#34;撤销修改&#34;&gt;撤销修改&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;工作区撤销&lt;/strong&gt;： 执行 &lt;code&gt;git checkout -- 文件名&lt;/code&gt; 命令可以撤销到最近一次 &lt;code&gt;git add&lt;/code&gt; 或 &lt;code&gt;git commit&lt;/code&gt; 的状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作区撤销内部流程&lt;/strong&gt;： 你执行了工作区撤销命令，如果暂存区有此文件，则将暂存区中的文件恢复到工作区中；如果暂存区没有此文件，则将分支中的文件恢复到工作区中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;暂存区撤销&lt;/strong&gt;：&lt;br&gt;
先执行 &lt;code&gt;git reset HEAD 文件名&lt;/code&gt; 命令将该文件移除暂存区，后执行&lt;code&gt; git checkout -- 文件名&lt;/code&gt; 命令回退到上一个版本&lt;br&gt;
&lt;strong&gt;暂存区撤销场景&lt;/strong&gt;： 如果在工作区中修改了文件并发送到了暂存区中，但文件中有需要撤销的内容&lt;/p&gt;
&lt;h2 id=&#34;分支&#34;&gt;分支&lt;/h2&gt;
&lt;p&gt;每一个被&lt;code&gt;git&lt;/code&gt;管理的仓库都会有一个默认的主分支（&lt;code&gt;master&lt;/code&gt;分支）。&lt;/p&gt;
&lt;p&gt;分⽀中接收&lt;code&gt;git commit&lt;/code&gt;提交的内容，为㇐个㇐个不断向前发展的提交点。每个提交点都保存了㇐个版本。每个分⽀，都有㇐个指针，指针默认指向最近㇐次提交的版本。⼯作区中的内容，初始状态，就是指针所指向的版本状态。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git&lt;/code&gt;在保存每个版本时( 对应提交点 )，并不是复制所有⽂件，没有改动的⽂件的话只是记录㇐个链接。&lt;/p&gt;
&lt;p&gt;实际开发中&lt;code&gt;master&lt;/code&gt;分⽀尽量只存放稳定的代码提交，保证&lt;code&gt;master&lt;/code&gt;分⽀稳定，有效。因为这样保证了我们的开发进度不会受到影响。在需要编写新功能时，新建㇐个开发⽤的分⽀，所有改动都在该分⽀上提交，在功能完整实现后，将该分⽀的最终内容合并到master分⽀。这样，既保证开发中有多个版本可以控制，⼜保证master分⽀是稳定，有效的。&lt;/p&gt;
&lt;h3 id=&#34;创建分支&#34;&gt;创建分支&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;git branch 分支名&lt;/code&gt; 命令创建分支，会与当前分支保持同样的数据状态，即新分支和当前分支指向同一个提交点&lt;/p&gt;
&lt;h3 id=&#34;切换分支&#34;&gt;切换分支&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;git checkout 分支名&lt;/code&gt;命令切换分支，切换分支后工作区中显示当前分支内容（切换分支实际上是切换了分支的指针，让指针指向了所要切换到分支）&lt;/p&gt;
&lt;h3 id=&#34;查看当前分支&#34;&gt;查看当前分支&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;git branch&lt;/code&gt; 命令来查看当前分支&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看当前分支详细信息&lt;/strong&gt;： 使用 &lt;code&gt;git branch -vv&lt;/code&gt; 命令查看分支详细信息，分支信息则是所跟踪的远程分支信息以及是否领先远程分支等等&lt;/p&gt;
&lt;h3 id=&#34;合并分支&#34;&gt;合并分支&lt;/h3&gt;
&lt;p&gt;新分支编写完成后，先使用 &lt;code&gt;git branch master&lt;/code&gt; 命令切换到&lt;code&gt;master&lt;/code&gt;分支&lt;br&gt;
再使用 &lt;code&gt;git merge 新分支名&lt;/code&gt; 命令将新分支合并到&lt;code&gt;master&lt;/code&gt;分支。&lt;br&gt;
此次合并就是将&lt;code&gt;master&lt;/code&gt;的指针移到了新分支的位置，等价于快速合并&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看当前合并分支&lt;/strong&gt;： 分支合并后可以使用 &lt;code&gt;git branch --merged&lt;/code&gt; 命令查看被当前分⽀合并了的分⽀&lt;/p&gt;
&lt;h3 id=&#34;删除分支&#34;&gt;删除分支&lt;/h3&gt;
&lt;p&gt;将分支合并后，如果新分支不再继续使用，可以先使用&lt;code&gt;git branch --merged&lt;/code&gt;命令查看合并分支以确认我们即将删除的分支的确是无用分支后&lt;br&gt;
再使用 &lt;code&gt;git branch -d 分支名 &lt;/code&gt;命令删除需要删除的无用分支。&lt;/p&gt;
&lt;h3 id=&#34;解决分支冲突&#34;&gt;解决分支冲突&lt;/h3&gt;
&lt;p&gt;两个分支对同一个文件做了改动，所以在合并时&lt;code&gt;git&lt;/code&gt;会无法确定保留哪个分支上的数据就会产生冲突&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;终止合并分支&lt;/strong&gt;： 当出现分支冲突时可以使用&lt;code&gt;git merge --abort&lt;/code&gt;命令来终止合并分支&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;避免因为空⽩导致冲突&lt;/strong&gt;： 在合并分支时，如果有空白内容有可能会出现分支冲突现象，所以此时可以使用&lt;code&gt;git merge 分支名 -Xignore-all-space &lt;/code&gt;命令来避免因为空白而导致的分支冲突&lt;/p&gt;
&lt;h2 id=&#34;远程仓库github&#34;&gt;远程仓库（Github）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git&lt;/code&gt;本地仓库和GitHub或码云之间传输，建议设置&lt;code&gt;SSH key&lt;/code&gt;，避免在传输中反复输入密码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置SSH key&lt;/strong&gt;： 执行 &lt;code&gt;ssh-keygen -t rsa -C 邮箱 &lt;/code&gt;命令后的每一步都按&lt;code&gt;Enter&lt;/code&gt;键确定就好，知道命令执行结束（&lt;code&gt;-C&lt;/code&gt; 后面的内容随意写就行，这只是作为title而已）&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;key&lt;/code&gt;创建在&lt;code&gt;root&lt;/code&gt;下就必须以&lt;code&gt;root&lt;/code&gt;用户才能传输 创建在哪个用户文件夹底下就哪个用户能传&lt;/p&gt;
&lt;p&gt;命令执行完毕后，会在你电脑的&lt;code&gt;C:\Users\主机名\.ssh&lt;/code&gt;目录下生成密钥文件。&lt;br&gt;
&lt;code&gt;id_rsa&lt;/code&gt;是私钥，不能泄露出去。&lt;code&gt;id_rsa.pub&lt;/code&gt;是公钥，可以放⼼地告诉任何⼈。&lt;/p&gt;
&lt;p&gt;随后注册登录GitHub，在账户设置中选择&lt;code&gt;SSH Keys&lt;/code&gt;，在Title中随意填写内容，在Key中填写&lt;code&gt;id_rsa.pub&lt;/code&gt;文件中的所有内容&lt;/p&gt;
&lt;p&gt;这样就可以在GitHub中添加好自己的公钥，和Git服务器通信时（clone，push，pull）git服务器就可以识别出你的身份了！&lt;/p&gt;
&lt;h3 id=&#34;关联远程仓库&#34;&gt;关联远程仓库&lt;/h3&gt;
&lt;p&gt;关联远程仓库只需要执行 &lt;code&gt;git remote add 关联别名 仓库地址&lt;/code&gt; 命令即可&lt;br&gt;
注意：别名是可以自己取名设置的，但是不要忘记就好，因为后续push的时候会用到&lt;br&gt;
仓库地址在code下ssh里 形如git@github.com:wjcsw/test.git&lt;/p&gt;
&lt;h3 id=&#34;上传到github远程仓库&#34;&gt;上传到GitHub远程仓库&lt;/h3&gt;
&lt;p&gt;执行 &lt;code&gt;git push 关联别名 master&lt;/code&gt; 命令将文件上传到&lt;code&gt;GitHub&lt;/code&gt;服务器的&lt;code&gt;master&lt;/code&gt;分支&lt;/p&gt;
&lt;p&gt;上传到GitHub远程仓库后，我们就可以正常的在GitHub查看所上传的文件。设置一次关联后，我们在本地仓库上传到GitHub远程仓库都需要经过 &lt;code&gt;add&lt;/code&gt; -&amp;gt; &lt;code&gt;commit&lt;/code&gt; -&amp;gt; &lt;code&gt;push&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;查看关联的所有远程仓库&lt;/strong&gt;： 执行&lt;code&gt;git remote -v&lt;/code&gt;命令查看关联的所有远程仓库&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查看关联后远程仓库分支和本地仓库分支的对应关系&lt;/strong&gt;： 执行&lt;code&gt;git remote show 关联别名&lt;/code&gt;命令查看&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;删除关联&lt;/strong&gt;： 执行 &lt;code&gt;git remote remove 关联别名&lt;/code&gt; 命令删除关联&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重命名关联别名&lt;/strong&gt;： 执行&lt;code&gt;git remote rename 原关联别名 新关联别名&lt;/code&gt;命令重命名关联别名&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;上传到GitHub远程仓库&lt;/strong&gt;： 执行&lt;code&gt;git push 关联别名 master&lt;/code&gt;命令来将本地仓库的文件上传到GitHub远程仓库的&lt;code&gt;master&lt;/code&gt;分支显示（注意：我们是可以指定上传的分支的！）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;本地存在分支上传github分支&#34;&gt;本地存在分支上传GitHub分支&lt;/h3&gt;
&lt;p&gt;执行&lt;code&gt;git push 关联别名 本地仓库分支:GitHub仓库分支&lt;/code&gt;命令会将本地仓库存在分支上传到GitHub分支&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拉取远程仓库分支： 执行&lt;code&gt;git fetch 关联别名 master&lt;/code&gt;命令来拉取&lt;code&gt;master&lt;/code&gt;分支下的内容&lt;/li&gt;
&lt;li&gt;手动合并本地库分支： 执行&lt;code&gt;git merge 关联别名/master&lt;/code&gt;命令来手动合并本地库分支下的内容&lt;/li&gt;
&lt;li&gt;比较拉取内容中的分支和本地分支中的不同： 首先执行&lt;code&gt;git checkout&lt;/code&gt; 分支命令来切换到想要比较并拉取的分支，再执行&lt;code&gt;git diff关联别名/分支&lt;/code&gt;命令来比较拉取的内容中的分支和本地分支的不同&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;下载远程仓库内容&#34;&gt;下载远程仓库内容&lt;/h3&gt;
&lt;p&gt;下载操作等价于拉取远程的新内容，并合并到当前分支的操作&lt;/p&gt;
&lt;h4 id=&#34;下载远程内容&#34;&gt;下载远程内容&lt;/h4&gt;
&lt;p&gt;执行&lt;code&gt;git pull 关联别名 master&lt;/code&gt;命令来完成对远程仓库主分支内容的下载操作，该操作省略了本地仓库分支（当前分支），默认的将远程仓库&lt;code&gt;master&lt;/code&gt;主分支上的内容下载到了本地仓库的&lt;code&gt;master&lt;/code&gt;主分支&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下载远程内容的完整写法&lt;/strong&gt;：&lt;code&gt; git pull 关联别名 远程仓库分支:本地仓库分支（当前分支）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;克隆操作将GitHub远程仓库的所有内容下载到本地，该方式&lt;strong&gt;自动搭建了本地与GitHub远程仓库的关联&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clone操作1： 执行命令&lt;code&gt;git clone SSH地址&lt;/code&gt;将远程仓库&lt;code&gt;clone&lt;/code&gt;到本地，已设置&lt;code&gt;key&lt;/code&gt;，不用命令&lt;/li&gt;
&lt;li&gt;clone操作2： 执行命令&lt;code&gt;git clone HTTPS地址&lt;/code&gt;将远程仓库&lt;code&gt;clone&lt;/code&gt;到本地，该方式需要输入GitHub口令&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;标签常用命令&#34;&gt;标签常用命令&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1688040630728.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">[Linux] GIT</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/7u3kRJZR_/"" data-c="
          &lt;p&gt;&lt;strong&gt;GDB&lt;/strong&gt;（GNU Debugger）是UNIX及UNIX-like下的强大调试工具，可以调试&lt;code&gt;ada&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;,&lt;code&gt; c++&lt;/code&gt;, &lt;code&gt;asm&lt;/code&gt;, &lt;code&gt;minimal&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;fortran&lt;/code&gt;, &lt;code&gt;objective-c&lt;/code&gt;, &lt;code&gt;go&lt;/code&gt;, &lt;code&gt;java&lt;/code&gt;, &lt;code&gt;pascal&lt;/code&gt;等语言。&lt;/p&gt;
&lt;p&gt;对于C程序来说，&lt;strong&gt;需要在编译时加上&lt;code&gt;-g&lt;/code&gt;参数&lt;/strong&gt;，保留调试信息，否则不能使用GDB进行调试。&lt;/p&gt;
&lt;h2 id=&#34;直接使用-gdb-文件名&#34;&gt;直接使用 gdb + 文件名&lt;/h2&gt;
&lt;p&gt;如果没有调试信息，会提示&lt;code&gt;no debugging symbols found&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果是下面的提示：&lt;code&gt;Reading symbols from helloWorld...done.&lt;/code&gt; 则可以进行调试。&lt;/p&gt;
&lt;p&gt;接着进入交互界面 输入命令进行调试&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;run [参数]&lt;/code&gt;, 如果运行的程序需要参数 则在run后面直接跟参数即可&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start &lt;/code&gt;默认在最开始有个临时断点&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688032198307.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688032202961.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;或者使用&lt;code&gt;set args&lt;/code&gt;，然后再用&lt;code&gt;run&lt;/code&gt;启动&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;set args&lt;/code&gt; 用于传递&lt;code&gt;main&lt;/code&gt;函数参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;show args&lt;/code&gt; 可以查看参数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调试core文件&#34;&gt;调试core文件&lt;/h2&gt;
&lt;p&gt;当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存状态记录下来，保存在一个&lt;code&gt;core&lt;/code&gt;文件中，这种行为就叫做&lt;code&gt;Core Dump&lt;/code&gt;（中文有的翻译成“核心转储”）。我们可以认为 &lt;code&gt;core dump&lt;/code&gt; 是“&lt;strong&gt;内存快照&lt;/strong&gt;”，但实际上，除了内存信息之外，还有些关键的程序运行状态也会同时 &lt;code&gt;dump&lt;/code&gt; 下来，例如&lt;strong&gt;寄存器信息&lt;/strong&gt;（包括&lt;strong&gt;程序指针&lt;/strong&gt;、&lt;strong&gt;栈指针&lt;/strong&gt;等）、&lt;strong&gt;内存管理信息&lt;/strong&gt;、其他处理器和操作系统状态和信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;core dump&lt;/code&gt; 对于编程人员诊断和调试程序是非常有帮助的，因为对于有些程序错误是很难重现的，例如指针异常，而 &lt;code&gt;core dump&lt;/code&gt; 文件可以再现程序出错时的情景。&lt;/p&gt;
&lt;p&gt;当程序&lt;code&gt;core dump&lt;/code&gt;时，可能会产生&lt;code&gt;core&lt;/code&gt;文件，它能够很大程序帮助我们定位问题。但前提是系统没有限制core文件的产生。&lt;/p&gt;
&lt;p&gt;可以使用命令&lt;code&gt;ulimit -c&lt;/code&gt;查看是否允许生成&lt;code&gt;core&lt;/code&gt;文件&lt;br&gt;
若结果为&lt;code&gt;0&lt;/code&gt; 则代表不能生成&lt;code&gt;core&lt;/code&gt;文件&lt;br&gt;
可以通过以下命令解除限制 两种方式可选其一。第一种无限制，第二种指定最大产生文件的大小。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ulimit -c unlimied #表示不限制core文件大小
ulimit -c 10 #设置最大大小，单位为块，一块默认为512字节
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用core文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(gdb) core-file core # 查看生成的core文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;调试已运行程序&#34;&gt;调试已运行程序&lt;/h2&gt;
&lt;p&gt;首先使用 &lt;code&gt;ps&lt;/code&gt; 命令找到进程&lt;code&gt;id&lt;/code&gt;&lt;br&gt;
接着用 &lt;code&gt;attach + id&lt;/code&gt; 启动调试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ps -ef|grep 进程名
$ gdb
(gdb) attach 20829
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;断点设置&#34;&gt;断点设置&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Gdb&lt;/code&gt;模式下可以使用&lt;code&gt;info break&lt;/code&gt;查看已设置断点 或者简写为 &lt;code&gt;i b&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;根据行号设置断点&#34;&gt;根据行号设置断点:&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;b/break 9 # break 可简写为b
b test.c: 9 # 程序运行到第9行的时候会断住
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;根据函数名设置断点&#34;&gt;根据函数名设置断点:&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;b printNum # printNum 为函数名 程序在调用到printNum函数的时候会断住
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;根据条件设置断点&#34;&gt;根据条件设置断点:&lt;/h3&gt;
&lt;p&gt;假设程序某处发生崩溃，而崩溃的原因怀疑是某个地方出现了非期望的值，那么你就可以在这里断点观察，当出现该非法值时，程序断住。这个时候我们可以借助gdb来设置条件断点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;break test.c:23 if b==0 # 当在b等于0时，程序将会在第23行断住。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;code&gt;condition&lt;/code&gt;有着类似的作用，假设上面的断点号为&lt;code&gt;1&lt;/code&gt;，那么：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;condition 1 b==0 # 会使得b等于0时，产生断点1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;根据规则设置断点-rbreak&#34;&gt;根据规则设置断点 &lt;code&gt;rbreak&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;对所有以&lt;code&gt;printNum&lt;/code&gt;开头的函数都设置断点，可以使用下面的方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rbreak printNum* # 所有以printNum开头的函数都设置了断点
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;设置临时断点-tbreak&#34;&gt;设置临时断点 &lt;code&gt;tbreak&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tbreak test.c: 10 #在第10行设置临时断点
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;跳过多次设置断点-ignore&#34;&gt;跳过多次设置断点 &lt;code&gt;ignore&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;假如有某个地方，我们知道可能出错，但是前面30次都没有问题，虽然在该处设置了断点，但是想跳过前面30次：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ignore 1 30 # 1为断点号 30是跳过次数
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;根据表达式值变化产生断点-watch&#34;&gt;根据表达式值变化产生断点 &lt;code&gt;watch&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;watch a # 当变量a的值变化时 中断并打印a的值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rwatch&lt;/code&gt; 和 &lt;code&gt;awatch&lt;/code&gt; 同样可以设置观察点&lt;br&gt;
前者是&lt;strong&gt;当变量值被读时断住&lt;/strong&gt;，后者是&lt;strong&gt;被读或者被改写时断住&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;禁用或启动断点&#34;&gt;禁用或启动断点&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;disable # 禁用所有断点
disable bnum # 禁用标号为bnum的断点
enable # 启用所有断点
enable bnum # 启用标号为bnum的断点
enable delete bnum # 启动标号为bnum的断点，并且在此之后删除该断点
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;断点清除&#34;&gt;断点清除&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;clear # 删除当前行所有breakpoints
clear function # 删除函数名为function处的断点
clear filename: function # 删除文件filename中函数function处的断点
clear lineNum # 删除行号为lineNum处的断点
clear filename：lineNum # 删除文件filename中行号为lineNum处的断点
delete # 删除所有breakpoints,watchpoints和catchpoints
delete bnum # 删除断点号为bnum的断点
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;变量查看&#34;&gt;变量查看&lt;/h2&gt;
&lt;h3 id=&#34;普通变量查看&#34;&gt;普通变量查看&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;print&lt;/code&gt;（可简写为&lt;code&gt;p&lt;/code&gt;）打印变量内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;p a # 打印变量a的内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有时候，多个函数或者多个文件会有同一个变量名，这个时候可以在前面加上函数名或者文件名来区分&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;p &#39;main&#39;::b
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;打印指针指向内容&#34;&gt;打印指针指向内容&lt;/h3&gt;
&lt;p&gt;使用解引用方式打印&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;p *d # 通过解引用符*来打印指针指向的内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但直接使用*仅仅只能打印第一个值&lt;br&gt;
如果要打印多个值(如数组)，后面跟上&lt;code&gt;@&lt;/code&gt;并加上要打印的长度。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;p *d@10 # 通过指针打印一个长为10的数组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;$&lt;/code&gt; 可表示上一个变量&lt;br&gt;
假设此时有一个链表&lt;code&gt;linkNode&lt;/code&gt;，它有&lt;code&gt;next&lt;/code&gt;成员代表下一个节点，则可使用下面方式不断打印链表内容：&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688032179267.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;set&lt;/code&gt; 可以定义一个变量&lt;br&gt;
如果想要查看前面数组的内容，可以定义下标变量后, 将下标一个一个累加&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688032173492.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;按照特定格式打印变量&#34;&gt;按照特定格式打印变量&lt;/h3&gt;
&lt;p&gt;对于简单的数据，&lt;code&gt;print&lt;/code&gt;默认的打印方式已经足够了，它会根据变量类型的格式打印出来，但是有时候这还不够，我们需要更多的格式控制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/x&lt;/code&gt; 按十六进制格式显示变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/d&lt;/code&gt; 按十进制格式显示变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/u&lt;/code&gt; 按十六进制格式显示无符号整型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/o&lt;/code&gt; 按八进制格式显示变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/t&lt;/code&gt; 按二进制格式显示变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/a&lt;/code&gt; 按十六进制格式显示变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/c&lt;/code&gt; 按字符格式显示变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/f&lt;/code&gt; 按浮点数格式显示变量。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688032167243.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是这种方式仍然无法查看浮点数的二进制格式，因为直接打印它首先会被转换成整型&lt;/p&gt;
&lt;h3 id=&#34;查看内存内容&#34;&gt;查看内存内容&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;examine&lt;/code&gt;(简写为&lt;code&gt;x&lt;/code&gt;) 可以用来查看内存地址中的值。语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;x/[n][f][u] addr
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; 表示要显示的内存单元数，默认值为1.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; 表示要打印的格式，前面已经提到了格式控制字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt; 表示要打印的单元长度 单元长度常见有如下：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; 字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h&lt;/code&gt; 半字，即双字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt; 字，即四字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt; 八字节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addr&lt;/code&gt; 内存地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1688032154519.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
此处 &lt;code&gt;n=4, f = t , u = b&lt;/code&gt;&lt;br&gt;
代表以二进制形式打印四个字节大小的e变量所处地址的内存单元中的内容&lt;/p&gt;
&lt;p&gt;查看寄存器内容 &lt;code&gt;info registers&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;自动显示变量内容&#34;&gt;自动显示变量内容&lt;/h3&gt;
&lt;p&gt;假设我们希望程序断住时，就显示某个变量的值，可以使用&lt;code&gt;display&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;display e # 每次程序断住时，就会打印e的值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要查看哪些变量被设置了&lt;code&gt;display&lt;/code&gt;，可以使用：&lt;code&gt;info display&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果想要清除打印变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;delete display [num] # num为前面变量前的编号,不带num时清除所有。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;单步调试&#34;&gt;单步调试&lt;/h2&gt;
&lt;h3 id=&#34;单步执行&#34;&gt;单步执行&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;next&lt;/code&gt;命令（可简写为&lt;code&gt;n&lt;/code&gt;）用于在程序断住后，继续执行下一条语句。&lt;/p&gt;
&lt;p&gt;假设已经启动调试，并在第12行停住，如果要继续执行，则使用&lt;code&gt;n&lt;/code&gt;执行下一条语句。&lt;br&gt;
如果后面跟上数字&lt;code&gt;num&lt;/code&gt;，则表示执行该命令&lt;code&gt;num&lt;/code&gt;次，就达到继续执行&lt;code&gt;n&lt;/code&gt;行的效果了&lt;/p&gt;
&lt;h3 id=&#34;单步进入&#34;&gt;单步进入&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;step&lt;/code&gt;命令（可简写为&lt;code&gt;s&lt;/code&gt;），它可以单步跟踪到函数内部，但&lt;strong&gt;前提是该函数有调试信息并且有源码信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果没有函数调用，&lt;code&gt;s&lt;/code&gt;的作用与&lt;code&gt;n&lt;/code&gt;的作用并无差别，仅仅是继续执行下一行。它后面也可以跟数字，表明要执行的次数。&lt;/p&gt;
&lt;h3 id=&#34;继续执行到下一个断点&#34;&gt;继续执行到下一个断点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;continue&lt;/code&gt;命令（可简写为&lt;code&gt;c&lt;/code&gt;）或者&lt;code&gt;fg&lt;/code&gt;，它会继续执行程序，直到再次遇到断点处&lt;/p&gt;
&lt;h3 id=&#34;继续运行到指定位置&#34;&gt;继续运行到指定位置&lt;/h3&gt;
&lt;p&gt;假如我们在25行停住了，现在想要运行到29行停住&lt;br&gt;
可以使用&lt;code&gt;until&lt;/code&gt;命令（可简写为&lt;code&gt;u&lt;/code&gt;）它利用的是&lt;strong&gt;临时断点&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;跳过执行&#34;&gt;跳过执行&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;skip&lt;/code&gt;可以在&lt;code&gt;step&lt;/code&gt;时跳过一些不想关注的函数或者某个文件的代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;skip function add # step时跳过add函数
info skip # 查看step情况
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;skip&lt;/code&gt;也后面也可以跟文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;skip file gdbStep.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样&lt;code&gt;gdbStep.c&lt;/code&gt;中的函数都不会进入。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;skip delete [num]&lt;/code&gt; 删除skip条目，nun表示跳过条目的编号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;skip enable [num]&lt;/code&gt; 启用skip条目，nun表示跳过条目的编号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;skip disable [num]&lt;/code&gt; 禁止skip条目，nun表示跳过条目的编号&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;查看源码或对源码进行编辑&#34;&gt;查看源码或对源码进行编辑&lt;/h2&gt;
&lt;h3 id=&#34;查看源码内容&#34;&gt;查看源码内容&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt;（可简写为&lt;code&gt;l&lt;/code&gt;），它可以将源码列出来&lt;/p&gt;
&lt;p&gt;直接输入 &lt;code&gt;l&lt;/code&gt; 可从第一行开始显示源码，未显示全继续输入 &lt;code&gt;l&lt;/code&gt; ，可列出后面的源码。&lt;br&gt;
后面也可以跟上 &lt;code&gt;+&lt;/code&gt; 或者 &lt;code&gt;-&lt;/code&gt; ，分别表示要列出上一次列出源码的后面部分或者前面部分。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;l - 
l +
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;l&lt;/code&gt; 后面可以跟行号，表明要列出某行附近的源码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;l 9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;列出指定函数附近的源码: l后面跟函数名即可&lt;/p&gt;
&lt;h3 id=&#34;设置源码一次列出行数&#34;&gt;设置源码一次列出行数&lt;/h3&gt;
&lt;p&gt;默认是10行 可以通过&lt;code&gt;set listsize&lt;/code&gt;属性来设置&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688032134515.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;若设置为&lt;code&gt;0&lt;/code&gt;或者&lt;code&gt;unlimited&lt;/code&gt;，列出就没有限制了，但源码如果较长，查看将会不便。&lt;/p&gt;
&lt;h3 id=&#34;列出指定行之间的源码&#34;&gt;列出指定行之间的源码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;list first,last
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启始行和结束行号之间用逗号隔开。两者之一也可以省略，例如：&lt;code&gt;list 3,&lt;/code&gt;&lt;br&gt;
省略结束行的时候，它列出从开始行开始，到指定大小行结束，而省略开始行的时候，到结束行结束，列出设置的大小行，例如默认设置为10行，则到结束行为止，总共列出10行。&lt;/p&gt;
&lt;h3 id=&#34;列出指定文件的源码&#34;&gt;列出指定文件的源码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;l location 其中location可以是 文件名加行号 或 函数名
l test.c: 1 # 查看指定文件指定行
l test.c: printNum1 # 指定文件指定函数
l test.c: 1, test.c: 3 # 指定文件指定行之间
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;更换源码目录&#34;&gt;更换源码目录&lt;/h3&gt;
&lt;p&gt;例如，你编译好的程序文件，放到了另外一台机器上进行调试，或者你的源码文件全都移动到了另外一个目录，怎么办呢？&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;dir&lt;/code&gt;命名指定源码路径&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dir ./temp # 或者使用下面的方式替换当前路径
set substitute-path from [ ] to [ ]  # 将原来的路径替换为新的路径
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;借助 &lt;code&gt;readelf&lt;/code&gt; (bash)命令可以知道原来的源码路径&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;readelf main -p .debug_str
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;编辑源码&#34;&gt;编辑源码&lt;/h3&gt;
&lt;p&gt;为了避免已经启动了调试之后，需要编辑源码，又不想退出，可以直接在gdb模式下编辑源码，它默认使用的编辑器是&lt;code&gt;/bin/ex&lt;/code&gt;，但是你的机器上可能没有这个编辑器，或者你想使用自己熟悉的编辑器，那么可以通过下面的方式在bash下进行设置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;EDITOR=/usr/bin/vim
export EDITOR
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;edit location&lt;/code&gt; 可以在调试模式下编辑源码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;edit 3 #编辑第三行
edit printNum #编辑printNum函数
edit test.c: 5 #编辑test.c第五行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动时，如果带上&lt;code&gt;tui&lt;/code&gt;(Text User Interface)参数，会有意想不到的效果，它会将调试在多个文本窗口呈现：&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688032123583.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">[Linux] GDB使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/OU-pouays/"" data-c="
          &lt;p&gt;&lt;strong&gt;GCC&lt;/strong&gt;（英文全拼：&lt;strong&gt;GNU Compiler Collection&lt;/strong&gt;）是 GNU 工具链的主要组成部分，是一套以 GPL 和 LGPL 许可证发布的程序语言编译器自由软件，由Richard Stallman 于 1985 年开始开发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GCC&lt;/strong&gt; 是Linux 下使用最广泛的 C/C++ 编译器，大多数的 Linux 发行版本都默认安装，不管是开发人员还是初学者，一般都将 &lt;strong&gt;GCC&lt;/strong&gt; 作为 Linux 下首选的编译工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;gcc&lt;/strong&gt;（&lt;strong&gt;GUN C Compiler&lt;/strong&gt;）是&lt;strong&gt;GCC&lt;/strong&gt;中的 &lt;code&gt;c&lt;/code&gt; 编译器，而&lt;strong&gt;g++&lt;/strong&gt;（&lt;strong&gt;GUN C++ Compiler&lt;/strong&gt;）是&lt;strong&gt;GCC&lt;/strong&gt;中的 &lt;code&gt;c++&lt;/code&gt; 编译器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gcc&lt;/code&gt;和 &lt;code&gt;g++&lt;/code&gt; 两者都可以编译&lt;code&gt;c&lt;/code&gt;和&lt;code&gt;cpp&lt;/code&gt;文件，但存在差异。&lt;code&gt;gcc&lt;/code&gt;在编译&lt;code&gt;cpp&lt;/code&gt;时语法按照&lt;code&gt;c&lt;/code&gt;来编译，但默认不能链接到&lt;code&gt;c++&lt;/code&gt;的库（&lt;code&gt;gcc&lt;/code&gt;默认链接&lt;code&gt;c&lt;/code&gt;库，&lt;code&gt;g++&lt;/code&gt;默认链接&lt;code&gt;c++&lt;/code&gt;库）。&lt;br&gt;
&lt;code&gt;g++&lt;/code&gt;编译&lt;code&gt;.c&lt;/code&gt;和&lt;code&gt;.cpp&lt;/code&gt;文件都统一按&lt;code&gt;cpp&lt;/code&gt;的语法规则来编译。&lt;br&gt;
所以一般编译c用&lt;code&gt;gcc&lt;/code&gt;，编译&lt;code&gt;c++&lt;/code&gt;用&lt;code&gt;g++&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;直接使用&#34;&gt;直接使用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc main.c # 在 gcc 命令后面紧跟源文件名 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不管源文件的名字是什么，GCC 生成的可执行文件的默认名字始终是&lt;code&gt;a.out&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不像 Windows，在 Linux 中不以文件后缀来区分可执行文件，Linux 下的可执行文件后缀理论上可以是任意的，这里的&lt;code&gt;.out&lt;/code&gt;只是用来表明它是 &lt;code&gt;gcc&lt;/code&gt; 的输出文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-o&lt;/code&gt;选项 可以自定义文件名&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc main.c -o out/main
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面是通过gcc命令一次性完成编译和链接的整个过程，这样最方便，大家在使用的过程中一般都这么做。实际上，gcc命令也可以将编译和链接分开，每次只完成一项任务。&lt;/p&gt;
&lt;h2 id=&#34;分步骤执行&#34;&gt;分步骤执行&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意，&lt;code&gt;gcc&lt;/code&gt;对于语法错误的检查是在编译阶段进行的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-预处理preprocessing&#34;&gt;1. 预处理（Preprocessing）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;-E&lt;/code&gt;选项 &lt;strong&gt;进行宏替换&lt;/strong&gt; 将源文件执行预处理操作 也即生成&lt;code&gt;*.i&lt;/code&gt;文件&lt;br&gt;
&lt;code&gt;gcc&lt;/code&gt;编译器将对以&lt;code&gt;#&lt;/code&gt;开头的指令进行解析&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc -E Demo.c -o Demo.i
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.i&lt;/code&gt;文件可用记事本打开&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;预处理时会将所有注释都去掉&lt;/strong&gt;，所以反编译回来的代码是没有注释的！&lt;/p&gt;
&lt;p&gt;使用指令&lt;code&gt;gcc -E Demo.c&lt;/code&gt; 而不使用-o指定输出的文件名时内容将会直接输出到Dos框中，而不会产生文件&lt;/p&gt;
&lt;h3 id=&#34;2-编译compiling&#34;&gt;2. 编译（Compiling）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;-S&lt;/code&gt;选项 生成汇编代码 将 &lt;code&gt;*.i&lt;/code&gt; 文件中源码转化为汇编代码 &lt;code&gt;*.s&lt;/code&gt; 文件&lt;br&gt;
用记事本打开会发现c源码已经被编译器转化为汇编代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc -S Demo.i -o Demo.s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果使用指令 &lt;code&gt;gcc -S Demo.i&lt;/code&gt; 即不指定输出文件名，默认也将会在当前目录下产生文件&lt;code&gt;Demo.s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也可以直接由 &lt;code&gt;.c&lt;/code&gt; 文件生成 &lt;code&gt;.s&lt;/code&gt; 汇编文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc -S hello.c
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-汇编assembling&#34;&gt;3.  汇编（Assembling）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;-c&lt;/code&gt;选项 生成机器可识别代码 将源文件编译成目标文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc -c main.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于微软编译器（内嵌在 Visual C++ 或者 Visual Studio 中），目标文件的后缀为&lt;code&gt;.obj&lt;/code&gt;；对于 GCC 编译器，目标文件的后缀为&lt;code&gt;.o&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果希望自定义目标文件的名字，那么仍然可以使用&lt;code&gt;-o&lt;/code&gt;选项&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc -c main.c -o a.o
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以由 &lt;code&gt;.i&lt;/code&gt; 或 &lt;code&gt;.s&lt;/code&gt; 文件生成目标文件 &lt;code&gt;.o&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc -c hello.i -o hello.o gcc -c hello.s -o hello.o
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-链接linking&#34;&gt;4.  链接（Linking）&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;gcc&lt;/code&gt;命令后面紧跟目标文件的名字，就可以将目标文件链接成为可执行文件。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;gcc&lt;/code&gt;命令后面紧跟源文件名字或者目标文件名字都是可以的，gcc命令能够自动识别到底是源文件还是目标文件：如果是源文件，那么要经过编译和链接两个步骤才能生成可执行文件；如果是目标文件，只需要链接就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc main.o #将 main.o 链接为 默认的 a.out
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;-o&lt;/code&gt;选项仍然能够自定义可执行文件的名字&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc main.o -o main.out
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-I&lt;/code&gt; ：指定头文件的包含路径。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-L&lt;/code&gt; ：指定链接库的包含路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;链接库&#34;&gt;链接库&lt;/h2&gt;
&lt;p&gt;库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。&lt;/p&gt;
&lt;p&gt;库有两种：&lt;strong&gt;静态库&lt;/strong&gt;（&lt;code&gt;.a&lt;/code&gt;、&lt;code&gt;.lib&lt;/code&gt;）和&lt;strong&gt;动态库&lt;/strong&gt;（&lt;code&gt;.so&lt;/code&gt;、&lt;code&gt;.dll&lt;/code&gt;）。&lt;br&gt;
所谓静态、动态是指链接方式&lt;/p&gt;
&lt;h3 id=&#34;使用静态库&#34;&gt;使用静态库&lt;/h3&gt;
&lt;p&gt;之所以称为“&lt;strong&gt;静态库&lt;/strong&gt;”，是因为在链接阶段，会将汇编生成的目标文件&lt;code&gt;.o&lt;/code&gt;与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。&lt;/p&gt;
&lt;p&gt;其实一个静态库可以简单看成是一组目标文件（&lt;code&gt;.o&lt;/code&gt;/&lt;code&gt;.obj&lt;/code&gt;文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。&lt;/p&gt;
&lt;p&gt;Linux下使用&lt;code&gt;ar&lt;/code&gt;工具、Windows下vs使用&lt;code&gt;lib.exe&lt;/code&gt;，将目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索。&lt;/p&gt;
&lt;p&gt;静态库特点总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态库对函数库的链接是放在编译时期完成的。&lt;/li&gt;
&lt;li&gt;程序在运行时与函数库再无瓜葛，移植方便。&lt;/li&gt;
&lt;li&gt;浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;将-c-文件编译成静态库-a-文件&#34;&gt;将 .c 文件编译成静态库 .a 文件&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;生成 &lt;code&gt;.o&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;再由 &lt;code&gt;.o&lt;/code&gt; 文件 生成 &lt;code&gt;.a&lt;/code&gt; 文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc -c foo.c # 生成 foo.o 目标文件
ar rcs libfoo.a foo.o # 生成 libfoo.a 静态库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-static&lt;/code&gt; ：使用静态链接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编译 &lt;code&gt;hello.c&lt;/code&gt; 并链接静态库 &lt;code&gt;libfoo.a&lt;/code&gt;（通过加上 &lt;code&gt;-static&lt;/code&gt; 选项）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc hello.c -static libfoo.a -o hello
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;-L&lt;/code&gt; 指定库的搜索路径，并使用 &lt;code&gt;-l&lt;/code&gt; 指定库名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc hello.c -static -L. -l foo -o hello # -L . 代表搜索当前目录 -l foo指定库名为foo
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用共享库&#34;&gt;使用共享库&lt;/h3&gt;
&lt;p&gt;为什么需要动态库，其实也是静态库的问题导致。空间浪费是静态库的一个问题。&lt;/p&gt;
&lt;p&gt;另一个问题是静态库对程序的更新、部署和发布页会带来麻烦。如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，全量更新）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态库在程序编译时并不会被连接到目标代码中，而是在程序运行时才被载入&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不同的应用程序如果调用相同的库，那么&lt;strong&gt;在内存里只需要有一份该共享库的实例&lt;/strong&gt;，&lt;strong&gt;规避了空间浪费问题&lt;/strong&gt;。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。&lt;strong&gt;用户只需要更新动态库即可，增量更新&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-shared&lt;/code&gt; ：创建共享库/动态库。&lt;br&gt;
由于动态库可以被多个进程共享加载，所以需要使用 &lt;code&gt;-fPIC&lt;/code&gt; 选项生成位置无关的代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc foo.c -shared -fPIC -o libfoo.so
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译 hello.c 并链接共享库 libfoo.so&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc hello.c libfoo.so -o hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样可以使用 &lt;code&gt;-L&lt;/code&gt; 和 &lt;code&gt;-l&lt;/code&gt; 选项指定库的路径和名称&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc hello.c -L . -l foo -o hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是此时直接运行 hello 程序仍然失败 原因是找不到 &lt;code&gt;libfoo.so&lt;/code&gt; 共享库&lt;br&gt;
这是因为 &lt;code&gt;libfoo.so&lt;/code&gt; 并不在 Linux 系统的默认搜索目录中，解决办法是我们主动告诉系统，libfoo.so 共享库在哪里。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;方式一：设置环境变量 LD_LIBRARY_PATH&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export LD_LIBRARY_PATH=$(pwd)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;方式二：使用 &lt;code&gt;rpath&lt;/code&gt; 将共享库位置嵌入到程序&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc hello.c -L. -lfoo -Wl,-rpath=`pwd` -o hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rpath&lt;/code&gt; 即 run path，是种可以将共享库位置嵌入程序中的方法，从而不用依赖于默认位置和环境变量。&lt;br&gt;
这里在链接时使用 &lt;code&gt;-Wl,-rpath=/path/to/yours&lt;/code&gt; 选项，&lt;code&gt;-Wl&lt;/code&gt;会发送以逗号分隔的选项到链接器，注意逗号分隔符后面没有空格。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;方式三：将 &lt;code&gt;libfoo.so&lt;/code&gt; 共享库添加到系统路径&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo cp libfoo.so /usr/lib/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过命令&lt;code&gt;ldd&lt;/code&gt;可以列出程序的动态依赖&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688029530679.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;其他选项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-D&lt;/code&gt; : 在程序编译的时候，指定一个宏&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-B &lt;/code&gt;&lt;directory&gt; ：将 &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; 添加到编译器的搜索路径。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-save-temps&lt;/code&gt; ：不用删除中间文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-save-temps=&amp;lt;arg&amp;gt;&lt;/code&gt; ：不用删除指定的中间文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-time&lt;/code&gt; ：为每个子流程的执行计时。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Xassembler &amp;lt;arg&amp;gt;&lt;/code&gt; ：将 &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; 传递给汇编器（assembler）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Xpreprocessor &amp;lt;arg&amp;gt;&lt;/code&gt; ：将 &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; 传递给预处理器（preprocessor）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Xlinker &amp;lt;arg&amp;gt;&lt;/code&gt; ：将 &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; 传递给链接器（linker）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-g&lt;/code&gt; : 生成调试信息。GNU 调试器可利用该信息, 否则不能使用GDB进行调试.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-O0/1/2/3&lt;/code&gt; : 编译器的优化选项的4个级别，&lt;code&gt;-O0&lt;/code&gt;表示没有优化,&lt;code&gt;-O1&lt;/code&gt;为缺省值，&lt;code&gt;-O3&lt;/code&gt;优化级别最高。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Wall&lt;/code&gt; 生成所有警告信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-MM&lt;/code&gt; 输出依赖关系（不包含标准库文件）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gcc编译多个文件&#34;&gt;gcc编译多个文件&lt;/h2&gt;
&lt;p&gt;编译这三个文件，可以一次编译：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc hello.c main.c -o main # 生成可执行文件main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以独立编译：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc -Wall -c main.c -o main.o
gcc -Wall -c hello.c -o hello.o
gcc -Wall main.o hello.o -o main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;独立编译的好处是，当其中某个模块发送改变时，只需要编译该模块就行，不必重新编译所有文件，这样可以节省编译时间。&lt;/p&gt;
">[Linux] gcc/g++使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/Zt1yDkGGU/"" data-c="
          &lt;p&gt;Vim是一款功能强大的文本编辑器，是Unix和Linux系统中最常用的编辑器之一，可以大大提高编辑效率。它是Vi编辑器的增强版，提供了更多的功能和快捷键，可以大大提高编辑效率。&lt;/p&gt;
&lt;p&gt;虽然它的学习曲线比较陡峭，但一旦掌握了它的基本操作和快捷键，就可以在编辑文本时事半功倍。&lt;/p&gt;
&lt;p&gt;以下是Vim的一些特点和功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模式&lt;/strong&gt;：Vim有多种模式，包括普通模式、插入模式、可视模式等。在普通模式下，可以使用快捷键执行各种操作，如复制、剪切、粘贴、查找、替换等。在插入模式下，可以像普通文本编辑器一样输入文本。在可视模式下，可以选择文本块进行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;快捷键&lt;/strong&gt;：Vim的快捷键非常丰富，可以大大提高编辑效率。例如，使用yy命令复制一行文本，使用dd命令剪切一行文本，使用p命令粘贴文本等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;插件&lt;/strong&gt;：Vim支持各种插件，可以扩展其功能。例如，可以安装代码高亮插件、自动补全插件、文件管理插件等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;跨平台&lt;/strong&gt;：Vim可以在多种操作系统上运行，包括Unix、Linux、Windows等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;自定义&lt;/strong&gt;：Vim可以通过修改配置文件来自定义其行为。例如，可以修改快捷键、设置颜色方案、添加插件等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;移动&#34;&gt;移动&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;j&lt;/code&gt;，下&lt;/li&gt;
&lt;li&gt;&lt;code&gt;k&lt;/code&gt;，上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h&lt;/code&gt;，左&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l&lt;/code&gt;，右&lt;/li&gt;
&lt;li&gt;&lt;code&gt;v&lt;/code&gt;，按 &lt;code&gt;v&lt;/code&gt; 之后按方向键可以选中你要选中的文字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gg&lt;/code&gt;，跳到第 1 行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G&lt;/code&gt;，跳到最后一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;16G&lt;/code&gt; 或 &lt;code&gt;:16&lt;/code&gt;，跳到第 16 行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt;，到本行 行尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt;，到本行 行头&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt;，到本行的第一个非blank字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g_&lt;/code&gt;，到本行最后一个不是blank字符的位置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt;，匹配括号移动，包括 &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;（需要把光标先移到括号上）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;，匹配光标当前所在的单词，移动光标到 下一个 匹配单词&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt;，匹配光标当前所在的单词，移动光标到 上一个 匹配单词&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/pattern&lt;/code&gt;，搜索 &lt;code&gt;pattern&lt;/code&gt; 的字符串（如果搜索出多个匹配，可按&lt;code&gt;n&lt;/code&gt;键到下一个）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fa&lt;/code&gt;，到下一个为&lt;code&gt;a&lt;/code&gt;的字符处，你也可以&lt;code&gt;fs&lt;/code&gt;到下一个为&lt;code&gt;s&lt;/code&gt;的字符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3fa&lt;/code&gt;，在当前行查找第三个出现的a。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;, 到逗号前的第一个字符。逗号可以变成其它字符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt;，和 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; 一样，只不过是相反方向。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;插入&#34;&gt;插入&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt;，在当前 &lt;strong&gt;行首&lt;/strong&gt; 插入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt;，在当前 &lt;strong&gt;行尾&lt;/strong&gt; 插入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;，在当前字符的 &lt;strong&gt;左边&lt;/strong&gt; 插入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;，在当前字符的 &lt;strong&gt;右边&lt;/strong&gt; 插入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt;(小写)，在当前行 &lt;strong&gt;下面&lt;/strong&gt; 插入一个新行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O&lt;/code&gt;(大写)，在当前行 &lt;strong&gt;上面&lt;/strong&gt; 插入一个新行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;删除&#34;&gt;删除&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt;，删除 &lt;strong&gt;光标后&lt;/strong&gt; 的 &lt;strong&gt;1&lt;/strong&gt; 个字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2x&lt;/code&gt;，删除 &lt;strong&gt;光标后&lt;/strong&gt; 的 &lt;strong&gt;2&lt;/strong&gt; 个字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X&lt;/code&gt;，删除 &lt;strong&gt;光标前&lt;/strong&gt; 的 &lt;strong&gt;1&lt;/strong&gt; 个字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2X&lt;/code&gt;，删除 &lt;strong&gt;光标前&lt;/strong&gt; 的 &lt;strong&gt;2&lt;/strong&gt; 个字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dd&lt;/code&gt;，删除当前行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cc&lt;/code&gt;，删除当前行后进入 &lt;code&gt;insert&lt;/code&gt; 模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dw&lt;/code&gt;，删除当前光标下的单词/空格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d$&lt;/code&gt;，删除光标至 &lt;strong&gt;行尾&lt;/strong&gt; 所有字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dG&lt;/code&gt;，删除光标至 &lt;strong&gt;文件尾&lt;/strong&gt; 所有字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ndd&lt;/code&gt;，从当前光标开始，删掉 &lt;code&gt;n&lt;/code&gt; 行，比如&lt;code&gt;3dd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dt&amp;quot;&lt;/code&gt;，删除所有的内容，直到遇到双引号 &lt;code&gt;&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo &amp;gt; aa.txt&lt;/code&gt;，从 bash 角度清空文件内容，这个比较高效&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;复制&#34;&gt;复制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt;，复制光标所选字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yw&lt;/code&gt;，复制光标后单词&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yy&lt;/code&gt;或&lt;code&gt;y_&lt;/code&gt;或&lt;code&gt;Y&lt;/code&gt;，复制当前行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;4yy&lt;/code&gt;，复制当前行及下面 &lt;code&gt;4&lt;/code&gt; 行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y$&lt;/code&gt;，复制光标位置至 &lt;strong&gt;行尾&lt;/strong&gt; 的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y^&lt;/code&gt;，复制光标位置至 &lt;strong&gt;第一个非空白字符&lt;/strong&gt; 的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y0&lt;/code&gt;，从当前位置复制到 &lt;strong&gt;行首&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yG&lt;/code&gt;，从当前行复制到文件结束&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y20G&lt;/code&gt;，从当前行复制到第&lt;code&gt;20&lt;/code&gt;行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y?bar&lt;/code&gt;，复制至上一个出现&lt;code&gt;bar&lt;/code&gt;的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;粘贴&#34;&gt;粘贴&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt;(小写)，将粘贴板中内容复制到 &lt;strong&gt;光标之后&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;P&lt;/code&gt;(大写)，将粘贴板中内容复制到 &lt;strong&gt;光标之前&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:%s/YouMeek/Judasn/g&lt;/code&gt;，把文件中&lt;strong&gt;所有&lt;/strong&gt; &lt;code&gt;YouMeek&lt;/code&gt; 替换为&lt;code&gt;Judasn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:%s/YouMeek/Judasn/&lt;/code&gt;，把文件中&lt;strong&gt;所有行中第一个&lt;/strong&gt; &lt;code&gt;YouMeek&lt;/code&gt; 替换为&lt;code&gt;Judasn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:s/YouMeek/Judasn/&lt;/code&gt;，把光标&lt;strong&gt;当前行第一个&lt;/strong&gt; &lt;code&gt;YouMeek&lt;/code&gt; 替换为 &lt;code&gt;Judasn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:s/YouMeek/Judasn/g&lt;/code&gt;，把光标&lt;strong&gt;当前行所有&lt;/strong&gt; &lt;code&gt;YouMeek&lt;/code&gt; 替换为 &lt;code&gt;Judasn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:s#YouMeek/#Judasn/#&lt;/code&gt;，除了使用斜杠作为分隔符之外，还可以使用 &lt;code&gt;#&lt;/code&gt; 作为分隔符，此时搜索部分中间出现的 &lt;code&gt;/&lt;/code&gt; 不会作为分隔符，该命令表示：把光标当前行第一个&lt;code&gt;YouMeek/&lt;/code&gt; 替换为 &lt;code&gt;Judasn/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:10,31s/YouMeek/Judasn/g&lt;/code&gt;，把第 &lt;code&gt;10&lt;/code&gt; 行到 &lt;code&gt;31&lt;/code&gt; 行之间所有 &lt;code&gt;YouMeek&lt;/code&gt; 替换为 &lt;code&gt;Judasn&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vim 提供了 11 个剪贴板，分别是：&lt;code&gt;0&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;,&lt;code&gt;2&lt;/code&gt;,&lt;code&gt;3&lt;/code&gt;,&lt;code&gt;4&lt;/code&gt;,&lt;code&gt;5&lt;/code&gt;,&lt;code&gt;6&lt;/code&gt;,&lt;code&gt;7&lt;/code&gt;,&lt;code&gt;8&lt;/code&gt;,&lt;code&gt;9&lt;/code&gt;,&lt;code&gt;a&lt;/code&gt;,&lt;code&gt;&amp;quot;&lt;/code&gt;，默认采用的是 &lt;code&gt;&amp;quot;&lt;/code&gt;，也就是双引号。如果开启了系统剪贴板，则会另外多出两个：&lt;code&gt;+&lt;/code&gt;和&lt;code&gt;*&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;:reg&lt;/code&gt;命令，可以查看各个粘贴板里的内容。&lt;/p&gt;
&lt;p&gt;指定复制到某个剪切板的命令：&lt;code&gt;&amp;quot;7y&lt;/code&gt;，表示使用 &lt;code&gt;7&lt;/code&gt; 号剪切板。&lt;br&gt;
指定黏贴某个剪切板内容：&lt;code&gt;&amp;quot;7p&lt;/code&gt;，表示使用 &lt;code&gt;7&lt;/code&gt; 号剪切板内容进行黏贴&lt;/p&gt;
&lt;p&gt;如果想&lt;code&gt;y&lt;/code&gt;/&lt;code&gt;p&lt;/code&gt;直接和系统剪贴板打通，可以在&lt;code&gt;~/.vimrc&lt;/code&gt;中加上以下配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;set clipboard^=unnamed,unnamedplus
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;guu&lt;/code&gt;，把当前行的字母全部转换成 &lt;strong&gt;小写&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gUU&lt;/code&gt;，把当前行的字母全部转换成 &lt;strong&gt;大写&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g~~&lt;/code&gt;，把当前行的字母是大写的转换成小写，是小写的转换成大写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt;，撤销&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+r&lt;/code&gt; 反撤销&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件操作&#34;&gt;文件操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:e &amp;lt;path/to/file&amp;gt;&lt;/code&gt;，打开一个文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:saveas &amp;lt;path/to/file&amp;gt;&lt;/code&gt;，另存为 &lt;code&gt;&amp;lt;path/to/file&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:w&lt;/code&gt;，存盘&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:x&lt;/code&gt;， &lt;code&gt;ZZ&lt;/code&gt; 或 &lt;code&gt;:wq&lt;/code&gt;，保存并退出 (&lt;code&gt;:x&lt;/code&gt; 表示仅在需要时保存，&lt;code&gt;ZZ&lt;/code&gt;不需要输入冒号并回车)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:bn&lt;/code&gt; 和 &lt;code&gt;:bp&lt;/code&gt;，你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文&lt;br&gt;
件。（使用&lt;code&gt;:n&lt;/code&gt;也可以到下一个文件）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;块操作&#34;&gt;块操作:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl+v&lt;/code&gt; 然后移动光标选择块区域 进行操作以后按esc使得操作对于整个块区域生效&lt;/li&gt;
&lt;li&gt;&lt;code&gt;J&lt;/code&gt;，把所有的行连接起来（变成一行）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; 或 &lt;code&gt;&amp;gt;&lt;/code&gt;，左右缩进&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt;，自动给缩进&lt;/li&gt;
&lt;/ul&gt;
">[Linux] vim基础</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/ON56mZ7Nv/"" data-c="
          &lt;p&gt;&lt;strong&gt;POSIX&lt;/strong&gt;：可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX），发布者为电气与电子工程师协会（Institute of Electrical and Electronics Engineers），简称IEEE。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;POSIX&lt;/strong&gt;是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称，&lt;strong&gt;其正式称呼为IEEE 1003&lt;/strong&gt;，而&lt;strong&gt;国际标准名称为ISO/IEC 9945&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;基础命令&#34;&gt;基础命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Ctrl + r&lt;/code&gt;，进入历史命令的搜索功能模式&lt;br&gt;
&lt;code&gt;history&lt;/code&gt;，查看所有的历史命令&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tty&lt;/code&gt;，查看当前终端&lt;br&gt;
输入 &lt;code&gt;echo $$&lt;/code&gt; 可以查看当前终端的进程pid&lt;/p&gt;
&lt;p&gt;&amp;amp;表示这个程序在后台运行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./hello &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;nohup command &amp;amp;&lt;/code&gt;  之后&lt;code&gt;ctrl+d &lt;/code&gt;或者 关闭窗口 进程仍然会在后台执行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./&lt;/code&gt;表示当前目录 如果不写&lt;code&gt;./&lt;/code&gt;，Linux 会到系统路径下查找文件&lt;br&gt;
所谓系统路径，就是环境变量指定的路径，我们可以通过修改环境变量添加自己的路径，或者删除某个路径。&lt;br&gt;
很多时候，一条 Linux 命令对应一个可执行程序，如果执行命令时没有指明路径，那么就会到系统路径下查找对应的程序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;|&lt;/code&gt; 管道 (pipeline) 连结上个指令的标准输出，做为下个指令的标准输入。&lt;br&gt;
通过 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 可以控制多条命令的执行情况&lt;br&gt;
&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;要求前一条命令执行成功才执行后面的语句 &lt;code&gt;||&lt;/code&gt;则是前一条失败才执行后面语句&lt;/p&gt;
&lt;p&gt;查询CPU信息: &lt;code&gt;cat /proc/cpuinfo &lt;/code&gt;&lt;br&gt;
查看CPU的核的个数: &lt;code&gt;cat /proc/cpuinfo | grep processor | wc -l&lt;/code&gt;&lt;br&gt;
查看内存信息: &lt;code&gt;cat /proc/meminfo&lt;/code&gt;&lt;br&gt;
显示内存page大小（以KByte为单位）: &lt;code&gt;pagesize&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ifconfig&lt;/code&gt;，查看内网 IP 等信息（常用）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;date&lt;/code&gt;，查看系统时间（常用）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;date -s20080103&lt;/code&gt;，设置日期（常用）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;date -s18:24&lt;/code&gt;，设置时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;bashrc与profile都用于保存用户的环境信息，bashrc用于交互式non-loginshell，而profile用于交互式login shell。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/profile&lt;/code&gt;，&lt;code&gt;/etc/bashrc&lt;/code&gt; 是系统全局环境变量设定&lt;br&gt;
&lt;code&gt;~/.profile&lt;/code&gt;，&lt;code&gt;~/.bashrc&lt;/code&gt;用户目录下的私有环境变量设定&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unset $JAVA_HOME&lt;/code&gt;，删除指定的环境变量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;~/.profile&lt;/code&gt;与&lt;code&gt;~/.bashrc&lt;/code&gt;的区别:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这两者都具有个性化定制功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~/.profile&lt;/code&gt;可以设定本用户专有的路径，环境变量，等，它只能登入的时候执行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~/.bashrc&lt;/code&gt;也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以在这些环境变量中设置自己经常进入的文件路径，以及命令的快捷方式&lt;br&gt;
通过修改&lt;code&gt;.bashrc&lt;/code&gt; 可以为命令设置别名 (该文件就在主文件夹底下 隐藏显式)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;alias lsl=&#39;ls -lrt&#39; 
alias lm=&#39;ls -al | more&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动帐号后自动执行的是 文件为&lt;code&gt;.profile&lt;/code&gt;，然后通过这个文件可设置自己的环境变量&lt;br&gt;
安装的软件路径一般需要加入到&lt;code&gt;path&lt;/code&gt;中:&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;ls -l&lt;/code&gt;可查看文件的属性字段 文件属性字段总共有10个字母组成&lt;br&gt;
第一个字母表示文件类型，如果这个字母是一个减号&lt;code&gt;-&lt;/code&gt;, 则说明该文件是一个普通文件。字母&lt;code&gt;d&lt;/code&gt;表示该文件是一个目录，字母&lt;code&gt;d&lt;/code&gt;,是dirtectory(目录)的缩写。&lt;br&gt;
后面的9个字母为该文件的权限标识，3个为一组，分别表示文件所属用户、用户所在组、其它用户的读写和执行权限；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;-rwxrw-r-- colin king 725 2023-11-12 15:37 /home/colin/a 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表示这个文件对文件拥有者colin这个用户可读写、可执行；对colin所在的组（king）可读可写；对其它用户只可读&lt;/p&gt;
&lt;h2 id=&#34;帮助命令&#34;&gt;帮助命令&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;whatis &lt;em&gt;command&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;简要说明&lt;em&gt;command&lt;/em&gt;的作用（显示&lt;em&gt;command&lt;/em&gt;所处的man分类页面）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;man &lt;em&gt;command&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;查询命令&lt;em&gt;command&lt;/em&gt;的说明文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;which &lt;em&gt;command&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;查看程序的binary文件所在路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;whereis &lt;em&gt;command&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;查看程序的搜索路径(用于当系统中安装了同一软件的多个版本时，不确定使用的是哪个版本时)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;文件目录管理&#34;&gt;文件/目录管理&lt;/h2&gt;
&lt;p&gt;创建：&lt;code&gt;mkdir&lt;/code&gt;&lt;br&gt;
&lt;code&gt;touch&lt;/code&gt; 文件名，创建一个空白文件&lt;/p&gt;
&lt;p&gt;删除：&lt;code&gt;rm&lt;/code&gt;&lt;br&gt;
删除非空目录：&lt;code&gt;rm -rf file/dirtectory&lt;/code&gt;&lt;br&gt;
删除日志 &lt;code&gt;rm *log&lt;/code&gt; (等价: &lt;code&gt;$find ./ -name “*log” -exec rm {} ;&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;移动：&lt;code&gt;mv&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;重命名: &lt;code&gt;mv/rename&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;复制：&lt;code&gt;cp&lt;/code&gt; (复制目录：&lt;code&gt;cp -r&lt;/code&gt; )&lt;/p&gt;
&lt;p&gt;切换到上一个工作目录：&lt;code&gt;cd -&lt;/code&gt;或者&lt;code&gt;cd ..&lt;/code&gt;&lt;br&gt;
切换到home目录： &lt;code&gt;cd&lt;/code&gt; or &lt;code&gt;cd ~&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;显示当前路径: &lt;code&gt;pwd&lt;/code&gt;&lt;br&gt;
显示当前目录下的文件: &lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;ls -a&lt;/code&gt; 可以显式隐藏文件&lt;/p&gt;
&lt;p&gt;按时间排序，以列表的方式显示目录项 &lt;code&gt;ls -lrt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看两个文件间的差别: &lt;code&gt;diff file1 file2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在文件内查找指定的字符串: &lt;code&gt;egrep&lt;/code&gt; 执行效果与&lt;code&gt;grep-E&lt;/code&gt;相似&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;egrep Linux * # 查找当前目录下包含字符串“Linux”的文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改变文件的拥有者: &lt;code&gt;chown&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用chmod命令可以更改文件的读写权限，更改读写权限有两种方法，一种是字母方式，一种是数字方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;字母方式: &lt;code&gt;chmod [-R] userMark(+|-) PermissionsMark &lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-R&lt;/code&gt;代表递归&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;|&lt;code&gt;-&lt;/code&gt; 代表增加或删除权限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;userMark&lt;/code&gt;取值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt;：用户&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt;：组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt;：其它用户&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;：所有用户&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PermissionsMark&lt;/code&gt;取值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt;: 读&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt;：写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt;：执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;chmod a+x main # 对所有用户给文件main增加可执行权限
chmod g+w blogs # 对组用户给文件blogs增加可写权限
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;数字方式：
&lt;ul&gt;
&lt;li&gt;数字方式直接设置所有权限，相比字母方式，更加简洁方便；&lt;/li&gt;
&lt;li&gt;使用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;chmod 740 main # 将main的用户权限设置为rwxr-----
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更改文件或目录的拥有者:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;chown username dirOrFile #使用-R选项递归更改该目下所有文件的拥有者
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建符号链接/硬链接:&lt;br&gt;
&lt;code&gt;ln&lt;/code&gt; 加上命令&lt;code&gt;-s&lt;/code&gt;为软链接&lt;br&gt;
软连接等价于起别名 硬链接等价于复制一个新文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat&lt;/code&gt;（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt; 或 &lt;code&gt;--number&lt;/code&gt;：由 1 开始对所有输出的行数编号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-b&lt;/code&gt; 或 &lt;code&gt;--number-nonblank&lt;/code&gt;：和 &lt;code&gt;-n&lt;/code&gt; 相似，只不过对于空白行不编号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; 可以进行输出重定向 &lt;code&gt;cat&lt;/code&gt;默认输出到标准输出流&lt;br&gt;
与&lt;code&gt;cat&lt;/code&gt;结合:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat -n textfile1 &amp;gt; textfile2 # 把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;file&lt;/code&gt;命令用于辨识文件类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;file [-bcLvz][-f &amp;lt;名称文件&amp;gt;][-m &amp;lt;魔法数字文件&amp;gt;...][文件或目录...]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-b&lt;/code&gt; 列出辨识结果时，不显示文件名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt; 详细显示指令执行过程，便于排错或分析程序执行的情形。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt;&amp;lt;名称文件&amp;gt; 指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-L&lt;/code&gt; 直接显示符号连接所指向的文件的类别。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-m&amp;lt;魔法数字文件&amp;gt;&lt;/code&gt; 指定魔法数字文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt; 显示版本信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-z&lt;/code&gt; 尝试去解读压缩文件的内容。&lt;br&gt;
&lt;code&gt;[文件或目录...]&lt;/code&gt;为 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ar&lt;/code&gt;命令用于建立或修改备存文件，或是从备存文件中抽取文件。&lt;code&gt;ar&lt;/code&gt;可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt; 删除备存文件中的成员文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt; 变更成员文件在备存文件中的次序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt; 显示备存文件中的成员文件内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;q&lt;/code&gt; 将文件附加在备存文件末端。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; 将文件插入备存文件中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt; 显示备存文件中所包含的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; 自备存文件中取出成员文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&amp;lt;成员文件&amp;gt;&lt;/code&gt; 将文件插入备存文件中指定的成员文件之后。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&amp;lt;成员文件&amp;gt;&lt;/code&gt; 将文件插入备存文件中指定的成员文件之前。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt; 建立备存文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&amp;lt;成员文件&amp;gt;&lt;/code&gt; 将文件插入备存文件中指定的成员文件之前。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt; 保留备存文件中文件的日期。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt; 不产生符号表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;v&lt;/code&gt; 程序执行时显示详细的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ar rv one.bak a.c b.c # 打包 a.c b.c文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;文本处理&#34;&gt;文本处理&lt;/h2&gt;
&lt;p&gt;文件查找: &lt;code&gt;find&lt;/code&gt;&lt;br&gt;
Eg. 查找txt和pdf文件:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;find . \( -name &amp;quot;*.txt&amp;quot; -o -name &amp;quot;*.pdf&amp;quot; \) -print
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;按类型搜索 &lt;code&gt;-f&lt;/code&gt; 文件 / &lt;code&gt;-l&lt;/code&gt; 符号链接 / &lt;code&gt;-d&lt;/code&gt; 目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按时间搜索&lt;br&gt;
&lt;code&gt;-atime&lt;/code&gt; 访问时间 (单位是天，分钟单位则是-amin，以下类似）&lt;br&gt;
&lt;code&gt;-mtime&lt;/code&gt; 修改时间 （内容被修改）&lt;br&gt;
&lt;code&gt;-ctime&lt;/code&gt; 变化时间 （元数据或权限变化）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按大小搜索 &lt;code&gt;-size&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到后的操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除 &lt;code&gt;-delete&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打印 &lt;code&gt;-print&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行动作 &lt;code&gt;-exec+命令&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文本搜索: &lt;code&gt;grep&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-o&lt;/code&gt; 只输出匹配的文本行 VS &lt;code&gt;-v&lt;/code&gt; 只输出没有匹配的文本行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt; 统计文件中包含文本的次数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt; 打印匹配的行号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt; 搜索时忽略大小写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l&lt;/code&gt; 只打印文件名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;xargs&lt;/code&gt; 能够将输入数据转化为特定命令的命令行参数；是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。之所以能用到这个命令，关键是由于很多命令不支持&lt;code&gt;|&lt;/code&gt;管道来传递参数，而日常工作中有有这个必要。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; 定义定界符 （默认为空格 多行的定界符为 n）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt; 指定输出为多行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-I {}&lt;/code&gt; 指定替换字符串，这个字符串在xargs扩展时会被替换掉,用于待执行的命令需要多个参数时&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-0&lt;/code&gt;：指定&lt;code&gt;0&lt;/code&gt;为输入定界符&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;find . type f -name &amp;quot;*.swp&amp;quot; | xargs rm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对文件内容进行排序: &lt;code&gt;sort&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt; 按数字进行排序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; 按字典序进行排序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt; 逆序排序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-k N&lt;/code&gt; 指定按第&lt;code&gt;N&lt;/code&gt;列排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;uniq&lt;/code&gt;命令用于检查及删除文本文件中重复出现的行列，一般与 &lt;code&gt;sort&lt;/code&gt; 命令结合使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt;或&lt;code&gt;--count&lt;/code&gt; 在每列旁边显示该行重复出现的次数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt;或&lt;code&gt;--repeated&lt;/code&gt; 仅显示重复出现的行列。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-u&lt;/code&gt;或&lt;code&gt;--unique&lt;/code&gt; 仅显示出一次的行列。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w&amp;lt;字符位置&amp;gt;&lt;/code&gt;或&lt;code&gt;--check-chars=&amp;lt;字符位置&amp;gt;&lt;/code&gt; 指定要比较的字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;tr&lt;/code&gt; 命令用于转换或删除文件中的字符。&lt;code&gt;tr&lt;/code&gt; 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;tr [OPTION] SET1 [SET2] 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt;, &lt;code&gt;--delete&lt;/code&gt;：删除指令字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;--complement&lt;/code&gt;：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt;, &lt;code&gt;--squeeze-repeats&lt;/code&gt;：缩减连续重复的字符成指定的单个字符 常用于压缩多余的空格&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat file | tr -s &#39; &#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;cut&lt;/code&gt;命令用于显示每行从开头算起 &lt;code&gt;num1&lt;/code&gt; 到 &lt;code&gt;num2&lt;/code&gt; 的文字。&lt;code&gt;cut&lt;/code&gt; 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt; ：以字符为单位进行分割。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; ：自定义分隔符，默认为制表符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt; ：与&lt;code&gt;-d&lt;/code&gt;一起使用，指定显示哪个区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;wc&lt;/code&gt; 统计行和字符的工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-l&lt;/code&gt;  统计行数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w&lt;/code&gt;  统计单词数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt;  统计字符数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;磁盘管理&#34;&gt;磁盘管理&lt;/h2&gt;
&lt;p&gt;查看磁盘空间利用大小: &lt;code&gt;df -h&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-h&lt;/code&gt;: human缩写，以易读的方式显示结果（即带单位：比如M/G，如果不加这个参数，显示的数字以B为单位）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看目录所占空间大小:&lt;code&gt;du -sh&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt; 递归整个目录的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-h&lt;/code&gt; 人性化显示&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;打/解包: &lt;code&gt;tar&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;tar -cvf etc.tar /etc # 仅打包，不压缩！ 压缩用zip
tar -xvf demo.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-x&lt;/code&gt; 表示进行解包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt; :表示进行打包, 即将所有文件放到一个文件夹中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt; :显示打包进度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt; :使用档案文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-z&lt;/code&gt; 解压gz文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-j&lt;/code&gt; 解压bz2文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-J&lt;/code&gt; 解压xz文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程管理&#34;&gt;进程管理&lt;/h2&gt;
&lt;p&gt;任何进程都与文件关联；我们会用到&lt;code&gt;lsof&lt;/code&gt;工具（list opened files），作用是列举系统中已经被打开的文件。在linux环境中，任何事物都是文件，设备是文件，目录是文件，甚至sockets也是文件。用好&lt;code&gt;lsof&lt;/code&gt;命令，对日常的linux管理非常有帮助。&lt;/p&gt;
&lt;p&gt;查看端口占用的进程状态：&lt;code&gt;lsof&lt;/code&gt; 直接加文件名&lt;br&gt;
&lt;code&gt;lsof abc.txt&lt;/code&gt;：显示开启文件&lt;code&gt;abc.txt&lt;/code&gt;的进程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt;：查看端口占用 #lsof -i:8080 查看8080端口占用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt;: 显示该进程现在打开的文件 # -c -p 1234 列出进程号为1234的进程所打开的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-u username&lt;/code&gt;: 查看用户&lt;code&gt;username&lt;/code&gt;的进程所打开的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+d&lt;/code&gt;: 查询指定目录下被进程开启的文件（使用&lt;code&gt;+D&lt;/code&gt; 递归c目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查询正在运行的进程信息: &lt;code&gt;ps&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-A/-e&lt;/code&gt; 列出所有的进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w&lt;/code&gt; 显示加宽可以显示较多的资讯&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;：显示终端上的所有进程，包括其他用户的进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt;：显示进程的详细信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt;：显示没有控制终端的进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;j&lt;/code&gt;：列出与作业控制相关的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ps -ef | grep 进程关键字 # 查找指定进程:
ps auxw --sort=-%cpu # 查看CPU使用率最高的进程
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-%cpu&lt;/code&gt; 代表降序 若为&lt;code&gt;--sort=%cpu&lt;/code&gt; 表示升序&lt;/p&gt;
&lt;p&gt;输入参数&lt;code&gt;j&lt;/code&gt;时可以查看到与作业控制相关的信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ppid&lt;/code&gt; &lt;code&gt;父进程id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pid&lt;/code&gt; &lt;code&gt;进程id &lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pgid&lt;/code&gt; &lt;code&gt;进程组id &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;显示进程信息，并实时更新: &lt;code&gt;top&lt;/code&gt;&lt;br&gt;
在&lt;code&gt;top&lt;/code&gt;界面输入字符命令后显示相应的进程状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;P&lt;/code&gt;：根据CPU使用百分比大小进行排序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M&lt;/code&gt;：根据驻留内存大小进行排序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;：使&lt;code&gt;top&lt;/code&gt;不显示任何闲置或者僵死进程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt;：显示或隐藏内存状态信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt;：设置刷新时间间隔&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Space&amp;gt;&lt;/code&gt;：立即刷新&lt;/li&gt;
&lt;li&gt;&lt;code&gt;q&lt;/code&gt;：退出&lt;code&gt;top&lt;/code&gt;命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt;：按MITE+排行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;K&lt;/code&gt;: &lt;code&gt;kill&lt;/code&gt;进程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结束进程: &lt;code&gt;kill&lt;/code&gt;&lt;br&gt;
直接&lt;code&gt;kill pid&lt;/code&gt;可以杀死进程 加&lt;code&gt;-9&lt;/code&gt;是彻底杀死&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kill&lt;/code&gt; 本质上是将指定的信息送至程序。预设的信息为 &lt;code&gt;SIGTERM(15)&lt;/code&gt;，可将指定程序终止。&lt;br&gt;
若仍无法终止该程序，可使用&lt;code&gt; SIGKILL(9)&lt;/code&gt; 信息尝试强制删除程序。&lt;/p&gt;
&lt;p&gt;程序或工作的编号可利用 &lt;code&gt;ps&lt;/code&gt; 指令或 &lt;code&gt;jobs&lt;/code&gt; 指令查看。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-1&lt;/code&gt; (HUP)：重新加载进程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-9&lt;/code&gt; (KILL)：杀死一个进程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-15&lt;/code&gt; (TERM)：正常停止一个进程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l &amp;lt;信息编号&amp;gt;&lt;/code&gt; 若不加&amp;lt;信息编号&amp;gt;选项，则 -l 参数会列出全部的信息名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s &amp;lt;信息名称或编号&amp;gt;&lt;/code&gt; 指定要送出的信息。 &lt;code&gt;ps -s 9 pid&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;性能监控&#34;&gt;性能监控&lt;/h2&gt;
&lt;p&gt;查看CPU使用率: &lt;code&gt;sar -u n m&lt;/code&gt; （&lt;code&gt;n&lt;/code&gt; 为监控频率、&lt;code&gt;m&lt;/code&gt;为监控次数）&lt;br&gt;
查看内存使用状况: &lt;code&gt;sar -r n m&lt;/code&gt;&lt;br&gt;
当系统中&lt;code&gt;sar&lt;/code&gt;不可用时，可以使用以下工具替代: &lt;code&gt;vmstat&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;网络工具&#34;&gt;网络工具&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ifconfig&lt;/code&gt;查看ip&lt;/p&gt;
&lt;p&gt;&lt;code&gt;netstat&lt;/code&gt; 命令用于显示网络状态。利用 &lt;code&gt;netstat&lt;/code&gt; 指令可让你得知整个 Linux 系统的网络情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-a&lt;/code&gt;或&lt;code&gt;--all&lt;/code&gt; 显示所有连线中的Socket。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt;或&lt;code&gt;--continuous&lt;/code&gt; 持续列出网络状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt;或&lt;code&gt;--extend&lt;/code&gt; 显示网络其他相关信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt;或&lt;code&gt;--programs&lt;/code&gt; 显示正在使用Socket的程序识别码和程序名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt;或&lt;code&gt;--route&lt;/code&gt; 显示Routing Table。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t&lt;/code&gt;或&lt;code&gt;--tcp&lt;/code&gt; 显示TCP传输协议的连线状况。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-u&lt;/code&gt;或&lt;code&gt;--udp&lt;/code&gt; 显示UDP传输协议的连线状况。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l&lt;/code&gt;或&lt;code&gt;--listening&lt;/code&gt; 显示监控中的服务器的Socket。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt;或&lt;code&gt;--numeric&lt;/code&gt; 直接使用IP地址，而不通过域名服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;列出所有 tcp 端口: &lt;code&gt;netstat -at&lt;/code&gt;&lt;br&gt;
使用netstat工具查询端口: &lt;code&gt;netstat -antp | grep 6379&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1687924470119.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;查看路由状态: &lt;code&gt;route -n&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;探测前往地址IP的路由路径: &lt;code&gt;traceroute IP&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;DNS查询，寻找域名domain对应的IP: &lt;code&gt;host domain&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ssh登陆远程服务器host，ID为用户名: &lt;code&gt;ssh ID@host&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ftp/sftp文件传输: &lt;code&gt;sftp ID@host&lt;/code&gt;&lt;br&gt;
ftp登陆后，可以使用下面的命令进一步操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;get filename&lt;/code&gt; # 下载文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;put filename&lt;/code&gt; # 上传文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls&lt;/code&gt; # 列出host上当前路径的所有文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd&lt;/code&gt; # 在host上更改当前路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lls&lt;/code&gt; # 列出本地主机上当前路径的所有文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lcd&lt;/code&gt; # 在本地主机更改当前路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络复制:&lt;br&gt;
将本地localpath指向的文件上传到远程主机的path路径: &lt;code&gt;scp localpath ID@host:path&lt;/code&gt;&lt;br&gt;
以ssh协议，遍历下载path路径下的整个文件系统，到本地的localpath: &lt;code&gt;scp -r ID@site:path localpath&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;用户管理&#34;&gt;用户管理&lt;/h2&gt;
&lt;p&gt;添加用户: &lt;code&gt;useradd -m username&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;为用户添加/修改密码: &lt;code&gt;passwd username&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;删除用户: &lt;code&gt;userdel -r username&lt;/code&gt; #不带选项使用 userdel，只会删除用户。用户的home目录将仍会在/home目录下。要完全的删除用户信息，使用-r选项&lt;/p&gt;
&lt;p&gt;切换到用户B: &lt;code&gt;su userB&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看用户当前组: &lt;code&gt;groups&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;变更用户组:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;usermod -G groupNmame username 
# 一个用户可以属于多个组 -G是将用户加入到组, -g将用户加入到新的组，并从原有的组中除去
&lt;/code&gt;&lt;/pre&gt;
">[Linux] Bash基础命令使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/8JnsSdCk7/"" data-c="
          &lt;p&gt;通过&lt;code&gt;template &amp;lt;typename T, class C,…(模板参数列表)&amp;gt; &lt;/code&gt;来定义模板&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class&lt;/code&gt;关键字和 &lt;code&gt;typename&lt;/code&gt; 关键字没有任何区别&lt;br&gt;
只是后者从名字上来说更清晰 出现的更晚而已&lt;/p&gt;
&lt;p&gt;模板参数列表中除了定义类型参数 还可以定义非类型参数&lt;br&gt;
其中的非类型参数表示一个值而非一个类型&lt;/p&gt;
&lt;p&gt;而当一个模板被实例化时 非类型参数必须被一个用户提供的或是编译器推断的常量表达式替代&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 我们在模板参数列表中定义了两个非类型参数 其类型为无符号整数
// 用于指定比较的字符串长度
template&amp;lt;unsigned int N, unsigned int M&amp;gt;
int compare(const char (&amp;amp;p1)[N], const char (&amp;amp;p1)[M]){
    return strcmp(p1,p2);
}
// 我们调用这个版本的compare时 编译器根据字面常量的大小来推断N和M的值
// 注意 编译器会为字面常量的字符串末尾自动插入\0作为终止符
compare(&amp;quot;hi&amp;quot;,&amp;quot;hello&amp;quot;);
// 因此 编译器最终会为上面的调用实例化出下面的版本
int compare(const char (&amp;amp;p1)[3], const char (&amp;amp;p1)[6]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将函数模板声明为&lt;code&gt;inline&lt;/code&gt;或&lt;code&gt;constexpr&lt;/code&gt;时 其定义说明符跟在模板参数列表之后 返回类型之前&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Template&amp;lt;typename T&amp;gt; inline T min(cosnt T&amp;amp;, cosnt T&amp;amp;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大多数模板的错误在实例化期间才报告&lt;/p&gt;
&lt;p&gt;使用类模板时 必须通过显式模板实参列表来提供额外信息&lt;br&gt;
但在类自身内部的作用域中 可以直接使用模板名而不提供实参&lt;/p&gt;
&lt;p&gt;一个类模板的每个实例都生成一个独立的类 互相之间没有任何关系&lt;/p&gt;
&lt;p&gt;当一个类模板包含一个非模板友元 则该友元可以访问所有模板实例&lt;/p&gt;
&lt;p&gt;如果友元自身是模板 类可以授权给所有模板实例 也可以只授权给特定实例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Template&amp;lt;typename T&amp;gt; class C{
    Friend class pal&amp;lt;C&amp;gt;; //只有用类C实例化的类pal是C的友元
    Template &amp;lt;typename X&amp;gt; friend class pal2; 
    // 所有类pal的实例化都是C的友元 注意必须使用不同的模板参数
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种情况下可以用&lt;code&gt;typename&lt;/code&gt;关键字告诉编译器一个名字表示类型 但不能用&lt;code&gt;class&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;即使所有的模板参数都定义了默认实参 但定义时仍然必须有个&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Numbers&amp;lt;&amp;gt; a;
&lt;/code&gt;&lt;/pre&gt;
">[C++学习笔记] 模板和泛型编程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/oxOQXJroN/"" data-c="
          &lt;p&gt;面向对象编程(OOP) 核心思想在于 &lt;strong&gt;数据抽象&lt;/strong&gt; &lt;strong&gt;继承&lt;/strong&gt; 和 &lt;strong&gt;动态绑定&lt;/strong&gt;&lt;br&gt;
也叫 &lt;strong&gt;封装&lt;/strong&gt; &lt;strong&gt;继承&lt;/strong&gt; 和 &lt;strong&gt;多态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;strong&gt;数据抽象&lt;/strong&gt; 可以将类的接口和实现分离&lt;br&gt;
通过&lt;strong&gt;继承&lt;/strong&gt; 可以定义相似的类型并对其相似关系建模&lt;br&gt;
通过&lt;strong&gt;动态绑定&lt;/strong&gt; 可以一定程度上忽略相似类别的区别 以统一的方式使用它们的对象&lt;/p&gt;
&lt;h2 id=&#34;继承&#34;&gt;继承&lt;/h2&gt;
&lt;p&gt;继承中 一般基类负责定义所有类共有的成员 而每个派生类定义各自特有的成员&lt;/p&gt;
&lt;p&gt;通过使用&lt;code&gt;virtual&lt;/code&gt;关键字 可以定义虚函数 派生类必须对所有的虚函数进行声明&lt;br&gt;
所有的虚函数都必须有定义 因为编译器不知道是否会在动态绑定时使用&lt;/p&gt;
&lt;p&gt;一个函数在基类中被声明为虚函数 则在所有派生类中都为虚函数 无需再次声明&lt;code&gt;virtual&lt;/code&gt;关键字&lt;/p&gt;
&lt;p&gt;基类&lt;strong&gt;通常应该定义一个虚析构函数&lt;/strong&gt; 因为动态绑定可能会导致实际类型与指针类型不符&lt;br&gt;
定义了虚析构函数将会阻止编译器为其合成移动操作&lt;/p&gt;
&lt;p&gt;派生类必须通过类派生列表来明确指出从哪个(些)基类继承而来&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class b_quote : public Quote{
    public:
        b_quote() =default;
        b_quote(string &amp;amp;book,double p, double disc): Quote(book,p),discount(disc){ }
        double price() override;
    private:
        double discount;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过&lt;code&gt;override&lt;/code&gt;关键字显式地注明使用哪个成员函数改写基类的虚函数 以防止形参列表不一致而导致未覆盖虚函数而重新定义了一个新函数的错误&lt;/p&gt;
&lt;p&gt;&lt;code&gt;protected&lt;/code&gt; 访问运算符 表示该成员只能被类本身,友元和派生类访问&lt;/p&gt;
&lt;p&gt;如果要被继承 那么基类必须先被定义而不仅仅是声明&lt;/p&gt;
&lt;p&gt;派生类和其他创建基类的方法一样 必须通过基类的构造函数来初始化它的基类部分&lt;br&gt;
初始化顺序是 先初始化基类成员 再按定义顺序初始化派生类内的成员&lt;/p&gt;
&lt;p&gt;静态成员无论继承多少次 仍只有一个&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;final&lt;/code&gt;关键字 可以禁止该类被继承 但该类本身仍可以继承别的基类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class base final: public Quote{ };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以通过&lt;code&gt;final&lt;/code&gt;关键字修饰函数 使得该函数不可以被继承类覆盖&lt;/p&gt;
&lt;p&gt;友元关系不可被继承&lt;/p&gt;
&lt;p&gt;派生类的派生列表中的访问说明符并不影响其是否能访问直接基类的成员(只与基类中的访问权限有关)&lt;br&gt;
其&lt;strong&gt;作用是控制派生类用户(包括派生类的派生类)对于基类成员的访问权限&lt;/strong&gt; 即表示派生类从基类继承过来的成员的访问权限&lt;br&gt;
公有继承 则遵循原有访问说明符 私有和保护继承则是改为对应说明符权限&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class base{
    public:
        int a;
        protected: 
        int b;
};

class b1: public base{}; //b1中 a为public成员 b为protected成员
class b2: private base{}; //b2中 a和b为private成员
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过在类的内部使用using语句可以改变成员的访问权限&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class b3: private base{ 
    public:
        using base:: a;
    protected:
        using base:: b;
}; // a变为了public成员 b变为了Protected成员
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认情况下使用&lt;code&gt;class&lt;/code&gt;定义的派生类是私有继承 使用&lt;code&gt;struct&lt;/code&gt;定义的是公有继承&lt;/p&gt;
&lt;p&gt;派生类的作用域位于基类的作用域之内 即先在派生类中解析 无法完成的情况下再向外层基类作用域中寻找解析&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;using&lt;/code&gt;语句 可以在派生类内部继承基类的每个构造函数&lt;br&gt;
对于基类的每个构造函数 编译器都在派生类中生成一个形参列表完全相同的派生类的构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;using Quote:: Quote; // 对应就会有 b_quote(args): Quote(args) { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用这些构造函数时 如果派生类含有自己特有的数据成员 这些成员将被默认初始化&lt;/p&gt;
&lt;p&gt;使用容器存放继承体系中的对象时 应该通过指针进行间接储存&lt;br&gt;
否则会因为类型转化而导致报错(基类向派生类转化)或者信息丢失(派生类向基类的转换)&lt;/p&gt;
&lt;h2 id=&#34;动态绑定&#34;&gt;动态绑定&lt;/h2&gt;
&lt;p&gt;C++中无法直接使用对象进行面向对象编程 反而得使用指针和引用来间接操控&lt;br&gt;
基类通过声明虚函数来使得该函数执行动态绑定&lt;br&gt;
动态绑定可以根据传入的参数 在运行时选择调用的类成员&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;double print(const Quote &amp;amp; item) {
    cout&amp;lt;&amp;lt;item.price();
}
b_quote a;
Quote b;
print(a);
print(b);
// 运行时传入 b_quote和Quote对象都可以 并且会自动选择对应版本函数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果调用虚函数时使用了默认实参 则使用的是本次调用的静态类型的默认实参&lt;br&gt;
如通过基类对象引用调用函数 实际传入的为派生类对象 那么使用的是基类的默认实参 尽管调用的是派生类的函数&lt;/p&gt;
&lt;p&gt;可以通过作用域运算符强迫执行指定的虚函数版本 而不是动态绑定&lt;br&gt;
一般用于某个派生类中的虚函数调用被它覆盖的虚函数时 因为否则将调用自身无限递归&lt;/p&gt;
&lt;p&gt;即使动态绑定了 我们仍旧只能调用其静态类型的对象所包含的成员&lt;br&gt;
如我们将基类引用绑定到派生类对象上 我们不能调用那些在派生类中新添加的成员&lt;/p&gt;
&lt;p&gt;派生类中都包含它的基类部分 因此 派生类可以隐式转换为基类&lt;br&gt;
但基类不能隐式转换为派生类&lt;br&gt;
注意 &lt;strong&gt;派生类向基类的隐式转换只对指针和引用有效&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于代码中给定的部分而言 如果此时基类的公有成员是可访问的 则派生类向基类的转换也是可访问的 反之则不行&lt;/p&gt;
&lt;p&gt;我们可以使用派生类对象为基类对象初始化或赋值&lt;br&gt;
这是因为本质上我们调用的构造函数或者拷贝函数接受引用输入 因此可以隐式转换&lt;/p&gt;
&lt;p&gt;使用派生类对象为基类对象初始化或赋值时 只有该派生类中的基类部分会被拷贝、移动或赋值 它的派生类部分会被忽略&lt;/p&gt;
&lt;p&gt;我们将具有继承关系的多种类型称为多态类型, 因为我们可以使用这些类型的&amp;quot;多种形式&amp;quot;而无需在意它们之间的差异&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用或指针的静态类型和动态类型不一致(即动态绑定)是C++支持多态性的根本所在&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;封装&#34;&gt;封装&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;通过在声明函数本来函数体的位置书写 = 0 就可以将一个虚函数声明为纯虚函数&lt;/strong&gt; 这种方式仅能出现在类的内部声明虚函数时&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;double price(int) = 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类&lt;/strong&gt; 负责定义接口 也不能创建抽象基类的对象&lt;br&gt;
&lt;strong&gt;定义纯虚函数的真正目的是为了定义抽象类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;纯虚函数&lt;strong&gt;通常没有定义体，但也完全可以拥有, 甚至可以显示调用&lt;/strong&gt;。&lt;/p&gt;
">[C++学习笔记] 面向对象程序设计 OOP</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/7wNgt7IgP/"" data-c="
          &lt;h2 id=&#34;重载运算符&#34;&gt;重载运算符&lt;/h2&gt;
&lt;p&gt;重载的运算符是具有特殊名字的函数 它们的名字由关键字&lt;code&gt;operator&lt;/code&gt;和要定义的运算符号共同组成&lt;/p&gt;
&lt;p&gt;重载运算符的参数数量与该运算符作用的运算对象数量一样多&lt;br&gt;
重载运算符作为成员函数时 其左侧运算对象被隐式地绑定到当前调用它的对象上 显式的形参减少一个&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不能重新定义内置类型对象的运算符&lt;/strong&gt;&lt;br&gt;
因此重载运算符要么是类的成员函数 要么至少有一个类类型的参数&lt;/p&gt;
&lt;p&gt;也不能定义新的运算符 而&lt;strong&gt;只能重载已有的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有&lt;strong&gt;部分运算符不能被重载: &lt;code&gt;::&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;?:&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常情况下 也不应该重载 &lt;strong&gt;逗号&lt;/strong&gt; &lt;strong&gt;取地址&lt;/strong&gt; &lt;strong&gt;逻辑与&lt;/strong&gt; &lt;strong&gt;逻辑或&lt;/strong&gt;运算符&lt;br&gt;
因为它们有着内置的求值顺序或含义&lt;/p&gt;
&lt;p&gt;可以通过运算符号间接调用运算符函数 也可以像任何其他函数一样显式调用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;data1 + data2; 
operator+ (data1, data2); 
data1.operator+=(data2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有&lt;strong&gt;部分运算符必须是成员函数:  &lt;code&gt;=&lt;/code&gt; &lt;code&gt;[]&lt;/code&gt; &lt;code&gt;()&lt;/code&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; 以及 类型转换运算符 &lt;code&gt;operator type( ) const;&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
类型转换运算符不能声明返回类型(默认为定义的type) 形参列表也必须为空&lt;/p&gt;
&lt;p&gt;由于向&lt;code&gt;bool&lt;/code&gt;类型的转换通常用在条件部分 因此&lt;code&gt;operator bool()&lt;/code&gt;一般定义为&lt;code&gt;explicit&lt;/code&gt;(其他情况不能隐式调用)&lt;/p&gt;
&lt;p&gt;改变对象状态的运算符如&lt;code&gt;++&lt;/code&gt;,&lt;code&gt;--&lt;/code&gt;,解引用以及复合赋值运算符(如&lt;code&gt;+=&lt;/code&gt;,&lt;code&gt;-=&lt;/code&gt;,&lt;code&gt;/=&lt;/code&gt;等等)一般来说是成员函数&lt;/p&gt;
&lt;h3 id=&#34;输入输出运算符&#34;&gt;输入输出运算符&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;输入输出运算符必须是非成员函数&lt;/strong&gt; 并且通常为类的友元函数(为了打印非公有成员)&lt;/p&gt;
&lt;p&gt;**具有对称性的运算符(如算术和关系运算符)**一般不设置为非成员的普通函数&lt;br&gt;
因为具有对称性的运算符可能转换任意一端的运算对象 例如&lt;code&gt;int + double&lt;/code&gt; 和&lt;code&gt;double + int&lt;/code&gt; 都应该是成立的&lt;/p&gt;
&lt;p&gt;输出运算符&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 的第一个形参是一个要写入的非常量的&lt;code&gt;ostream&lt;/code&gt;对象的引用&lt;br&gt;
非常量是因为我们要写入 而引用则是因为无法复制一个流对象&lt;/p&gt;
&lt;p&gt;第二个形参一般是一个我们希望打印的对象类型的常量引用 返回值为传入的&lt;code&gt;ostream&lt;/code&gt;形参&lt;br&gt;
函数体内使用传入的形参完成输出后返回&lt;/p&gt;
&lt;p&gt;输入运算符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;与输出运算符类似 第一个形参为要读取的流的引用 第二个形参为要写入对象类型的非常量引用&lt;br&gt;
返回值为流引用&lt;/p&gt;
&lt;p&gt;注意 输入运算符必须处理可能失败的情况 而输出不需要 当读取操作发生错误时 输入运算符应该负责从错误中恢复(如 重置为空)&lt;/p&gt;
&lt;h3 id=&#34;赋值运算符&#34;&gt;赋值运算符&lt;/h3&gt;
&lt;p&gt;如果类同时定义了算术运算符和对应的复合赋值运算符 通常应该使用对应复合赋值运算符来实现算术运算符&lt;br&gt;
因为&lt;code&gt;operator+&lt;/code&gt;需要创建计算结果的新对象 &lt;code&gt;operator+=&lt;/code&gt;只使用一个对象。&lt;br&gt;
调用&lt;code&gt;operator+=&lt;/code&gt;作为用户重载的运算符，更简洁，更符合实际逻辑。&lt;/p&gt;
&lt;p&gt;除了&lt;strong&gt;拷贝赋值&lt;/strong&gt;和&lt;strong&gt;移动赋值运算符&lt;/strong&gt;外 还有&lt;strong&gt;列表初始化赋值运算符&lt;/strong&gt;(这三者事实上是同名不同参的重载运算符)&lt;/p&gt;
&lt;p&gt;列表初始化赋值运算符:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;strvec&amp;amp; operator=(std::initializer_list&amp;lt;std::string&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下标运算符通常以所访问的元素的引用作为返回值&lt;br&gt;
出于安全考虑 最好同时定义下标运算符的常量版本和非常量版本&lt;br&gt;
在常量版本中保证对常量对象的访问返回的是常量引用 以确保不会为常量赋值&lt;/p&gt;
&lt;h3 id=&#34;自增自减运算符&#34;&gt;自增自减运算符&lt;/h3&gt;
&lt;p&gt;定义递增和递减运算符时应该同时定义&lt;strong&gt;前置版本&lt;/strong&gt;和&lt;strong&gt;后置版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了区分前置版本和后置版本 &lt;strong&gt;后置版本接受一个额外的不被使用的int类型的形参&lt;/strong&gt;&lt;br&gt;
其唯一作用就是为了区分 由于不会使用该形参 甚至不需要为其命名&lt;/p&gt;
&lt;p&gt;所以当显式调用后置版本运算符时 必须传入一个任意整数参数来区分使用版本 这个参数本身不被使用&lt;/p&gt;
&lt;p&gt;前置版本需要检查越界问题 后置版本直接调用前置版本并返回原值即可&lt;/p&gt;
&lt;h3 id=&#34;箭头运算符&#34;&gt;箭头运算符&lt;/h3&gt;
&lt;p&gt;重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象&lt;br&gt;
&lt;strong&gt;使用箭头运算符时将会重复调用结果的箭头运算符直至最后为内置箭头运算符结果或类的指针&lt;/strong&gt;&lt;br&gt;
运算符 &lt;code&gt;-&amp;gt;&lt;/code&gt; 的重载比较特别，它只能是非静态的成员函数形式，而且没有参数。&lt;/p&gt;
&lt;p&gt;如果返回值是一个原始指针，那么就将运算符的右操作数当作这个原始指针所指向类型的成员进行访问；&lt;/p&gt;
&lt;p&gt;如果返回值是另一个类型的实例，那么就继续调用这个返回类型的 &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; ，直到有一个调用返回一个原始指针为止，然后按第一种情况处理。&lt;/p&gt;
&lt;p&gt;如果上述条件不满足（如：右操作数不是返回的原始指针指向的类型的成员，或者，返回的非指针类型没有重载 &lt;code&gt;operator-&amp;gt;()&lt;/code&gt;），那么编译将报错。&lt;/p&gt;
&lt;h2 id=&#34;函数对象模板&#34;&gt;函数对象模板&lt;/h2&gt;
&lt;p&gt;如果类重载了调用运算符&lt;code&gt;()&lt;/code&gt; 则我们可以像使用函数一样使用该类的对象&lt;br&gt;
我们将这种定义了调用运算符的类的对象称之为 &lt;strong&gt;函数对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数对象常常作为泛型算法的实参 lambda是一种函数对象&lt;br&gt;
通过值捕获的变量将被保存到类内的数据成员中(通过合成构造函数初始化)&lt;br&gt;
而引用捕获的则不会&lt;/p&gt;
&lt;p&gt;标准库定义了一组对应&lt;strong&gt;算术&lt;/strong&gt; &lt;strong&gt;关系&lt;/strong&gt; &lt;strong&gt;和逻辑运算符&lt;/strong&gt;的函数对象模板类 可用于构造对应类型的函数对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Plus&amp;lt;int&amp;gt; intAdd; 
int sum = intAdd(10, 20); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们自定义的比较中形参是没有相关性的 因此可能会产生错误 而使用标准库定义的则不会&lt;br&gt;
例如比较指针地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;string *&amp;gt; table;
// 错误：table中的指针彼此之间没有关系，将产生未定义的行为
sort(table.begin(),table.begin(),[](string *a, string *b){return a&amp;lt;b;});
// 正确：标准库中的less对指针的定义是良好的
sort(table.begin(),table.begin(),less&amp;lt;string *&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;function&amp;lt;T&amp;gt;&lt;/code&gt;模板可以使多个函数共享一个调用形式&lt;br&gt;
例如多种整数运算都是&lt;code&gt;int(int,int)&lt;/code&gt;形式&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1687856395763.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;二义性问题&#34;&gt;二义性问题&lt;/h2&gt;
&lt;p&gt;如果我们对同一个类既提供了转换目标是算术类型的类型转换 也提供了重载的运算符 则会遇到重载运算符与内置运算符的二义性问题&lt;/p&gt;
&lt;p&gt;例如：对&lt;code&gt;a&lt;/code&gt;类定义了转换到int的类型转换 又定义了与&lt;code&gt;int&lt;/code&gt;的加法重载符 则使用&lt;code&gt;a&lt;/code&gt;类对象与&lt;code&gt;int&lt;/code&gt;相加时会产生二义性&lt;br&gt;
无法判断是进行类型转换在使用&lt;code&gt;int&lt;/code&gt;加法  还是使用重载的加法&lt;/p&gt;
">[C++学习笔记] 运算符重载与类型转换</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/MvD0C2wyC/"" data-c="
          &lt;p&gt;&lt;strong&gt;拷贝控制&lt;/strong&gt;操作包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;拷贝构造函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拷贝赋值运算符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;移动构造函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;移动赋值运算符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;析构函数&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;1 3&lt;/strong&gt; 定义了使用同类型的对象初始化本对象时的操作&lt;br&gt;
&lt;strong&gt;2 4&lt;/strong&gt; 定义了将同类型的对象赋予给本对象时的操作&lt;br&gt;
&lt;strong&gt;5&lt;/strong&gt; 定义了销毁该类型对象时的操作&lt;/p&gt;
&lt;h2 id=&#34;拷贝构造&#34;&gt;拷贝构造&lt;/h2&gt;
&lt;p&gt;拷贝构造函数:&lt;br&gt;
第一个参数为自身类型的引用(而且基本上都是&lt;code&gt;const&lt;/code&gt; 引用)&lt;br&gt;
并且&lt;strong&gt;其他参数(如果有的话)都有默认值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般而言 拷贝构造函数常常会被隐式调用 因此不会定义为&lt;code&gt;explicit&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;与合成默认构造函数不同 &lt;strong&gt;即使我们定义了其他构造函数 编译器也会合成一个拷贝构造函数&lt;/strong&gt;&lt;br&gt;
合成拷贝构造函数会&lt;strong&gt;将其参数的非static成员逐个拷贝到正在创建的对象中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用直接初始化时 编译器使用普通的函数匹配来选择与提供参数最匹配的构造函数&lt;br&gt;
而使用拷贝初始化时 编译器将右侧运算对象拷贝到正在创建的对象中 如果需要的话 会进行类型转换&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;string s(&amp;quot;1123&amp;quot;); 
string s2(s); //都是直接初始化
string s3=s; 
string s4=&amp;quot;11&amp;quot;; //都是拷贝初始化
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了使用&lt;code&gt;=&lt;/code&gt;定义变量时显式调用拷贝初始化 在隐式的类型转换时也会进行:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将一个对象作为实参传递给一个非引用的形参&lt;/li&gt;
&lt;li&gt;作为函数返回值返回一个对象&lt;/li&gt;
&lt;li&gt;用花括号列表初始化一个数组中的元素或者一个聚合类的成员&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外 使用标准库容器时 调用&lt;code&gt;insert&lt;/code&gt;和&lt;code&gt;push&lt;/code&gt;会调用拷贝初始化&lt;br&gt;
而使用&lt;code&gt;emplace&lt;/code&gt;会进行直接初始化&lt;/p&gt;
&lt;p&gt;拷贝构造函数被用来初始化非引用类型参数 因此&lt;strong&gt;拷贝构造函数自身参数必须是引用&lt;/strong&gt; 不然就会无限循环调用自己了&lt;/p&gt;
&lt;p&gt;重载运算符本质上是函数 由&lt;code&gt;operator&lt;/code&gt;关键字后接表示要定义的运算符的符号组成&lt;br&gt;
类似其他函数 重载运算符也有返回类型和参数&lt;br&gt;
例如拷贝赋值运算符是一个名为&lt;code&gt;operator=&lt;/code&gt;的函数，它接受与类相同类型的参数&lt;/p&gt;
&lt;p&gt;重载运算符的参数表示运算对象 某些运算符(如赋值运算符)必须定义为成员函数&lt;br&gt;
若重载运算符是一个成员函数 那么其左侧运算对象默认绑定到隐式的&lt;code&gt;this&lt;/code&gt;对象上&lt;/p&gt;
&lt;p&gt;赋值运算符通常应该返回一个指向其左侧运算对象的引用&lt;/p&gt;
&lt;h2 id=&#34;析构函数&#34;&gt;析构函数&lt;/h2&gt;
&lt;p&gt;析构函数负责释放对象使用的资源 并销毁对象的非static成员&lt;br&gt;
析构函数没有返回值 也不接受参数 以~关键字开头 如&lt;code&gt; ~Foo(){ }&lt;/code&gt;&lt;br&gt;
由于没有参数 析构函数也不能被重载 对一个类型而言 析构函数是唯一的&lt;/p&gt;
&lt;p&gt;构造函数中成员初始化是在函数体执行之前的 且初始化顺序与它们在类中出现的顺序一致&lt;br&gt;
而析构函数中 函数体执行之后才销毁成员 销毁顺序是初始化的逆顺序&lt;/p&gt;
&lt;p&gt;但不同于初始化时可以利用初始化列表来控制如何初始化&lt;br&gt;
析构函数中析构部分是隐式的 自动完成&lt;br&gt;
析构函数体并不需要承担销毁成员的责任 销毁成员是在函数体结束后隐式自动完成的&lt;/p&gt;
&lt;p&gt;但注意 销毁一个内置指针类型的成员 不会&lt;code&gt;delete&lt;/code&gt;它所指向的对象&lt;br&gt;
而智能指针是类类型 会自动销毁其成员&lt;/p&gt;
&lt;p&gt;析构函数会在对象被销毁时(如离开作用域)自动调用&lt;/p&gt;
&lt;p&gt;一般而言 拷贝运算符和拷贝构造函数以及析构函数 三者是需要一块定义的&lt;br&gt;
因为往往定义析构函数是为了释放指针的指向内存&lt;br&gt;
然而未定义拷贝构造函数和运算符的话 默认的合成拷贝构造函数和运算符 会直接简单拷贝指针成员 这就导致多个对象中的成员指向相同的内存&lt;br&gt;
当析构函数delete时会多次删除同一块内存 引发未知错误&lt;/p&gt;
&lt;p&gt;对于具有默认合成版本的成员函数 可以使用&lt;code&gt;=default&lt;/code&gt;来显式要求使用编译器合成的版本&lt;/p&gt;
&lt;p&gt;某些时候 需要阻止拷贝构造和拷贝赋值(如IO类型禁止拷贝以免多个对象读取或写入相同流)&lt;br&gt;
我们需要定义一个对应的拷贝构造和拷贝赋值函数来阻止&lt;br&gt;
因为不定义的话会自动生成合成版本  可以通过将这些函数定义为&lt;strong&gt;删除函数&lt;/strong&gt;(新标准)或者将这些函数定义为&lt;strong&gt;私有函数&lt;/strong&gt;(旧标准方法) 来阻止&lt;/p&gt;
&lt;p&gt;删除函数: 在函数的参数列表后加上&lt;code&gt;=delete&lt;/code&gt;定义 意味着虽然声明了该函数 但不能使用它们&lt;br&gt;
&lt;code&gt;=delete&lt;/code&gt;必须出现在函数第一次声明时&lt;br&gt;
但不应该将析构函数定义为删除函数 因为这样就无法销毁该类型对象了&lt;/p&gt;
&lt;p&gt;对于删除了析构函数的类型 不能定义这种类型的变量或者成员 但仍可以动态分配这种类型的对象 但是不能释放这些对象&lt;/p&gt;
&lt;p&gt;如果类中某个成员的析构函数被删除 则该类的析构函数也被定义为删除的&lt;br&gt;
如果类中某个成员的析构函数或拷贝构造函数被删除 则该类的拷贝构造函数也被定义为删除的&lt;/p&gt;
&lt;p&gt;定义了一个移动构造或移动赋值的类必须也定义自己的拷贝操作 否则这些成员默认被定义为删除的&lt;/p&gt;
&lt;p&gt;类似析构函数 赋值操作会销毁左侧运算对象的资源&lt;br&gt;
类似拷贝构造 赋值操作会从右侧对象拷贝数据&lt;br&gt;
为了保证安全(如自赋值) 应该&lt;strong&gt;先拷贝右侧对象 再释放左值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过自己定义动态内存的引用计数来共享类的状态 从而模拟&lt;code&gt;shared_ptr&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Size_t *use(new size_t(1)); //构造时进行初始化 
++*use; // 每次拷贝时增加计数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;析构时检测&lt;code&gt;--*use==0&lt;/code&gt;来决定是否&lt;code&gt;delete&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;移动操作&#34;&gt;移动操作&lt;/h2&gt;
&lt;p&gt;定义&lt;code&gt;swap&lt;/code&gt;运算 应当交换指针而非拷贝内容 可以提高效率&lt;br&gt;
定义了&lt;code&gt;swap&lt;/code&gt;运算的类应当使用&lt;code&gt;swap&lt;/code&gt;来完成赋值运算符 更加安全 并能处理自赋值&lt;/p&gt;
&lt;p&gt;移动操作获取了对象资源的控制权，从而&lt;strong&gt;避免了不必要的拷贝&lt;/strong&gt;。&lt;br&gt;
使用移动构造函数时&lt;br&gt;
一方面可以避免拷贝后立刻销毁这样的情况 提高性能&lt;br&gt;
另一方面 对于IO类或者是&lt;code&gt;unique_ptr&lt;/code&gt;这种类型 包含不能被共享的资源 它们不允许被拷贝 但是应当允许移动&lt;/p&gt;
&lt;p&gt;为了支持移动操作 必须使用&lt;strong&gt;右值引用&lt;/strong&gt;,即必须绑定到右值的引用,通过&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;获得&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;移动后源对象必须保证是有效的 可析构的状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;右值引用只能绑定到一个&lt;strong&gt;将要销毁&lt;/strong&gt;的对象&lt;br&gt;
左值引用只能绑定左值 即绑定的是对象的身份 但 &lt;code&gt;const&lt;/code&gt; 左值引用可以绑定右值&lt;br&gt;
而右值引用只能绑定到右值 即绑定是对象的值&lt;/p&gt;
&lt;p&gt;因此我们不能将一个右值引用变量绑定到另一个变量上 即使这个变量也是右值引用类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int &amp;amp;&amp;amp;rr1 = 42; 
int &amp;amp;&amp;amp;rr2 = rr1; //错误 不能将一个右值引用变量绑定到另一个变量上
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;左值持久 而右值短暂&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int i = 42;
int &amp;amp;r = i; // 正确：r 引用 i
int &amp;amp;&amp;amp;rr = i; // 错误：不能将一个右值引用绑定到一个左值上
int &amp;amp;r2 = i * 42; // 错误：i*42是一个右值
const int &amp;amp;r3 = i * 42; // 正确： 可以将const引用绑定到一个右值上
int &amp;amp;&amp;amp;rr2 = i * 42; //正确：将右值引用绑定到了乘法结果上，这是一个临时变量，为右值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过标准库的&lt;code&gt;move&lt;/code&gt;函数可以获得左值的右值引用&lt;br&gt;
调用move意味着告诉编译器 这个左值将不再使用其值 可以销毁它 也可以赋予新值 但不能使用其值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int &amp;amp;&amp;amp;rr2=std::move(i); //成立 move返回左值i的右值引用
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意 使用&lt;code&gt;move&lt;/code&gt;的代码应该调用&lt;code&gt;std::move&lt;/code&gt;以避免潜在的名字冲突&lt;/p&gt;
&lt;p&gt;类似拷贝构造 移动构造函数的第一个参数是该类型的右值引用 其他额外参数必须都有默认值&lt;br&gt;
特别地 移动构造函数必须保证移动完成后源对象必须不再指向被移动的资源 从而保证销毁它是无害的&lt;/p&gt;
&lt;p&gt;移动构造函数不分配任何新内存 它接管给定的对象的内存 然后将其中的指针都置为空 最后将其销毁&lt;/p&gt;
&lt;p&gt;移动构造函数通常不应该抛出任何异常 可以通过跟在形参列表后面的&lt;code&gt;noexpect&lt;/code&gt;关键字通知编译器&lt;br&gt;
在一个构造函数中&lt;code&gt;noexpect&lt;/code&gt;出现在参数列表和初始化列表开始前的冒号之间(即冒号之前)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 移动构造函数不应抛出任何异常
// 在成员初始化中接管s中的资源
strvec:: strvec(strvec &amp;amp;&amp;amp;s) noexcept:element(s.element),cap(s.cap){
    // 令s处于可析构的状态
    s.element = s.cap = nullptr;
}
    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为编译器对可能抛出异常的类会做一些额外的工作 声明为&lt;code&gt;noexpect&lt;/code&gt;可以避免浪费&lt;br&gt;
将函数声明为&lt;code&gt;noexpect&lt;/code&gt;还有一个作用 因为移动一个对象可能会改变它的值&lt;br&gt;
如果在移动了部分元素时抛出异常 则可能导致旧空间的移动源元素已经改变而新空间中尚未构造&lt;/p&gt;
&lt;p&gt;为了避免这种情况 如vector等知道该元素类型的移动构造函数不会抛出异常&lt;br&gt;
否则在重新分配内存的时候 它都必须使用拷贝构造而非移动构造&lt;/p&gt;
&lt;p&gt;如果一个类没有定义移动操作 那么使用时会&lt;strong&gt;使用拷贝操作来代替&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只有当一个类没有定义任何自己版本的拷贝控制成员 且类中的每个非static成员都可以移动&lt;br&gt;
编译器才会为其合成一个移动构造函数或移动赋值运算符&lt;/p&gt;
&lt;p&gt;移动迭代器: 通过改变给定迭代器的解引用运算符行为来适配&lt;br&gt;
移动迭代器的解引用返回一个右值引用&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;make_move_iterator()&lt;/code&gt;将一个普通迭代器转换为移动迭代器&lt;br&gt;
通常而言 调用成员函数不限制是左值还是右值调用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;string s1=&amp;quot;1&amp;quot;,s2=&amp;quot;2&amp;quot;; 
(s1+s2).find(&#39;1&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过引用限定符&lt;code&gt;&amp;amp;&lt;/code&gt; 和&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;可以限制成员函数只能被左值或者右值对象调用&lt;br&gt;
引用限定符跟在&lt;code&gt;const&lt;/code&gt;限定符后&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;Foo someMem() const &amp;amp;; //正确 定义了一个只能被左值const对象调用的成员函数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当通过引用限定符进行重载时 &lt;strong&gt;必须对所有重名且具有相同形参列表的函数(即只有引用限定不同的重载函数)都声明其引用限定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而当通过&lt;code&gt;const&lt;/code&gt;限定符进行重载时 &lt;strong&gt;仅有&lt;code&gt;const&lt;/code&gt;限定不同的重名函数可以不加限定&lt;/strong&gt;&lt;/p&gt;
">[C++学习笔记] 拷贝控制</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/ilgstVH0h/"" data-c="
          &lt;h2 id=&#34;1-启程&#34;&gt;1. 启程&lt;/h2&gt;
&lt;p&gt;JSON 只包含 6 种数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;null: 表示为 null&lt;/li&gt;
&lt;li&gt;boolean: 表示为 true 或 false&lt;/li&gt;
&lt;li&gt;number: 一般的浮点数表示方式&lt;/li&gt;
&lt;li&gt;string: 表示为 &amp;quot;...&amp;quot;&lt;/li&gt;
&lt;li&gt;array: 表示为 [ ... ]&lt;/li&gt;
&lt;li&gt;object: 表示为 { ... }&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;宏的编写技巧：反斜线代表该行未结束，会串接下一行。而如果宏里有多过一个语句（statement），就需要用 do { /&lt;em&gt;...&lt;/em&gt;/ } while(0) 包裹成单个语句 否则预处理之后会出错 容易超出作用域&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;__FILE__&lt;/code&gt;和&lt;code&gt;__LINE__&lt;/code&gt;可以打印语句所在文件 和 所处位置&lt;/p&gt;
&lt;p&gt;通过预编译命令&lt;code&gt;#define&lt;/code&gt;将其插入到使用位置 则可以实现打印具体错误位置的功能&lt;/p&gt;
&lt;p&gt;测试驱动开发（test-driven development, TDD），它的主要循环步骤是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加入一个测试。&lt;/li&gt;
&lt;li&gt;运行所有测试，新的测试应该会失败。&lt;/li&gt;
&lt;li&gt;编写实现代码。&lt;/li&gt;
&lt;li&gt;运行所有测试，若有测试失败回到3。&lt;/li&gt;
&lt;li&gt;重构代码。&lt;/li&gt;
&lt;li&gt;回到 1。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;断言的使用&lt;/strong&gt;： 如果那个错误是由于程序员错误编码所造成的（例如传入不合法的参数），那么应用断言；如果那个错误是程序员无法避免，而是由运行时的环境所造成的，就要处理运行时错误（例如开启文件失败）。&lt;/p&gt;
&lt;h2 id=&#34;2-解析数字&#34;&gt;2. 解析数字&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;重构&lt;/strong&gt;：在不改变代码外在行为的情况下，对代码作出修改，以改进程序的内部结构。&lt;/p&gt;
&lt;p&gt;通过内置的库函数 &lt;code&gt;strtod()&lt;/code&gt;可以将字符串转换为浮点数 当值溢出时 返回定义在&lt;code&gt;math.h&lt;/code&gt;头文件中的&lt;code&gt;HUGE_VAL&lt;/code&gt;或&lt;code&gt;-HUGE_VAL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;C 的注释不支持嵌套（nested），而 &lt;code&gt;#if ... #endif&lt;/code&gt; 是支持嵌套的。代码中已有注释时，用 &lt;code&gt;#if 0 ... #endif&lt;/code&gt; 去禁用代码是一个常用技巧，而且可以把 0 改为 1 去恢复。&lt;/p&gt;
&lt;p&gt;科学计数法的指数部分没有对前导零作限制 1E012 也是合法的&lt;/p&gt;
&lt;p&gt;整数不容许前导零（leading zero），是因为更久的 JavaScript 版本容许以前导零来表示八进位数字，如 052 == 42，这种八进位常数表示方式来自于 C 语言。&lt;br&gt;
&lt;strong&gt;禁止前导零避免了可能出现的歧义&lt;/strong&gt;。但是在指数里就不会出现这个问题。&lt;/p&gt;
&lt;h2 id=&#34;3-解析字符串&#34;&gt;3. 解析字符串&lt;/h2&gt;
&lt;p&gt;JSON中也是通过双引号来界定字符串的 通过转义字符&lt;code&gt;\&amp;quot;&lt;/code&gt;可以在字符串中出现双引号&lt;/p&gt;
&lt;p&gt;一个值不可能同时为数字和字符串，因此我们可使用 C 语言的 &lt;code&gt;union&lt;/code&gt; 来节省内存&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688474561411.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;realloc&lt;/code&gt;的方式确实能够改变原数组的尺寸。给用户的感受，就好像我的数组根据要求扩大或缩小了一样。&lt;/p&gt;
&lt;p&gt;然而，底层实现可以知道，我们要分情况讨论：&lt;/p&gt;
&lt;p&gt;就拿扩大来说，并不是在原数组的地址空间基础上，继续往后按照我们的意愿去扩展。因为，我们并不能保证拟扩展的地址空间上，是否有其他程序已经先行占用了？如果拟扩展地址空间上没有占用，那么后续扩展的内容调整后的内存空间和原来的内存空间，保持同一内存始址。&lt;/p&gt;
&lt;p&gt;否则，程序会在内存的堆区重新找一块空闲的地址空间，并返回新的内存始址。所以，&lt;code&gt;realloc&lt;/code&gt;返回的指针很可能指向一个新的地址。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;realloc(p, size)&lt;/code&gt; 的功能是，分配一块大小为&lt;code&gt;size&lt;/code&gt;的内存，并将&lt;code&gt;p&lt;/code&gt;所指的内容复制过来(如果空间变大)并将重新分配的内存指针返回&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c-&amp;gt;stack&lt;/code&gt; 始终指向内存开头，&lt;br&gt;
&lt;code&gt;c-&amp;gt;top &lt;/code&gt;可以说是已使用大小 指向栈顶&lt;br&gt;
&lt;code&gt;c-&amp;gt;size&lt;/code&gt; 表示&lt;code&gt;c-&amp;gt;stack&lt;/code&gt;指向的这块内存的大小。&lt;/p&gt;
&lt;h3 id=&#34;windows-下的内存泄漏检测方法&#34;&gt;Windows 下的内存泄漏检测方法&lt;/h3&gt;
&lt;p&gt;在 Windows 下，可使用 Visual C++ 的 &lt;strong&gt;C Runtime Library（CRT）&lt;/strong&gt; 检测内存泄漏&lt;/p&gt;
&lt;p&gt;首先，我们在两个 &lt;code&gt;.c&lt;/code&gt; 文件首行插入这一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;# ifdef _WINDOWS
# define _CRTDBG_MAP_ALLOC
# include &amp;lt;crtdbg.h&amp;gt;
# endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并在 &lt;code&gt;main()&lt;/code&gt; 开始位置插入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(){
# ifdef _WINDOWS
_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF |_CRTDBG_LEAK_CHECK_DF);
# endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在输出会看到内存泄漏信息：&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688474555259.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;这正是我们在单元测试中，先设置字符串，然后设布尔值时没释放字符串所分配的内存。比较麻烦的是，它没有显示调用堆栈。从输出信息中 ... {79} ... 我们知道是第 79 次分配的内存做成问题，我们可以加上 _CrtSetBreakAlloc(79); 来调试，那么它便会在第 79 次时中断于分配调用的位置，那时候就能从调用堆栈去找出来龙去脉。&lt;/p&gt;
&lt;p&gt;总的来说，就是先通过&lt;code&gt;crt&lt;/code&gt;查看到第几次分配内存泄露，然后再用&lt;code&gt;_CrtSetBreakAlloc&lt;/code&gt;函数中断于该位置具体分析调用堆栈&lt;/p&gt;
&lt;h2 id=&#34;4-unicode&#34;&gt;4. Unicode&lt;/h2&gt;
&lt;p&gt;为了制定一套多语言的统一编码系统，多个机构成立了 Unicode 联盟，在 1991 年释出 Unicode 1.0，收录了 24 种语言共 7161 个字符。&lt;/p&gt;
&lt;p&gt;在四分之一个世纪后的 2016年，Unicode 已释出 9.0 版本，收录 135 种语言共 128237 个字符。&lt;/p&gt;
&lt;p&gt;这些字符被收录为统一字符集（Universal Coded Character Set, UCS），每个字符映射至一个整数码点（code point），码点的范围是 &lt;code&gt;0&lt;/code&gt; 至 &lt;code&gt;0x10FFFF&lt;/code&gt;，码点又通常记作 &lt;code&gt;U+XXXX&lt;/code&gt;，当中 &lt;code&gt;XXXX&lt;/code&gt; 为 16 进位数字。例如 劲 → &lt;code&gt;U+52B2&lt;/code&gt;、峰 → &lt;code&gt;U+5CF0&lt;/code&gt;。很明显，UCS 中的字符无法像 ASCII 般以一个字节存储。&lt;/p&gt;
&lt;p&gt;因此，Unicode 还制定了各种储存码点的方式，这些方式称为 Unicode 转换格式（Uniform Transformation Format, UTF）。现时流行的UTF 为 UTF-8、UTF-16 和 UTF-32。&lt;/p&gt;
&lt;p&gt;每种 UTF 会把一个码点储存为一至多个编码单元（code unit）。例如 UTF-8 的编码单元是 8 位的字节、UTF-16 为 16 位、UTF-32 为 32 位。&lt;/p&gt;
&lt;p&gt;除 UTF-32 外，UTF-8 和 UTF-16 都是可变长度编码。&lt;/p&gt;
&lt;p&gt;UTF-8 的优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它采用字节为编码单元，不会有字节序（endianness）的问题。&lt;/li&gt;
&lt;li&gt;每个 ASCII 字符只需一个字节去储存。&lt;/li&gt;
&lt;li&gt;如果程序原来是以字节方式储存字符，理论上不需要特别改动就能处理 UTF-8 的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JSON字符串中的 &lt;code&gt;\uXXXX&lt;/code&gt; 是以 16 进制表示码点 &lt;code&gt;U+0000&lt;/code&gt; 至 &lt;code&gt;U+FFFF&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4 位的 16 进制数字只能表示 &lt;code&gt;0&lt;/code&gt; 至 &lt;code&gt;0xFFFF&lt;/code&gt;，但 UCS 的码点是从&lt;code&gt; 0&lt;/code&gt; 至 &lt;code&gt;0x10FFFF&lt;/code&gt;，那怎么能表示多出来的码点？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;U+0000&lt;/code&gt; 至 &lt;code&gt;U+FFFF&lt;/code&gt; 这组 Unicode 字符称为基本多文种平面（basic multilingual plane, BMP），还有另外 16 个平面。&lt;/p&gt;
&lt;p&gt;那么 BMP 以外的字符，JSON 会使用代理对（surrogate pair）表示 &lt;code&gt;\uXXXX``\uYYYY&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 BMP 中，保留了 2048 个代理码点。如果第一个码点是&lt;code&gt;U+D800 &lt;/code&gt;至 &lt;code&gt;U+DBFF&lt;/code&gt;，我们便知道它是代码对的高代理项（high surrogate），之后应该伴随一个 &lt;code&gt;U+DC00&lt;/code&gt; 至 &lt;code&gt;U+DFFF&lt;/code&gt; 的低代理项（low surrogate）。&lt;/p&gt;
&lt;p&gt;然后，我们用下列公式把代理对 &lt;code&gt;(H, L)&lt;/code&gt; 变换成真实的码点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;codepoint = 0x10000 + (H − 0xD800) × 0x400 + (L − 0xDC00)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UTF-8 的编码单元为 8 位（1 字节），每个码点编码成 1 至 4 个字节。它的编码方式很简单，按照码点的范围，把码点的二进位分拆成 1 至最多 4 个字节：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;码点范围&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;码点位数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;字节1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;字节2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;字节4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;字节4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;U+0000&lt;/code&gt;~&lt;code&gt;U+007F&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0xxxxxxx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;U+0080&lt;/code&gt;~&lt;code&gt;U+07FF&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;110xxxxx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10xxxxxx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;U+0800&lt;/code&gt;~&lt;code&gt;U+FFFF&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1110xxxx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10xxxxxx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10xxxxxx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;U+10000&lt;/code&gt;~&lt;code&gt;U+10FFF&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;21&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11110xxx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10xxxxxx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10xxxxxx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10xxxxxx&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这个编码方法的好处之一是，码点范围 &lt;code&gt;U+0000&lt;/code&gt; ~ &lt;code&gt;U+007F&lt;/code&gt; 编码为一个字节，与 ASCII 编码兼容。这范围的 Unicode 码点也是和 ASCII 字符相同的。因此，一个 ASCII 文本也是一个 UTF-8 文本。&lt;/p&gt;
&lt;p&gt;我们举一个例子解析多字节的情况， 欧元符号→&lt;code&gt;U+20AC:&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;U+20AC&lt;/code&gt;在&lt;code&gt;U+0800&lt;/code&gt; ~ &lt;code&gt;U+FFFF&lt;/code&gt;的范围内,应编码成3个字节。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;U+20AC&lt;/code&gt;的二进位为 10000010101100&lt;/li&gt;
&lt;li&gt;3个字节的情况我们要16位的码点，所以在前面补两个0,成为 010000010101100&lt;/li&gt;
&lt;li&gt;按上表把二进位分成3组: 0010, 000010, 101100&lt;/li&gt;
&lt;li&gt;加上每个字节的前缀: 1100010, 10000010, 10101100&lt;/li&gt;
&lt;li&gt;用十六进位表示即: &lt;code&gt;0xE2&lt;/code&gt;, &lt;code&gt;0x82&lt;/code&gt;, &lt;code&gt;0xAC&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将整数转换为utf-8字符代码 注意utf-8中可以用多个字节存储一个字符 即存入多个不同字符 解码时会自动转换为utf-8字符&lt;/p&gt;
&lt;p&gt;为什么要做 &lt;code&gt;x &amp;amp; 0xFF&lt;/code&gt; 这种操作呢？这是因为 &lt;code&gt;u&lt;/code&gt; 是 &lt;code&gt;unsigned&lt;/code&gt; 类型，一些编译器可能会警告这个转型可能会截断数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static void lept_encode_utf8 (lept_ context* C，unsigned u) {
    if (u &amp;lt;= 0x7F) PUTC(C, u &amp;amp; 0xFF);
    else if (u &amp;lt;= 0x7FF) {
        PUTC(C, 0xC0 | ((u &amp;gt;&amp;gt; 6) &amp;amp; 0xFF));
        PUTC(C, 0x88 | ( u &amp;amp; ex3F));
    }
    else if (u &amp;lt;= 0xFFFF) {
        PUTC(C, 0xE0| ((u &amp;gt;&amp;gt; 12) &amp;amp; 0xFF));
        PUTC(C, 0x80| ((u &amp;gt;&amp;gt; 6) &amp;amp; 0x3F));
        PUTC(E, 0x80| ( u &amp;amp; 0x3F));
    }
    else {
        assert(u &amp;lt;= 0x10FFFF);
        PUTC(C, 0xF0| ((u &amp;gt;&amp;gt; 18) &amp;amp; 0xFF));
        PUTC(C, 0x80| ((u &amp;gt;&amp;gt; 12) &amp;amp; 0x3F));
        PUTC(C, 0x88| ((u &amp;gt;&amp;gt; 6) &amp;amp; 0x3F));
        PUTC(C, 0x80| ( u &amp;amp; 0x3F));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-数组&#34;&gt;5. 数组&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct{ 
    lept_value* e;
    size_t size, capacity; 
} a;
/* array: elements, element count, capacity */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个 JSON 数组可以包含零至多个元素，而这些元素也可以是数组类型。换句话说，数组可以表示嵌套（nested）的数据结构。&lt;/p&gt;
&lt;p&gt;对于 JSON 数组，也可以用与解析字符串相同的方法，而且，可以用同一个堆栈！只需要把每个解析好的元素压入堆栈，解析到数组结束时，再一次性把所有元素弹出，复制至新分配的内存之中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for (;;) {
    /* bug! */
    lept_value* e = lept_context_push(c, sizeof(lept_value));
    lept_init(e); 
    size++;
    if ((ret = lept_parse_value(c, e)) != LEPT_PARSE_OK) 
        return ret;
    /* ... */
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个 bug 源于压栈时，会获得一个指针 &lt;code&gt;e&lt;/code&gt;，指向从堆栈分配到的空。&lt;/p&gt;
&lt;p&gt;然后，程序对这个指针调用 &lt;code&gt;lept_parse_value(c, e)&lt;/code&gt;，这里会出现问题&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;lept_parse_value()&lt;/code&gt; 及之下的函数都需要调用 &lt;code&gt;lept_context_push()&lt;/code&gt;，而&lt;code&gt;lept_context_push()&lt;/code&gt; 在发现栈满了的时候会用 &lt;code&gt;realloc()&lt;/code&gt; 扩容。&lt;/p&gt;
&lt;p&gt;这时候，我们上层的 &lt;code&gt;e&lt;/code&gt; 就会失效，变成一个悬挂指针（dangling pointer），而且&lt;code&gt;lept_parse_value(c, e)&lt;/code&gt; 会通过这个指针写入解析结果，造成非法访问。&lt;/p&gt;
&lt;p&gt;这个bug非常不明显 只有当栈满时才会发生 因此在使用指针时 必须明白指针的生存周期&lt;br&gt;
使用&lt;code&gt;malloc&lt;/code&gt; 就需要使用&lt;code&gt;free&lt;/code&gt;将其释放&lt;/p&gt;
&lt;p&gt;而在解析&lt;code&gt;array&lt;/code&gt;时使用了&lt;code&gt;malloc&lt;/code&gt; 没释放 因此必须在解析完毕 不使用时释放 也就是在&lt;code&gt;lept_free()&lt;/code&gt;处释放&lt;/p&gt;
&lt;h2 id=&#34;6-对象&#34;&gt;6. 对象&lt;/h2&gt;
&lt;p&gt;在软件工程中，代码重构（code refactoring）是指在不改变软件外在行为时，修改代码以改进结构。&lt;/p&gt;
&lt;p&gt;代码重构十分依赖于单元测试，因为我们是通过单元测试去维护代码的正确性。有了足够的单元测试，我们可以放胆去重构，尝试并评估不同的改进方式，找到合乎心意而且能通过单元测试的改动，我们才提交它。&lt;/p&gt;
&lt;p&gt;JSON 对象以花括号 &lt;code&gt;{}&lt;/code&gt;（&lt;code&gt;U+007B&lt;/code&gt;、&lt;code&gt;U+007D&lt;/code&gt;）包裹表示，另外 JSON 对象由对象成员（member）组成，而 JSON 数组由 JSON 值组成。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct{ 
    lept_member* m;
    size_t size,capacity; 
} o;
/* object: members, member count, capacity */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所谓对象成员，就是键值对，键必须为 JSON 字符串，然后值是任何 JSON 值，中间以冒号 &lt;code&gt;:&lt;/code&gt;（&lt;code&gt;U+003A&lt;/code&gt;）分隔。&lt;/p&gt;
&lt;p&gt;语法如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;member = string Ws %x3A Ws value
object = %x7B ws[ member *( ws %x2C Ws member )] Ws %x7D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们成功地解析整个成员，那么就要把 &lt;code&gt;m.k&lt;/code&gt; 设为空指针，其意义是说明该键的字符串的拥有权已转移至栈，之后如遇到错误，我们不会重覆释放栈里成员的键和这个临时成员的键。&lt;/p&gt;
&lt;h2 id=&#34;7-生成器&#34;&gt;7. 生成器&lt;/h2&gt;
&lt;p&gt;JSON 生成器（generator）负责与解析器相反的事情，就是把树形数据结构转换成 JSON 文本。这个过程又称为「字符串化（stringify）」。&lt;/p&gt;
&lt;p&gt;在实现 JSON 解析时，我们加入了一个动态变长的堆栈，用于存储临时的解析结果。而现在，我们也需要存储生成的结果，所以最简单是再利用该数据结构，作为输出缓冲区。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;sprintf(&amp;quot;%.17g&amp;quot;, ...) &lt;/code&gt;来把浮点数转换成文本。&lt;code&gt;&amp;quot;%.17g&amp;quot;&lt;/code&gt; 是足够把双精度浮点转换成可还原的文本。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int sprintf(char *str, const char *format, ...)&lt;/code&gt; 发送格式化字符串format输出到 &lt;code&gt;str&lt;/code&gt; 所指向的字符串。&lt;/p&gt;
&lt;p&gt;如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sprintf(&amp;quot;%04x&amp;quot;, ...)&lt;/code&gt;可以用来用将16进制数转换为文本&lt;br&gt;
&lt;code&gt;%04x&lt;/code&gt; 中&lt;code&gt;x&lt;/code&gt;表示以小写的十六进制数输出；4表示输百出的十六进制数的宽度是4个字符；0表示输出的十六进制数中，不足4个字符的部分，用“0”来补度充，以达到4个字符的宽度。&lt;/p&gt;
&lt;h3 id=&#34;函数优化&#34;&gt;函数优化&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;lept_stringify_string()&lt;/code&gt; 实现中，每次输出一个字符/字符串，都要调用&lt;code&gt;lept_context_push()&lt;/code&gt;。如果我们使用一些性能剖测工具，也可能会发现这个函数消耗较多 CPU。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688474540894.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;中间最花费时间的，应该会是 (1)  需要计算而且作分支检查。&lt;/p&gt;
&lt;p&gt;一个优化的点子是，预先分配足够的内存，每次加入字符就不用做这个检查了。&lt;/p&gt;
&lt;p&gt;我们可以看到，每个字符可生成最长的形式是 &lt;code&gt;\u00XX&lt;/code&gt;，占 6 个字符，再加上前后两个双引号，也就是共 &lt;code&gt;len * 6 + 2&lt;/code&gt; 个输出字符。&lt;/p&gt;
&lt;p&gt;那么，使用 &lt;code&gt;char* p = lept_context_push()&lt;/code&gt; 作一次分配后，便可以用 &lt;code&gt;*p++ = c&lt;/code&gt; 去输出字符了。&lt;/p&gt;
&lt;p&gt;最后，再按实际输出量调整堆栈指针。&lt;/p&gt;
&lt;p&gt;要注意的是，很多优化都是有代价的。这个优化采取空间换时间的策略，对于只含一个字符串的JSON，很可能会分配多 6 倍内存；但对于正常含多个值的 JSON，多分配的内存可在之后的值所利用，不会造成太多浪费。&lt;/p&gt;
&lt;p&gt;另一个小优化点是，自行编写十六进位输出，避免 &lt;code&gt;printf()&lt;/code&gt; 内解析格式的开销&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688474534993.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;8-常见的json解析工具&#34;&gt;8. 常见的json解析工具&lt;/h2&gt;
&lt;h3 id=&#34;jackson&#34;&gt;Jackson&lt;/h3&gt;
&lt;p&gt;Jackson库（http://jackson.codehaus.org），是基于java语言的开源json格式解析工具功能全面，提供多种模式的json解析方式，“对象绑定”使用方便，利用注解包能为我们开发提供很多便利。&lt;/p&gt;
&lt;p&gt;性能较高，“流模式”的解析效率超过绝大多数类似的json包。&lt;/p&gt;
&lt;h3 id=&#34;fastjson&#34;&gt;FastJson&lt;/h3&gt;
&lt;p&gt;Fastjson 是一个 Java 库，可以将 Java 对象转换为 JSON 格式，当然它也可以将 JSON 字符串转换为 Java 对象。&lt;/p&gt;
&lt;p&gt;Fastjson 可以操作任何 Java 对象，即使是一些预先存在的没有源码的对象。&lt;/p&gt;
&lt;p&gt;提供服务器端、安卓客户端两种解析工具，性能表现较好。&lt;/p&gt;
&lt;h2 id=&#34;9-自我学习开发的c版本&#34;&gt;9. 自我学习开发的C++版本&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/wjcsw/cpp_json&#34;&gt;cpp_json&lt;/a&gt;&lt;br&gt;
本项目是基于 json-tutorial 教程 个人学习后开发的c++版本&lt;/p&gt;
&lt;h3 id=&#34;项目特点&#34;&gt;项目特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;通过cmake构建跨平台使用的代码&lt;/li&gt;
&lt;li&gt;相较于原教程使用指针管理内存的方法，本项目使用C++的容器来管理动态内存，在可读性和安全性上都更高&lt;/li&gt;
&lt;li&gt;本项目相较于原项目在某些处理上有所不同
&lt;ul&gt;
&lt;li&gt;在字符串处理上：本项目由于使用内置的string而不解析\0字符&lt;/li&gt;
&lt;li&gt;在数字溢出方面：本项目采用与C++本身一致的处理机制，对于溢出的数字，令其为对应的极限值，不进行报错&lt;/li&gt;
&lt;li&gt;本项目使用标准库的 map 容器实现了JSON_OBJECT，因此可以方便的直接调用map的函数来获取键值情况、查找key等&lt;/li&gt;
&lt;li&gt;使用 vector 容器实现了JSON_ARRAY 进行动态内存的管理&lt;/li&gt;
&lt;li&gt;同时 本项目还通过重载运算符的方法实现了错误情况打印, JSON对象打印内容和JSON对象拷贝构造，拷贝赋值运算符，以及直接使用运算符进行JSON对象的比较运算&lt;/li&gt;
&lt;li&gt;定义了JSON对象的swap操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;项目结构&#34;&gt;项目结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CMakeLists.txt：CMake配置文件&lt;/li&gt;
&lt;li&gt;cpp_json.cpp：测试文件，包含对于各项解析的单元测试&lt;/li&gt;
&lt;li&gt;cpp_json.h：头文件，对存储数据结构定义和解析函数定义&lt;/li&gt;
&lt;li&gt;parse.cpp：实现头文件中定义的解析函数&lt;/li&gt;
&lt;/ul&gt;
">[C++项目] Json解析器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/ukb8lk1ZN/"" data-c="
          &lt;h2 id=&#34;方法&#34;&gt;方法&lt;/h2&gt;
&lt;p&gt;Persistent homology 持久同源性&lt;/p&gt;
&lt;p&gt;利用边的权重进行排序,降序添加边构成子图&lt;code&gt;g1&lt;/code&gt;, &lt;code&gt;g2&lt;/code&gt;, …., &lt;code&gt;gm&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;同源性提供了知识网络的底层标志复合体所提供的知识的分层表示的结构的全局表征。&lt;/p&gt;
&lt;p&gt;持久同源性通过对网络边缘权重的过滤来跟踪该知识结构，并在同现频率的尺度上提供该结构的更细粒度表征。&lt;/p&gt;
&lt;h2 id=&#34;结果&#34;&gt;结果&lt;/h2&gt;
&lt;p&gt;通过绘制六个主要科学技术领域（化学、计算机、药物、电气、机械和物理）的平均拓扑洞数，概述了这些变化: 高阶结构的增加常常与低阶结构的减少相一致 在20世纪70年代，最常见的洞是一维的，其次是维度0、2和3。&lt;/p&gt;
&lt;p&gt;到20世纪90年代末，顺序发生了变化，现在最常见的孔是维度2的洞，其次是维1、3和0。高阶结构和低阶结构之间的这种反向关系很重要，因为它不仅表明发现可能在更高的层次上进行得越来越频繁，而且表明它在更低的层次上做得越来越少，因此使用传统技术可能不太明显。&lt;/p&gt;
&lt;p&gt;发现在计算机、物理、电子工程中，代表高阶网络结构的曲线显著升高，同时低维拓扑结构降低。这意味着这些领域近年来的发展，依赖参与者之间紧密的合作和互补。&lt;/p&gt;
&lt;p&gt;以成对的方式计算每年每个知识子类别之间的持久性图之间的Wasserstein距离来判断拓扑变化: 虽然个别知识领域在若干年的拓扑相似性方面可能趋同，但知识领域之间拓扑结构的总体差异表明，随着时间的推移，存在显著差异 意味着科学和技术知识的维度正在增加，并且在各个领域的拓扑上变得更加异质。&lt;/p&gt;
&lt;p&gt;在科研中的语言学上 更高维度的空洞与更抽象的词相关联 : 在&lt;code&gt;β0&lt;/code&gt;下，最具预测性的引理是指通过视觉、声音和触觉容易感知的事物（例如，“曲柄”、“线轴”、“鞋”）；令人惊讶的是，该清单包括6种简单机械中的3种（“杠杆”、“轮子”、“滑轮”）。相比之下，在&lt;code&gt;β3&lt;/code&gt;下，最强烈关联的名词指的是不太容易感知的事物（例如，“过程”、“属性”、“方法”）。&lt;/p&gt;
">[论文阅读] The Emergence of Higher-Order Structure in Scientific and Technological Knowledge Networks</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/jVyPUDC0U/"" data-c="
          &lt;h2 id=&#34;高阶相互作用-超图和单纯复形&#34;&gt;高阶相互作用: 超图和单纯复形&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1688471224596.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688471229182.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
单纯复形骨架（Simplicial complex skeleton）：&lt;code&gt;d&lt;/code&gt;维单纯复形&lt;code&gt;K&lt;/code&gt;中所有小于等于维度&lt;code&gt;r&lt;/code&gt;的单纯形的集合，称为单纯复形&lt;code&gt;K&lt;/code&gt;的&lt;code&gt;r&lt;/code&gt;维骨架，记为&lt;code&gt;Kr&lt;/code&gt;。如果只考虑一个单纯复形网络中的节点和连边，即为该单纯复形网络的1维骨架。&lt;/p&gt;
&lt;p&gt;纯单纯复形（Pure simplicial complex）：一个纯&lt;code&gt;d&lt;/code&gt;维单纯复形是由一组&lt;code&gt;d&lt;/code&gt;维单形及其面构成的。因此，纯&lt;code&gt;d&lt;/code&gt;维单纯复形只允许&lt;code&gt;d&lt;/code&gt;维单形作为面。这意味着纯&lt;code&gt;d&lt;/code&gt;维单纯形复形是由&lt;code&gt;d&lt;/code&gt;维单纯形沿着它们的表面粘接而形成的&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688471233682.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;贝蒂数表示单纯复形的m维洞的数量，也等于同调群的秩。其中同调群是空间表示中的m-循环链的同调类，它&lt;br&gt;
们与不是(m+1)-链边界的循环链有关&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1688471410962.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;引入高阶互动&#34;&gt;引入高阶互动&lt;/h2&gt;
&lt;p&gt;引入高阶互动后，能够用更细的粒度去描述系统中的非线性反馈&lt;/p&gt;
&lt;p&gt;引入非线性的高阶相互作用并改变其强度，是促成爆发性转变的通用机制&lt;/p&gt;
&lt;p&gt;高阶相互作用引入后能够探索的另一问题，即网络的拓扑结构如何随时间演化 同步现象会由高阶连接的部分扩散到低阶连接的部分（图b）；或者相反，由低阶部分扩散到高阶部分&lt;/p&gt;
&lt;h2 id=&#34;从观测数据中重构高阶相互作用网络&#34;&gt;从观测数据中重构高阶相互作用网络&lt;/h2&gt;
&lt;p&gt;即使系统中存在高阶相互作用，但观察到的数据却往往是两两节点之间的。例如A从B处听到了一则谣言，但它可能是从B之前其他人那里传来的。如何根据时间序列推测高阶相互作用的存在呢？&lt;/p&gt;
&lt;p&gt;通过贝叶斯推断或者统计模型中的零假设，用证据说明其存在，是重构高阶相互作用网络的两种常用方法。&lt;br&gt;
除了直接观测到的相互影响事件，还可以通过系统的状态随时间的改变，来推断是否存在高阶相互作用，例如&lt;br&gt;
节点间是否存在同步，是否有相关性等。&lt;/p&gt;
&lt;h2 id=&#34;未来方向&#34;&gt;未来方向&lt;/h2&gt;
&lt;p&gt;当前的模型，都假设高阶相互作用出现与否不会随时间而改变。如何在模型中加入变化的高阶相互作用，是未&lt;br&gt;
来的一个研究方向。&lt;/p&gt;
">[论文阅读] The physics of higher-order interactions in complex systems</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/hvIOsgc3-/"" data-c="
          &lt;h2 id=&#34;模型&#34;&gt;模型&lt;/h2&gt;
&lt;p&gt;用 public goods game (PGG) 公共物品博弈模型来表示人类能否达成合作&lt;/p&gt;
&lt;p&gt;PGG:&lt;br&gt;
N名玩家在不知道其他玩家选择的情况下，独立选择将初始资金的一部分投入公共池中。投入公共池的资金将被乘以一个系数作为“公共物品”，然后此“公共物品”将被平分给所有玩家。每位玩家还可获得初始资金中未&lt;br&gt;
投入到公共池的部分。系数的范围为(1,N)，即投入公共池会让资金带来更高的收益，但是不足以保证从公共物品中平分获得的收益一定大于原来的投入&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688471631579.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;C表示合作者, D表示不合作者 其等价于一个连续的囚徒困境, 其纳什均衡是大家都不合作,最优解是都合作&lt;/p&gt;
&lt;p&gt;在超图基础上，这篇文章提出了改进后的PGG模型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先以均匀概率随机选择超图中的节点&lt;code&gt;ni&lt;/code&gt;及其超边之一&lt;code&gt;li&lt;/code&gt;。然后，对于任何一条选择的超边&lt;code&gt;li&lt;/code&gt;, 超边的所有成员在他们所属的每个超边上都进行一轮博弈。&lt;/li&gt;
&lt;li&gt;节点累积了他们玩的所有回合的收益，最后由其平均收益来表示。&lt;/li&gt;
&lt;li&gt;节点&lt;code&gt;i&lt;/code&gt;将比较其收益与超边&lt;code&gt;li&lt;/code&gt;中收益最大的节点的收益,，以一定概率采用超边中具有最大回报节点的策略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结果&#34;&gt;结果&lt;/h2&gt;
&lt;p&gt;无论在节点数均匀或异质，网络都呈现出临界效应——即只要超过特定值，网络中的合作者比例就会显著变化: 节点度数异质的网络（不同参数、不同节点度数分布）中，只要协作系数超过1，网络中合作者的比例就会迅速提升到100%&lt;/p&gt;
&lt;p&gt;随着网络异质程度的增加，达到充分合作所需的协作系数降低，这意味着在合作者的人际网络具有多元化的环&lt;br&gt;
境中，人们能够更容易地展开合作。&lt;/p&gt;
">[论文阅读] Evolutionary dynamics of higher-order interactions in social networks</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/IHcRnAlre/"" data-c="
          &lt;h2 id=&#34;图卷积神经网络&#34;&gt;图卷积神经网络&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1688470924414.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以按照实施卷积的方式分为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;谱方法(spectral-based GCNs)&lt;/li&gt;
&lt;li&gt;空间方法(spatial-based GCNs)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中, 谱方法利用卷积定理从谱域定义图卷积&lt;/p&gt;
&lt;p&gt;空间方法则致力于从节点所在的空间域出发, 通过定义聚合操作和连接操作来聚合邻居信息并与中心节点信息合并从而形成新的中心节点表示&lt;/p&gt;
&lt;h2 id=&#34;detecting-the-ultra-low-dimensionality-of-real-networks&#34;&gt;Detecting the ultra low dimensionality of real networks&lt;/h2&gt;
&lt;p&gt;在没有先验的情况下预估网络维度&lt;br&gt;
https://github.com/networkgeometry/detecting-dimensionality&lt;/p&gt;
">[论文阅读] 图神经网络在复杂图挖掘上的研究进展</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/nBjC6ymmW/"" data-c="
          &lt;p&gt;&lt;strong&gt;静态内存&lt;/strong&gt;用于保存&lt;strong&gt;局部&lt;code&gt;static&lt;/code&gt;对象&lt;/strong&gt;，&lt;strong&gt;类中的&lt;code&gt;static&lt;/code&gt;数据成员&lt;/strong&gt;以及&lt;strong&gt;定义在任何函数之外的变量&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;栈内存&lt;/strong&gt;用于保存定义在函数之内的非&lt;code&gt;static&lt;/code&gt;对象&lt;br&gt;
分配在这两者中的对象&lt;strong&gt;由编译器自动创建和销毁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除此之外 每个程序还有一个内存池 被称作&lt;strong&gt;自由空间或堆&lt;/strong&gt;&lt;br&gt;
用于储存动态分配的对象 这些对象是程序运行时分配的对象&lt;br&gt;
由程序来控制生存期  即必须被代码显式地销毁&lt;/p&gt;
&lt;p&gt;C++中动态内存管理是通过一对运算符&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;来完成的&lt;/p&gt;
&lt;h2 id=&#34;智能指针&#34;&gt;智能指针&lt;/h2&gt;
&lt;p&gt;为了更安全更容易地使用动态内存 新标准还提供了两种智能指针: &lt;code&gt;shared_ptr&lt;/code&gt; 和 &lt;code&gt;unique_ptr&lt;/code&gt;  它们负责自动释放所指向的对象&lt;br&gt;
这两者的区别在于管理底层指针的方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shared_ptr&lt;/code&gt;允许多个指针指向同一对象&lt;/li&gt;
&lt;li&gt;而&lt;code&gt;unique_ptr&lt;/code&gt;独占所指向的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两者都是模板类 定义在头文件&lt;code&gt;memory&lt;/code&gt;中&lt;/p&gt;
&lt;p&gt;默认初始化的智能指针保存着一个空指针&lt;/p&gt;
&lt;h3 id=&#34;shared_ptr&#34;&gt;shared_ptr&lt;/h3&gt;
&lt;p&gt;最安全的分配和使用动态内存的方法是调用&lt;code&gt;make_shared()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;shared_ptr&amp;lt;int&amp;gt; p = make_shared&amp;lt;int&amp;gt;(42);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当对&lt;code&gt;shared_ptr&lt;/code&gt;进行拷贝和赋值时 每个&lt;code&gt;shared_ptr&lt;/code&gt;都会记录当前有多少个其他&lt;code&gt;shared_ptr&lt;/code&gt;指向相同的对象&lt;br&gt;
可以认为每个&lt;code&gt;shared_ptr&lt;/code&gt;都有一个关联计数器 称之为&lt;strong&gt;引用计数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当进行拷贝初始化或将其作为参数传递给另一个函数以及作为函数返回值时 引用计数+1&lt;br&gt;
当对其赋予新值或是其被销毁时(如局部&lt;code&gt;shared_ptr&lt;/code&gt;离开作用域) 引用计数-1&lt;/p&gt;
&lt;p&gt;一旦&lt;code&gt;shared_ptr&lt;/code&gt;的引用计数为0 则自动释放它所管理的对象&lt;br&gt;
&lt;code&gt;shared_ptr&lt;/code&gt;是通过析构函数来完成销毁工作的&lt;/p&gt;
&lt;p&gt;使用动态内存的一个常见目的是&lt;strong&gt;允许多个对象共享相同状态&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;在自由空间分配的内存是无名的&lt;/strong&gt; 因此&lt;code&gt;new&lt;/code&gt;无法为其分配的对象命名 而是&lt;strong&gt;返回一个指向该对象的指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;new&lt;/code&gt;可以分配动态数组 &lt;code&gt;int *p = new int[12];&lt;/code&gt;&lt;br&gt;
但事实上动态数组并不是数组类型 而是其对应元素类型的指针&lt;br&gt;
故不能使用一些数组操作 比如对其使用&lt;code&gt;begin()&lt;/code&gt;和&lt;code&gt;end()&lt;/code&gt;函数 也不能使用&lt;code&gt;for&lt;/code&gt;范围语句来处理&lt;/p&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt;分配的对象 不管是单个的还是动态数组 都是默认初始化的&lt;br&gt;
因此可能会出现未定义的情况 最好是定义时进行初始化&lt;br&gt;
如果初始化器数目小于元素数目 剩余元素将进行&lt;strong&gt;默认值初始化 **&lt;br&gt;
若大于 则抛出异常并&lt;/strong&gt;且不会分配任何内存**&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int *pi = new int(1024); //pi指向的对象的值为1024
string *ps = new string(3,&#39;a&#39;); // *ps为&amp;quot;aaa&amp;quot;
vector&amp;lt;int&amp;gt; *pv = new vector&amp;lt;int&amp;gt;{0,1,2,3};
int *pia = new int[3]{0,1}; //列表初始化动态数组 前两个元素为对应初始化器元素 第三个元素值初始化为0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;虽然不能定义长度为0的数组 但可以定义长度为0的动态数组&lt;/strong&gt;&lt;br&gt;
因为动态数组本质上是个指针而不是数组类型 长度为0的动态数组返回合法的非空指针 类似于尾后指针 不可对其解引用&lt;/p&gt;
&lt;p&gt;相对应的 与释放单个对象不同 释放动态数组时需要在指针前加一个方括号&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;delete p;//删除单个对象 
delete [] pa; //删除动态数组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除动态数组时 数组中的元素按逆序销毁&lt;br&gt;
即最后一个先被销毁 然后是倒数第二个 以此类推&lt;/p&gt;
&lt;p&gt;可以使用直接初始化的方式来利用&lt;code&gt;new&lt;/code&gt;来初始化智能指针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;shared_ptr&amp;lt;int&amp;gt; p1(new int(1024)); 
//注意 不能使用赋值初始化 因为指针参数的构造函数是explicit的 不接受隐式转换
shared_ptr&amp;lt;int&amp;gt; p1=new int(1024) //这种方式是错的 不能使用赋值初始化
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用内置指针初始化智能指针时 要么内置指针指向的是动态内存 要么就必须自己为其提供定义&lt;code&gt;delete&lt;/code&gt;操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;shared_ptr&amp;lt;T&amp;gt; p(q, del) //del为自定义的释放操作
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;delete&lt;/code&gt;释放内存时 释放非自由空间的内存或是多次释放同一内存 都是未定义的行为&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要混用普通指针和智能指针&lt;/strong&gt;&lt;br&gt;
因为将一个智能指针绑定到一个普通指针时 就将内存的管理责任也移交了&lt;br&gt;
一旦这么做了 就不应该再使用内置指针来访问内存了 因为可能会被智能指针释放&lt;/p&gt;
&lt;h3 id=&#34;unique_ptr&#34;&gt;unique_ptr&lt;/h3&gt;
&lt;p&gt;可以使用&lt;code&gt;unique_ptr&lt;/code&gt;来管理&lt;code&gt;new&lt;/code&gt;分配的动态数组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;unique_ptr&amp;lt;int []&amp;gt; up(new int[10]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;unique_ptr&lt;/code&gt;定义了下标运算符 可以直接通过&lt;code&gt;up[i]&lt;/code&gt;来访问动态数组中的元素&lt;/p&gt;
&lt;p&gt;但&lt;code&gt;shared_ptr&lt;/code&gt;不直接支持管理动态数组&lt;br&gt;
如果要使用&lt;code&gt;shared_ptr&lt;/code&gt;管理动态数组 必须提供自己定义的删除器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;shared_ptr&amp;lt;int&amp;gt; sp(new int[10], [](int *p){delete []p});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;不支持下标 并且智能指针类型不支持算术运算&lt;br&gt;
因此必须使用&lt;code&gt;get&lt;/code&gt;来返回一个内置指针 通过这个内置指针访问元素&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for(int i = 0; i != 10; ++i) {
	*(sp.get( ) + i) = i;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;.get()&lt;/code&gt;函数可以从智能指针返回一个普通指针提供给那些不能使用智能指针的代码&lt;br&gt;
但永远不要使用&lt;code&gt;get&lt;/code&gt;初始化另一个智能指针或为另一个智能指针赋值&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;.reset()&lt;/code&gt;函数可以改变&lt;code&gt;shared_ptr&lt;/code&gt;的指向&lt;br&gt;
&lt;code&gt;.reset()&lt;/code&gt; 将指针置空&lt;br&gt;
&lt;code&gt;.reset(q) &lt;/code&gt;将指针指向q&lt;br&gt;
&lt;code&gt;.reset(q, d)&lt;/code&gt; 利用&lt;code&gt;d&lt;/code&gt;而非&lt;code&gt;delete&lt;/code&gt;释放&lt;code&gt;q&lt;/code&gt; 因为如果使用智能指针管理的资源不是new分配的动态内存 要传递一个删除函数&lt;/p&gt;
&lt;p&gt;不要使用相同的内置指针初始化或&lt;code&gt;reset&lt;/code&gt;多个智能指针&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;shared_ptr&lt;/code&gt;不同 没有类似于&lt;code&gt;make_shared&lt;/code&gt;这种库函数&lt;br&gt;
当定义一个&lt;code&gt;unique_ptr&lt;/code&gt;时 需要&lt;strong&gt;将其绑定到一个&lt;code&gt;new&lt;/code&gt;返回的指针上&lt;/strong&gt;&lt;br&gt;
并且必须使用直接初始化方式 不能赋值初始化&lt;/p&gt;
&lt;p&gt;不能直接拷贝或者赋值&lt;code&gt;unique_ptr&lt;/code&gt;&lt;br&gt;
但可以通过调用&lt;code&gt;.release()&lt;/code&gt;或&lt;code&gt;.reset()&lt;/code&gt;将指针的所有权从一个非&lt;code&gt;const&lt;/code&gt;的&lt;code&gt;unique_ptr&lt;/code&gt;转移给另一个&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.release()&lt;/code&gt;返回当前保存指针并将其置空 可以切断&lt;code&gt;unique_ptr&lt;/code&gt;与当前管理对象的联系&lt;br&gt;
但不会释放内存 如果我们不用另一个智能指针来保存&lt;code&gt;.release()&lt;/code&gt;返回的指针 就必须通过程序来负责资源的释放&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;shared_ptr&lt;/code&gt;不同 向&lt;code&gt;unique_ptr&lt;/code&gt;传递删除器会影响到&lt;code&gt;unique_ptr&lt;/code&gt;的类型&lt;br&gt;
所以 与重载关联容器的比较操作类似 必须在类型定义时 即unique_ptr后的尖括号中 在类型之后额外指定删除器类型&lt;br&gt;
在创建和&lt;code&gt;reset&lt;/code&gt;一个这种&lt;code&gt;unique_ptr&lt;/code&gt;对象时 都必须提供一个指定类型的可调用对象用作删除器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;unique_ptr&amp;lt;int, decltype(end_connection)*&amp;gt; p(&amp;amp;c, end_connection);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;weak_ptr&#34;&gt;weak_ptr&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;weak_ptr&lt;/code&gt;是一种&lt;strong&gt;不控制所指向对象生存期&lt;/strong&gt;的智能指针&lt;br&gt;
它指向于一个&lt;code&gt;shared_ptr&lt;/code&gt;管理的对象&lt;/p&gt;
&lt;p&gt;将一个&lt;code&gt;weak_ptr&lt;/code&gt;绑定到一个&lt;code&gt;shared_ptr&lt;/code&gt;上不会改变&lt;code&gt;shared_ptr&lt;/code&gt;的引用计数&lt;br&gt;
即使有weak_ptr指向对象 也不影响引用计数归0后&lt;code&gt;shared_ptr&lt;/code&gt;释放内存 所以是一种&amp;quot;弱&amp;quot;共享&lt;/p&gt;
&lt;p&gt;由于对象可能不存在 &lt;strong&gt;不能使用&lt;code&gt;weak_ptr&lt;/code&gt;直接访问对象&lt;/strong&gt;&lt;br&gt;
而必须使用&lt;code&gt;.lock()&lt;/code&gt;函数 此函数检测weak_ptr指向的对象是否存在 存在则返回指向该对象的&lt;code&gt;shared_ptr&lt;/code&gt; 否则返回一个空的&lt;code&gt;shared_ptr&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;weak_ptr&lt;/code&gt;可以用定义&lt;strong&gt;核查指针&lt;/strong&gt; 在使用前检测某个对象是否存在&lt;/p&gt;
&lt;h2 id=&#34;allocator&#34;&gt;allocator&lt;/h2&gt;
&lt;p&gt;通过标准库的&lt;code&gt;allocator&lt;/code&gt;类 可以将内存分配和对象构造分离开来&lt;br&gt;
它分配的是原始的 未构造的内存 它是一个模板类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;allocator&amp;lt;string&amp;gt; alloc; 
auto const p = alloc.allocate(n);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了使用&lt;code&gt;allocator&lt;/code&gt;分配的内存 必须通过&lt;code&gt;.construct()&lt;/code&gt;为&lt;code&gt;allocator&lt;/code&gt;分配的内存构造对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto q = p; //q指向最后一个元素之后的位置
alloc.construct(q++); //构造空串
Alloc.construct(q++, 3, &#39;c&#39;); // 构造了一个 ccc 的字符串
Alloc.construct(q++, &amp;quot;hi&amp;quot;); // 构造了一个 hi 的字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用结束后 通过&lt;code&gt;.destory()&lt;/code&gt;可以销毁单个对象&lt;br&gt;
销毁元素以后 可以通过&lt;code&gt;.deallocate(p, n)&lt;/code&gt;释放从&lt;code&gt;p&lt;/code&gt;开始的&lt;code&gt;n&lt;/code&gt;块内存&lt;/p&gt;
">[C++学习笔记] 动态内存</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/D3wXjYQS0/"" data-c="
          &lt;p&gt;顺序容器与关联容器根本的不同: 顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的,而关联容器中的元素是按关键字来保存和访问的&lt;/p&gt;
&lt;p&gt;关联容器支持高效的关键字查找和访问&lt;/p&gt;
&lt;h2 id=&#34;关联容器类型&#34;&gt;关联容器类型&lt;/h2&gt;
&lt;p&gt;两个主要的关联容器 &lt;code&gt;map&lt;/code&gt; &lt;code&gt;set&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;标准库提供8个关联容器,其不同主要在三个方面:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是基于&lt;code&gt;set&lt;/code&gt;或是&lt;code&gt;map&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关键字是否重复,允许重复的前缀都有&lt;code&gt;multi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;容器是否有序 不按按顺序保存的都以&lt;code&gt;unordered&lt;/code&gt;开头&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Eg. &lt;code&gt;Unordered_multiset&lt;/code&gt; 就是一个无序的允许关键字重复的集合&lt;br&gt;
&lt;code&gt;Set&lt;/code&gt; 则是有序的不允许关键字重复的集合&lt;/p&gt;
&lt;p&gt;在无序容器中 使用哈希函数来组织元素&lt;br&gt;
当从&lt;code&gt;map&lt;/code&gt;中提取元素时 会得到一个&lt;code&gt;pair&lt;/code&gt;类的对象&lt;br&gt;
简单来说&lt;code&gt;pair&lt;/code&gt;类就是一个模板类 保存两个名为&lt;code&gt;first&lt;/code&gt;和&lt;code&gt;second&lt;/code&gt;的公有数据成员, 在这分别保存了关键字和对应值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Map&amp;lt;string,size_t&amp;gt; wc; 
For(const atuo &amp;amp;w: wc){ 
	cout&amp;lt;&amp;lt;w.first&amp;lt;&amp;lt;w.second&amp;lt;&amp;lt;endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当初始化&lt;code&gt;map&lt;/code&gt;时，必须提供关键字类型和值类型，并将每个关键字-值对用&lt;code&gt;{}&lt;/code&gt;括起来&lt;/p&gt;
&lt;p&gt;对于有序关联容器，定义的类型必须包含比较操作，若未定义&lt;code&gt;&amp;lt;&lt;/code&gt; 也可以提供自己定义的操作来代替&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Mutliset&amp;lt;sales_data, decltype(compareISBN)*&amp;gt; bookstore(compareISBN);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;set&lt;/code&gt;而言 &lt;code&gt;key_type&lt;/code&gt; 和&lt;code&gt;value_type&lt;/code&gt;相同&lt;br&gt;
对于&lt;code&gt;map&lt;/code&gt;而言 &lt;code&gt;value_type&lt;/code&gt;为对应的&lt;code&gt;pair&lt;/code&gt;类型 而&lt;code&gt;key_type&lt;/code&gt;和&lt;code&gt;mapped_type&lt;/code&gt;是关键字和映射的类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Set&amp;lt;string&amp;gt;:: value_type v1; 
Set&amp;lt;string&amp;gt;:: key_type_type v2; // v1 v2都为string
Map&amp;lt;string, int&amp;gt;:: value_type v3; 
Map&amp;lt;string, int&amp;gt;:: key_type v4; 
Map&amp;lt;string, int&amp;gt;:: mapped_type v5;
// v3, v4, v5分别为pair&amp;lt;string, int&amp;gt; string 和 int
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对关联容器解引用时 会得到类型为容器&lt;code&gt;value_type&lt;/code&gt;类型的值引用&lt;br&gt;
关联容器中的迭代器都是&lt;code&gt;const&lt;/code&gt;的 即不能通过迭代器改变关键字 但是&lt;code&gt;map&lt;/code&gt;类型可以改变映射值的内容&lt;/p&gt;
&lt;h2 id=&#34;关联容器操作&#34;&gt;关联容器操作&lt;/h2&gt;
&lt;p&gt;类似顺序容器 使用&lt;code&gt;.insert()&lt;/code&gt;或&lt;code&gt;.empalce()&lt;/code&gt;可以向关联容器中插入元素 可以是范围 也可以是&lt;code&gt;{}&lt;/code&gt;的值列表&lt;/p&gt;
&lt;p&gt;向&lt;code&gt;map&lt;/code&gt;中插入元素时 既可以是&lt;code&gt;{}&lt;/code&gt;键值对方式 也可以使用&lt;code&gt;make_pair&lt;/code&gt;显式构造一个&lt;code&gt;pair&lt;/code&gt;对象作为输入&lt;/p&gt;
&lt;p&gt;&lt;code&gt;insert&lt;/code&gt;返回值为&lt;code&gt;pair&lt;/code&gt;类型对象&lt;br&gt;
其&lt;code&gt;first&lt;/code&gt;成员是一个迭代器 指向插入的元素&lt;br&gt;
&lt;code&gt;second&lt;/code&gt;成员是一个&lt;code&gt;bool&lt;/code&gt;值 指示插入成功还是已存在&lt;/p&gt;
&lt;p&gt;同样 使用&lt;code&gt;.erase()&lt;/code&gt;来删除一个元素或一个范围的元素 返回值为&lt;code&gt;void&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;关联容器还额外提供了一个版本的&lt;code&gt;erase&lt;/code&gt; 接受&lt;code&gt;key_type&lt;/code&gt;类型的参数&lt;br&gt;
删除所有匹配给定关键字的元素 返回删除元素的数量&lt;/p&gt;
&lt;p&gt;map容器也提供下标运算符和对应&lt;code&gt;at&lt;/code&gt;函数 但不同之处在于&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果该关键字不在map中 会自动为它创建一个元素并插入到map 对应关联值将进行初始化&lt;/li&gt;
&lt;li&gt;其返回为映射 即类型为&lt;code&gt;mapped_type&lt;/code&gt; 与 解引用得到的不同&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Map&amp;lt;string, int&amp;gt; word; word[&amp;quot;hello&amp;quot;] = 3; 
//插入了一个关键字为hello的元素 关联值进行值初始化 然后将3赋予它
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关联容器可以通过&lt;code&gt;.find()&lt;/code&gt;查找元素 &lt;code&gt;.count()&lt;/code&gt;为某个元素计数&lt;br&gt;
&lt;code&gt;.lower_bound(k)&lt;/code&gt;/&lt;code&gt;.upper_bound(k)&lt;/code&gt; 返回一个迭代器 指向第一个关键字不小于/不大于k的元素&lt;br&gt;
&lt;code&gt;.equal_range(k)&lt;/code&gt; 返回一个&lt;code&gt;pair&lt;/code&gt; 两个成员分别为指向第一个匹配&lt;code&gt;k&lt;/code&gt;的 和最后一个匹配&lt;code&gt;k&lt;/code&gt;的迭代器 等价于同时使用&lt;code&gt;lower_bound&lt;/code&gt; 和&lt;code&gt;upper_bound&lt;/code&gt;确定范围&lt;/p&gt;
&lt;p&gt;无序容器在储存上组织为一组桶 每个桶保存0个或多个元素&lt;/p&gt;
&lt;p&gt;无序容器使用一个哈希函数将元素映射到桶&lt;br&gt;
访问元素时 容器通过计算元素哈希值来确定访问哪个桶 容器将所有具有相同哈希值的元素放在一个桶内&lt;/p&gt;
&lt;p&gt;因此 无序容器的性能依赖于哈希函数的质量和桶的数量和大小&lt;/p&gt;
&lt;p&gt;将不同关键字的元素映射到同一个桶也是允许的&lt;br&gt;
当一个桶保存多个元素时 需要顺序搜索元素&lt;br&gt;
当一个桶中有大量元素时 查找一个特定元素就需要大量比较操作&lt;/p&gt;
&lt;p&gt;无序容器通过&lt;code&gt;hash&amp;lt;key_type&amp;gt;&lt;/code&gt;类型的对象来生成每个元素的哈希值 由于标准库为内置类型和&lt;code&gt;string&lt;/code&gt;等定义了&lt;code&gt;hash&lt;/code&gt;模板 因此我们可以直接定义对应的无序容器&lt;/p&gt;
&lt;p&gt;但是 不能直接定义关键字类型为自定义类类型的无序容器&lt;br&gt;
必须提供对应的哈希函数和判定相等函数&lt;code&gt;==&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Unordered_mutliset&amp;lt;sales_data, decltype(hasher)*, decltype(equaler)*&amp;gt; booker(42, hasher, equaler);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果类定义了&lt;code&gt;==&lt;/code&gt;运算符 则可以只重载哈希函数&lt;/p&gt;
&lt;p&gt;C++中&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;multimap&lt;/code&gt;，&lt;code&gt;multiset&lt;/code&gt;的底层实现都是平衡二叉搜索树，再具体一点是红黑树 所以map、set的增删操作时间时间复杂度是&lt;code&gt;log n&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;unordered_map&lt;/code&gt;、&lt;code&gt;unordered_set&lt;/code&gt;底层实现是哈希表。&lt;/p&gt;
&lt;h2 id=&#34;红黑树&#34;&gt;红黑树&lt;/h2&gt;
&lt;p&gt;红黑树是一个二叉搜索树，它在每个节点增加了一个存储位记录节点的颜色，可以是&lt;font color=Red&gt;RED&lt;/font&gt;,也可以是&lt;strong&gt;BLACK&lt;/strong&gt;；通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡（最短路径就是全黑节点，最长路径就是一个红节点一个黑节点，当从根节点到叶子节点的路径上黑色节点相同时，最长路径刚好是最短路径的两倍）。它同时满足以下特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;节点是&lt;font color=Red&gt;红色&lt;/font&gt;或&lt;strong&gt;黑色&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;根节点是&lt;strong&gt;黑色&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;叶子节点（外部节点，空节点）都是&lt;strong&gt;黑色&lt;/strong&gt;，这里的&lt;strong&gt;叶子节点指的是最底层的空节点&lt;/strong&gt;（外部节点），&lt;code&gt;null&lt;/code&gt;节点的父节点在红黑树里不将其看作叶子节点&lt;/li&gt;
&lt;li&gt;&lt;font color=Red&gt;红色&lt;/font&gt;节点的子节点都是&lt;strong&gt;黑色&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=Red&gt;红色&lt;/font&gt;节点的父节点都是&lt;strong&gt;黑色&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;从根节点到叶子节点的所有路径上不能有 2 个连续的&lt;font color=Red&gt;红色&lt;/font&gt;节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从任一节点到叶子节点的所有路径都包含相同数目的&lt;strong&gt;黑色&lt;/strong&gt;节点&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1687838199776.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;红黑树的查找，插入和删除操作，时间复杂度都是O(logN)。&lt;br&gt;
红黑树的优点就是对有序数据的查询操作不会慢到O(N)的时间复杂度。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1687838212098.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;将节点左旋是将某个节点旋转为其右孩子的左孩子，而右旋是节点旋转为其左孩子的右孩子。&lt;/p&gt;
&lt;p&gt;性质1规定红黑树节点的颜色要么是&lt;font color=Red&gt;红色&lt;/font&gt;要么是&lt;strong&gt;黑色&lt;/strong&gt;，那么在插入新节点时，这个节点应该是&lt;font color=Red&gt;红色&lt;/font&gt;，原因也不难理解。如果插入的节点是&lt;strong&gt;黑色&lt;/strong&gt;，那么这个节点所在路径比其他路径多出一个&lt;strong&gt;黑色&lt;/strong&gt;节点。&lt;/p&gt;
&lt;p&gt;更详细的部分参照这篇博客&lt;a href=&#34;https://blog.csdn.net/cy973071263/article/details/122543826&#34;&gt;红黑树详解&lt;/a&gt;&lt;/p&gt;
">[C++学习笔记] 关联容器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/aFytugwnH/"" data-c="
          &lt;p&gt;C++标准库定义了一组泛型算法实现了一些经典算法的公共接口 如排序 搜索等 它们可以适用于不同类型的元素和多种容器类型&lt;/p&gt;
&lt;p&gt;这些算法大多定义在algorithm头文件中 并在numeric头文件中定义了一组数值算法&lt;/p&gt;
&lt;p&gt;一般情况下这些算法并不直接操作容器 而是通过迭代器来遍历范围 处理元素&lt;/p&gt;
&lt;p&gt;泛型算法永远不会改变底层容器的大小 只会运行在迭代器上 执行迭代器的操作&lt;/p&gt;
&lt;p&gt;泛型算法的结构类似 除了少数例外 都对一个范围内的元素进行操作 通过两个迭代器来确定输入范围&lt;br&gt;
接受输入范围的算法总是使用前两个参数来表示此范围&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Find(vec.begin(),vec.end(), &#39;a&#39;); //查找 若未找到 返回尾后迭代器
accumulate(vec.begin(),vec.end(), 0); // 求和 和的初值为0 
accumulate(vec.begin(),vec.end(), string(&amp;quot;&amp;quot;)); 
//求和 初值为空串 注意不可直接用字面值空串 其类型为const char* 无对应+操作
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意第三个参数和初值必须与求和的类型相容 也决定了最终返回类型&lt;/p&gt;
&lt;p&gt;比较两个序列中元素是否相同&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Equal(vec1.cbegin(),vec1.cend(), vec2.cbegin()); // 序列2至少和序列1一样长
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;接受谓词的算法&#34;&gt;接受谓词的算法&lt;/h2&gt;
&lt;p&gt;谓词是一个可调用的表达式 其结果是一个能用作条件的值&lt;br&gt;
标准库算法所使用的谓词分为两类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一元谓词(只接受单一参数)&lt;/li&gt;
&lt;li&gt;二元谓词(两个参数)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接受谓词参数的算法会对输入序列中元素调用谓词 因此这些元素必须能转换成谓词的参数类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Bool isshorter(const string&amp;amp;s1, const string&amp;amp;s2){ 
	return s1.size() &amp;lt; s2.size();
}
Sort(vec.begin(),vec.end(), isshorter);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意 这个sort传入的比较函数 以你返回true的类型排序&lt;br&gt;
即想升序排序 就使小于时为true 反之 大于时为true&lt;/p&gt;
&lt;h3 id=&#34;lambda表达式&#34;&gt;&lt;code&gt;lambda&lt;/code&gt;表达式&lt;/h3&gt;
&lt;p&gt;一个&lt;code&gt;lambda&lt;/code&gt;表达式表示一个可调用的代码单元&lt;br&gt;
可以理解为是&lt;strong&gt;一个未命名的内联函数&lt;/strong&gt; 本质上是&lt;strong&gt;函数对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与函数的不同在于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lambda表达式可以定义在函数内部&lt;/li&gt;
&lt;li&gt;不能使用默认参数&lt;/li&gt;
&lt;li&gt;且必须使用尾置返回来指定返回类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其形式为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;[capture list] (parameter list) -&amp;gt; return type {function body}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数列表和返回类型为可选项们，可以忽略&lt;/p&gt;
&lt;p&gt;若忽略返回类型&lt;br&gt;
如果函数只包含单一一条return语句 返回return语句对应类型&lt;br&gt;
否则返回void&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto f = [] {return 42;}; 
cout&amp;lt;&amp;lt;f()&amp;lt;&amp;lt;endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;strong&gt;捕获列表&lt;/strong&gt; &lt;code&gt;lambda&lt;/code&gt;表达式可以使用除了参数以外的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int sz=5; 
auto wc = find_if(vec.begin(),vec.end(), [sz](const string &amp;amp;a){return a.size()&amp;gt;= sz;}); 
//返回第一个长度不小于sz的元素
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当定义一个&lt;code&gt;lambda&lt;/code&gt;时 编译器生成一个与&lt;code&gt;lambda&lt;/code&gt;对应的未命名的类类型&lt;br&gt;
默认情况下 从lambda生成的类都包含对应该lambda所捕获的变量的数据成员 并在其对象创建时被初始化&lt;/p&gt;
&lt;p&gt;捕获列表默认是值传递 也可以使用引用传递&lt;br&gt;
但以引用方式捕获一个变量时 必须保证在&lt;code&gt;lambda&lt;/code&gt;执行时变量存在&lt;br&gt;
因此 尽可能避免捕获引用或指针以防止潜在的问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int v1 = 4; 
auto f = [&amp;amp;v1] {return v1;}; 
v1=0; 
cout&amp;lt;&amp;lt;f()&amp;lt;&amp;lt;endl; //结果为 0 因为传递的是引用 实际使用的是v1的值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;捕获列表中  &lt;code&gt;=&lt;/code&gt;表示值传递 &lt;code&gt;&amp;amp;&lt;/code&gt;表示引用传递&lt;br&gt;
&lt;code&gt;lambda&lt;/code&gt;可以通过隐式方式自动捕获所需变量 即只指出捕获方式 当函数内使用时会自动捕获外部变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;[&amp;amp;](){ sz = 1;} // 自动以引用传递方式捕获到变量sz
[=](){ int a = sz;} // 自动以值传递方式捕获到变量sz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同时也可以通过混用显式和隐式方式来对某一部分采用值传递捕获 另一部分采用默认方式隐式捕获&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;[=, reference_list](){} //reference list里的变量按引用捕获，其余的变量按值捕获，比如 [=, &amp;amp;a, &amp;amp;b] 表示 a 和 b 按引用，其余按值捕获
[&amp;amp;, identifier_list]( ){ } // identifier list里的变量按值捕获，其余的变量按引用捕获，比如 [&amp;amp;, a, b] 表示 a 和 b 按值，其余按引用捕获
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;其他标准库算法&#34;&gt;其他标准库算法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;for_each()&lt;/code&gt;接受一个可调用对象 并对输入序列中的每个元素调用此对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for_each(vec.begin(), vec.end(), [](const string &amp;amp;a){cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;endl;});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;bind()&lt;/code&gt;函数可以接受一个可调用对象 生成一个新的可调用对象来适应原对象的参数列表&lt;br&gt;
&lt;code&gt;bind&lt;/code&gt;定义在&lt;code&gt;functional&lt;/code&gt;头文件中&lt;br&gt;
通过形如&lt;code&gt;_n&lt;/code&gt;的占位符来表示传递给新对象的参数 &lt;code&gt;n&lt;/code&gt;表示参数的位置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool check(const string &amp;amp;a, int sz){
	return a.size()&amp;gt;= sz;
} 
auto check2= bind(check, _1, 6); 
String s= &amp;quot;hi&amp;quot;; 
check2(s);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更一般地 还可以通过&lt;code&gt;bind&lt;/code&gt;设置调用对象参数 或重新安排参数顺序&lt;br&gt;
假设&lt;code&gt;f&lt;/code&gt;是一个具有5个参数的函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto g= bind(f,a,b,_1,c,_2); 
//即g为一个两个参数的函数 其第一个参数输入到f的第3个参数 
//第二个参数输入到f的第5个参数 f的1 2 4参数分别绑定为a,b,c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt;是通过拷贝来传递参数&lt;br&gt;
若无法拷贝(如IO类)或需使用引用时 必须通过&lt;code&gt;ref()&lt;/code&gt;函数返回对应对象的引用&lt;br&gt;
同样该函数也定义在&lt;code&gt;functional&lt;/code&gt;头文件中&lt;/p&gt;
&lt;h2 id=&#34;特殊迭代器&#34;&gt;特殊迭代器&lt;/h2&gt;
&lt;p&gt;插入迭代器是一种向容器中添加元素的迭代器 如&lt;code&gt;back_inserter&lt;/code&gt;&lt;br&gt;
对该迭代器的赋值会调用push_back将一个具有该值的元素添加到容器中&lt;/p&gt;
&lt;p&gt;&lt;code&gt;back_inserter()&lt;/code&gt; &lt;code&gt;front_inserter()&lt;/code&gt; 分别插入元素到头尾&lt;br&gt;
&lt;code&gt;inserter()&lt;/code&gt; 接受第二个参数 将元素插入到给定的迭代器之前&lt;/p&gt;
&lt;p&gt;流迭代器可以从流对象中读取数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;istream_iterator&amp;lt;int&amp;gt; int_in(cin), eof;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样 可以使用泛型算法操作流迭代器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;cout&amp;lt;&amp;lt; accumulate(int_in, eof, 0) &amp;lt;&amp;lt;endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出流迭代器的赋值语句事实上将值写入到流中&lt;/p&gt;
&lt;p&gt;使用反向迭代器搜索后需要通过&lt;code&gt;.base()&lt;/code&gt;转换成正向 否则内容也会反向处理&lt;br&gt;
如 &amp;quot;last&amp;quot; 会变为 &amp;quot;tsal&amp;quot;&lt;/p&gt;
">[C++学习笔记] 泛型算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/INuaKbhdV/"" data-c="
          &lt;h2 id=&#34;stl介绍&#34;&gt;STL介绍&lt;/h2&gt;
&lt;p&gt;容器和泛型算法都属于STL模板库 其第一个实现版本是HP STL ，而且开放源代码&lt;/p&gt;
&lt;p&gt;现在最常用的是SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现 被Linux的C++编译器GCC所采用，SGI STL是开源软件&lt;/p&gt;
&lt;p&gt;P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的&lt;/p&gt;
&lt;h2 id=&#34;顺序容器类型&#34;&gt;顺序容器类型&lt;/h2&gt;
&lt;p&gt;一个容器就是一些特定类型对象的集合&lt;/p&gt;
&lt;p&gt;顺序容器提供了控制元素储存和访问顺序的能力 这种顺序只与元素加入容器的位置相对应&lt;/p&gt;
&lt;p&gt;顺序容器包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vector&lt;/code&gt;(可变大小 连续内存 随机访问 在尾部之外插入删除很慢)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string&lt;/code&gt;(类似于vector的字符专用版)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deque&lt;/code&gt;(队列 随机访问 在头尾插入删除快)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;list&lt;/code&gt;(双向链表 只能双向顺序访问 任何位置插入删除都快), &lt;code&gt;forward_list&lt;/code&gt;(单向链表)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array&lt;/code&gt;(固定大小数组 随机访问 不可插入删除)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;由于连续储存元素 保存在连续内存中 故可以快速随机访问&lt;br&gt;
但时在中间插入删除时必须 移动前/后的所有元素 因此非常耗时&lt;/p&gt;
&lt;p&gt;&lt;code&gt;deque&lt;/code&gt;与&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;类似 支持快速随机访问 中间位置添加删除慢&lt;br&gt;
但它在头尾插入删除都快 和链表速度差不多&lt;/p&gt;
&lt;p&gt;链表类型可以内存不连续 通过指针链接使任何位置的插入删除都很快 但是只能顺序访问遍历容器 还需要额外内存开销保存指针&lt;/p&gt;
&lt;p&gt;单向链表没有&lt;code&gt;size&lt;/code&gt;操作 访问 &lt;code&gt;list&lt;/code&gt; 容器中存储元素的方式很有限，即要么使用 front() 和 back() 成员函数，要么使用list 容器迭代器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;array&lt;/code&gt;数组类似于内置数组 但性能更优化 可以支持对象拷贝和赋值操作&lt;br&gt;
和内置数组类似 在构造时除了要指定元素类型 还必须指定数目&lt;br&gt;
默认是非空的 包含初始指定数目的元素 自动初始化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;array&amp;lt; int, 32&amp;gt; arr;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般来说 都使用vector作为顺序容器 除非有特别的理由&lt;/p&gt;
&lt;h2 id=&#34;构造函数&#34;&gt;构造函数&lt;/h2&gt;
&lt;p&gt;假设容器类型为C，容器的构造函数有:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;C c; //默认构造函数 构造空容器
C c1(c2); //拷贝构造
C c(b, d); // 以迭代器b和d指定的范围拷贝元素构造c
C c{a,b,d,e…}; //以列表初始化构造c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;顺序容器(不包括array)还特有两个构造方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;C c(n); //指定元素个数 自动值初始化
C c(n, t); //指定包含n个初始值为t的元素
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当以拷贝容器初始化构造或者拷贝赋值时 两个容器的类型和元素类型都必须相同&lt;br&gt;
注意 &lt;code&gt;string&lt;/code&gt; 和 &lt;code&gt;const char *&lt;/code&gt; 是不同的&lt;/p&gt;
&lt;p&gt;但是通过范围拷贝元素构造时可以不相同 只要可以通过转换得到就行&lt;/p&gt;
&lt;p&gt;并且顺序容器额外支持通过&lt;code&gt;.assign()&lt;/code&gt;将某个范围内不同但可转换的元素类型赋值给容器&lt;br&gt;
或者通过&lt;code&gt;assign&lt;/code&gt;用指定数目的相同值替换容器中的所有原有元素&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;a.assign(b.begin(), b.end());
a.assign(10,&amp;quot;hi&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;反向容器(不支持&lt;code&gt;forward_list&lt;/code&gt;)&lt;br&gt;
可以通过&lt;code&gt;reverse_iterator&lt;/code&gt;得到按逆序寻址元素的迭代器&lt;br&gt;
通过&lt;code&gt;c.rbegin()&lt;/code&gt; 和 &lt;code&gt;c.rend()&lt;/code&gt; 返回指向尾元素和首元素之前位置的迭代器 对应于&lt;code&gt;c.begin()&lt;/code&gt;和&lt;code&gt;c.end()&lt;/code&gt;&lt;br&gt;
同样 &lt;code&gt;c.crbegin()&lt;/code&gt; 和 &lt;code&gt;c.crend()&lt;/code&gt; 是对应的常量版本&lt;/p&gt;
&lt;p&gt;注意 迭代器范围是个左闭合区间&lt;code&gt; [begin,end)&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;指向的是尾元素(反向容器是首元素)之后的位置&lt;/p&gt;
&lt;h2 id=&#34;赋值操作&#34;&gt;赋值操作&lt;/h2&gt;
&lt;p&gt;所有容器都支持直接赋值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;c1=c2; 
c1= {a,e,d,…};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可通过&lt;code&gt;swap&lt;/code&gt;函数交换容器的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;c1.swap(c2); 
swap(c1,c2); 
//两种方法都行 最好使用后一种
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;swap&lt;/code&gt;时并不真正移动容器中元素的位置(&lt;code&gt;array&lt;/code&gt;除外)&lt;br&gt;
而是交换容器的内部结构 因此都可以在常数时间内完成&lt;br&gt;
对&lt;code&gt;array&lt;/code&gt;使用&lt;code&gt;swap&lt;/code&gt;时 会真正交换它们的元素 因此耗时与&lt;code&gt;array&lt;/code&gt;中元素的数目成正比&lt;/p&gt;
&lt;p&gt;容器可通过&lt;code&gt;.size()&lt;/code&gt;返回当前大小&lt;br&gt;
&lt;code&gt;.max_size()&lt;/code&gt;返回可保存的最大元素数目&lt;br&gt;
&lt;code&gt;.empty()&lt;/code&gt;返回是否为空&lt;/p&gt;
&lt;h2 id=&#34;迭代器访问&#34;&gt;迭代器访问&lt;/h2&gt;
&lt;p&gt;所有容器的迭代器都支持&lt;code&gt;++&lt;/code&gt;和&lt;code&gt;*&lt;/code&gt;&lt;br&gt;
并通过解引用操作&lt;code&gt;*&lt;/code&gt;来访问容器元素&lt;/p&gt;
&lt;p&gt;只有单向链表的迭代器不支持递减操作 &lt;code&gt;--&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于反向容器迭代器而言 &lt;code&gt;++&lt;/code&gt;意味着访问上一个元素 &lt;code&gt;--&lt;/code&gt;同理&lt;/p&gt;
&lt;p&gt;支持随机访问的容器(&lt;code&gt;string&lt;/code&gt; &lt;code&gt;vector&lt;/code&gt; &lt;code&gt;deque&lt;/code&gt; &lt;code&gt;array&lt;/code&gt;)的迭代器才支持部分算术运算&lt;/p&gt;
&lt;p&gt;利用&lt;code&gt;auto&lt;/code&gt;与&lt;code&gt;begin&lt;/code&gt;或&lt;code&gt;end&lt;/code&gt;结合使用时 可以根据容器类型自动获得对应版本的迭代器 而不用显式指定类型&lt;br&gt;
当然 也可以用&lt;code&gt;cbegin&lt;/code&gt;或&lt;code&gt;cend&lt;/code&gt;来显式指定&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;auto it1 = a.begin(); // it1的类型取决于a是否是常量 自适应
auto it2 = a.cbegin(); // it2是const_iterator
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;成员函数&#34;&gt;成员函数&lt;/h2&gt;
&lt;p&gt;所有容器都支持 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt;&lt;br&gt;
除了无序关联容器以外 都支持关系运算符 &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;br&gt;
但关系运算符两侧必须是同一种元素类型的同一种容器&lt;/p&gt;
&lt;p&gt;比较时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若容器大小和元素内容都相同 则相等;&lt;/li&gt;
&lt;li&gt;若容器大小不同 但容器小的那个是大的前缀子序列 则较小容器小于较大容器;&lt;/li&gt;
&lt;li&gt;前两者都不符合时 比较第一个不同的元素大小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意 &lt;strong&gt;必须容器中的元素都定义了关系运算&lt;/strong&gt; 容器才能使用关系运算&lt;/p&gt;
&lt;p&gt;顺序容器通过 &lt;code&gt;push_back()&lt;/code&gt; &lt;code&gt;push_front()&lt;/code&gt; &lt;code&gt;insert()&lt;/code&gt; 来插入拷贝的元素 (单链表不支持&lt;code&gt;push_back()&lt;/code&gt;和&lt;code&gt;insert()&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;对应的新标准有 &lt;code&gt;emplace_back()&lt;/code&gt; &lt;code&gt;emplace_front()&lt;/code&gt; &lt;code&gt;emplace()&lt;/code&gt;&lt;br&gt;
来插入根据输入参数新构造的对象&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;front()&lt;/code&gt; 和&lt;code&gt;back()&lt;/code&gt; 可以直接返回首元素和尾元素的引用&lt;/p&gt;
&lt;p&gt;下标操作&lt;code&gt;[n]&lt;/code&gt;等价于&lt;code&gt;at(n)&lt;/code&gt; 但是&lt;code&gt;at&lt;/code&gt;函数会在下标越界时抛出异常&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;pop_back()&lt;/code&gt; &lt;code&gt;pop_front()&lt;/code&gt; &lt;code&gt;erase()&lt;/code&gt; 来删除容器中的元素&lt;br&gt;
&lt;code&gt;clear()&lt;/code&gt;可以清空容器中的元素&lt;br&gt;
单链表不支持&lt;code&gt;pop_back()&lt;/code&gt;和 &lt;code&gt;erase()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;resize()&lt;/code&gt;可以改变容器大小 当前大小大于要求则会删除多余元素 小于时则会添加新元素到容器尾部&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;c.resize(n); 
c.resize(n, t); //对于新添加的元素可以指定值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单向链表比较特殊 我们必须提供其前驱来删除或插入对应位置的元素&lt;br&gt;
其使用函数也不同 &lt;code&gt;before_begin()&lt;/code&gt; 对应于普通的&lt;code&gt;begin()&lt;/code&gt; 返回的是首元素之前的位置或者说头指针&lt;br&gt;
插入元素 &lt;code&gt;insert_after(p, …)&lt;/code&gt; &lt;code&gt;emplace_after(p,…)&lt;/code&gt; 在&lt;code&gt;p&lt;/code&gt;迭代器之后的位置插入元素&lt;br&gt;
删除元素 &lt;code&gt;erase_after()&lt;/code&gt; 同理&lt;/p&gt;
&lt;p&gt;添加或删除容器中的元素可能会导致指向容器中元素的指针 迭代器和引用失效&lt;br&gt;
在改变容器大小的循环中 必须保证每个循环内都更新迭代器&lt;br&gt;
&lt;code&gt;insert&lt;/code&gt;和&lt;code&gt;erase&lt;/code&gt;操作本身就返回迭代器 容易更新&lt;br&gt;
而使用&lt;code&gt;end&lt;/code&gt;时 必须每次都重新调用更新 保存尾迭代器的值是一个坏主意&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;capacity()&lt;/code&gt;可以获取当前&lt;code&gt;vector&lt;/code&gt;或&lt;code&gt;string&lt;/code&gt;分配的空间&lt;br&gt;
&lt;code&gt;reserve(n)&lt;/code&gt;可以主动申请分配至少n个元素的空间&lt;br&gt;
只有当当前容量不足以添加新的元素时 才会申请分配新的空间&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;对象可以通过&lt;code&gt;substr()&lt;/code&gt;获取指定位置的子串&lt;br&gt;
通过&lt;code&gt;find()&lt;/code&gt;可以搜索指定字串(大小写敏感) &lt;code&gt;rfind()&lt;/code&gt;逆向搜索&lt;br&gt;
通过&lt;code&gt;append()&lt;/code&gt;可以追加字符串&lt;br&gt;
通过&lt;code&gt;stoi()&lt;/code&gt;,&lt;code&gt;stol()&lt;/code&gt;,&lt;code&gt;stod()&lt;/code&gt;,&lt;code&gt;stoul&lt;/code&gt;,&lt;code&gt;stof()&lt;/code&gt;等函数实现&lt;code&gt;string&lt;/code&gt;到其他类型如&lt;code&gt;int&lt;/code&gt; &lt;code&gt;long&lt;/code&gt; &lt;code&gt;double&lt;/code&gt; &lt;code&gt;unsigned long&lt;/code&gt;等的转换&lt;br&gt;
通过&lt;code&gt;to_string()&lt;/code&gt;可以实现其他类型到string的转换&lt;/p&gt;
&lt;h2 id=&#34;适配器&#34;&gt;适配器&lt;/h2&gt;
&lt;p&gt;适配器是一种机制 使得某个容器类型看起来像另一种类型&lt;/p&gt;
&lt;p&gt;如&lt;code&gt;stack&lt;/code&gt; &lt;code&gt;queue&lt;/code&gt; 和 &lt;code&gt;priority_queue&lt;/code&gt; 分别是栈, 队列和优先队列适配器&lt;br&gt;
它们定义了对应的操作 并且只能执行对应操作 而不能执行其底层容器的操作&lt;br&gt;
可以自己定义适配器的底层容器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Stack&amp;lt;int, vector&amp;lt;int&amp;gt;&amp;gt; dp; 
//注意 stack 和 queue在缺省状态下都是采用deque为底层容器的
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;priority_queue&lt;/code&gt; 其实就是一个披着队列外衣的堆&lt;br&gt;
因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。&lt;br&gt;
优先级队列内部元素是自动依照元素的权值排列。&lt;/p&gt;
&lt;p&gt;缺省情况下&lt;code&gt;priority_queue&lt;/code&gt;利用&lt;code&gt;max-heap&lt;/code&gt;（大顶堆）完成对元素的排序，这个大顶堆是以&lt;code&gt;vector&lt;/code&gt;为表现形式的complete binary tree（完全二叉树）。&lt;/p&gt;
&lt;p&gt;堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。&lt;/p&gt;
&lt;p&gt;priority_queue 模板有 3 个参数，其中两个有默认的参数；第一个参数是存储对象的类型，第二个参数是存储元素的底层容器，第三个参数是函数对象类（注意一定是个类）&lt;/p&gt;
&lt;p&gt;function 头文件中定义了 greater&lt;T&gt;，可以用来作为模板的最后一个参数对元素排序，最小元素会排在队列前面。当然，如果指定模板的最后一个参数，就必须提供另外的两个模板类型参数。&lt;/p&gt;
&lt;p&gt;例如我们在写快排的cmp函数的时候，&lt;code&gt;return left&amp;gt;right &lt;/code&gt;就是从大到小，&lt;code&gt;return left&amp;lt;right&lt;/code&gt; 就是从小到大。&lt;br&gt;
但优先级队列的定义正好反过来了 &lt;code&gt;return left&amp;gt;right&lt;/code&gt; 就是小堆 &lt;code&gt;return left&amp;lt;right&lt;/code&gt; 就是大堆&lt;/p&gt;
&lt;p&gt;适配器操作 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;push&lt;/code&gt;对应&lt;code&gt;push_back&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop&lt;/code&gt;对应&lt;code&gt;pop_back()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;front()&lt;/code&gt;和&lt;code&gt;back()&lt;/code&gt;是一致的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;栈里面的元素在内存中是连续分布的么？&lt;/strong&gt;&lt;br&gt;
这个问题有两个陷阱：&lt;br&gt;
陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中是不是连续分布。&lt;br&gt;
陷阱2：缺省情况下，默认底层容器是&lt;code&gt;deque&lt;/code&gt;，那么&lt;code&gt;deque&lt;/code&gt;的在内存中的数据分布是什么样的呢？ 答案是：不连续的,&lt;code&gt;deque&lt;/code&gt;的底层实现和 &lt;code&gt;vector&lt;/code&gt; 容器采用连续的线性空间不同，&lt;code&gt;deque&lt;/code&gt; 容器存储数据的空间是由一段一段等长的连续空间构成，但各段空间之间并不一定是连续的，可以位于在内存的不同区域。&lt;/p&gt;
&lt;p&gt;为了管理这些连续空间，&lt;code&gt;deque&lt;/code&gt; 容器用数组（数组名假设为 &lt;code&gt;map&lt;/code&gt;）存储着各个连续空间的首地址。也就是说，&lt;code&gt;map&lt;/code&gt; 数组中存储的都是指针，指向那些真正用来存储数据的各个连续空间（如图 1 所示）。&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1687836415894.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
也就是说&lt;code&gt;deque&lt;/code&gt;底层是一个动态开辟的二维数组，内部每个一维数组长度相等，不够时就开辟一个新的一维数组。&lt;/p&gt;
&lt;p&gt;通过建立 &lt;code&gt;map&lt;/code&gt; 数组，&lt;code&gt;deque&lt;/code&gt; 容器申请的这些分段的连续空间就能实现“整体连续”的效果。&lt;br&gt;
换句话说，当&lt;code&gt;deque&lt;/code&gt; 容器需要在头部或尾部增加存储空间时，它会申请一段新的连续空间，同时在 &lt;code&gt;map&lt;/code&gt; 数组的开头或结尾添加指向该空间的指针，由此该空间就串接到了 &lt;code&gt;deque&lt;/code&gt; 容器的头部或尾部。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt; 数组第一维初始值为2（一开始有2行），扩容时以2倍的方式进行扩容（2行变4行），扩容后，原来第二维的数组从新的二维数组的第一位下标&lt;code&gt;oldsize / 2&lt;/code&gt;的位置开始存放（原内容复制到二维数组的第1、2行，从0行开始），上下都预留相同的空行，方便支持&lt;code&gt;deque&lt;/code&gt;首尾元素的添加。&lt;/p&gt;
">[C++学习笔记] 顺序容器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/RzcXm-PBm/"" data-c="
          &lt;p&gt;&lt;code&gt;wcin&lt;/code&gt; &lt;code&gt;wcout&lt;/code&gt; &lt;code&gt;wcerr&lt;/code&gt; 是对应标准流&lt;code&gt;cin&lt;/code&gt;，&lt;code&gt;cout&lt;/code&gt;，&lt;code&gt;cerr&lt;/code&gt;的宽字符版本的流对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不能对流(IO)对象赋值或拷贝&lt;/strong&gt; 因此也不能将返回类型或者形参类型设置成流类型&lt;/p&gt;
&lt;p&gt;进行IO操作的函数通常&lt;strong&gt;用引用方式传递和返回流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IO状态使用3位比特的条件状态表示:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;条件状态&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;二进制码&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;状态含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;badbit&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;001&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;流崩溃 系统级错误 如不可恢复的读写错误 此时流已无法再使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;eofbit&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;010&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文件结束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;failbit&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;100&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一个IO操作失败 可恢复错误 如读取了错误类型的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;goodbit&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;000&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;成功 表示流未发生错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;当到达文件结束位置 &lt;code&gt;eofbit&lt;/code&gt;和&lt;code&gt;failbit&lt;/code&gt;都会被置位(设为1)&lt;br&gt;
利用流的函数可以返回状态:&lt;br&gt;
&lt;code&gt;s.eof()&lt;/code&gt; &lt;code&gt;s.fail()&lt;/code&gt; &lt;code&gt;s.bad()&lt;/code&gt; &lt;code&gt;s.good()&lt;/code&gt;&lt;br&gt;
&lt;code&gt;s.rdstate()&lt;/code&gt; 可以返回完整的条件状态&lt;br&gt;
&lt;code&gt;s.setstate()&lt;/code&gt; 可以设置条件状态&lt;/p&gt;
&lt;p&gt;通过输出缓冲可以将多个输出操作组合为单一的设备写操作 从而节省大量IO耗时&lt;/p&gt;
&lt;p&gt;导致缓冲刷新的原因:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序正常结束 作为&lt;code&gt;main&lt;/code&gt;函数中&lt;code&gt;return&lt;/code&gt;的一部分 缓冲刷新&lt;/li&gt;
&lt;li&gt;缓冲区满&lt;/li&gt;
&lt;li&gt;使用操纵符
&lt;ul&gt;
&lt;li&gt;比如&lt;code&gt;endl&lt;/code&gt;(额外换行) &lt;code&gt;flush&lt;/code&gt;(无额外字符) &lt;code&gt;ends&lt;/code&gt;(额外空格)&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;unitbuf&lt;/code&gt;操纵符会使得接下来每次写操作都执行&lt;code&gt;flush&lt;/code&gt;操作&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;nounitbuf&lt;/code&gt;则重置流恢复正常刷新机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读写被关联的流时, 关联到的流的缓冲区会被刷新&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当程序崩溃时 输出缓冲区不会刷新 因此需要确认最后输出的数据是否正确 因为可能尚未打印&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;.tie()&lt;/code&gt;函数可以关联流 &lt;code&gt;cin.tie(&amp;amp;cout);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;打开文件流&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//构造文件流对象时同时打开
fstream sin(str);
//或者先构造流再打开
fstream sin;
in.open(str)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对一个已经打开的 文件流调用&lt;code&gt;open&lt;/code&gt;会失败&lt;/p&gt;
&lt;p&gt;文件模式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;in&lt;/code&gt; 只读&lt;/li&gt;
&lt;li&gt;&lt;code&gt;out&lt;/code&gt; 只写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;app&lt;/code&gt; 追加模式, 每次写操作时定位至文件末尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ate&lt;/code&gt; 打开文件后立刻定位到文件末尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;binary&lt;/code&gt; 二进制形式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trunc&lt;/code&gt; 截断文件(即删除原有内容)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;保存ofstream打开的文件中已有数据的唯一方式是显式指定文件模式为&lt;code&gt;app&lt;/code&gt;或&lt;code&gt;in&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当需要处理整行文本时 部分工作需要处理行内的单词&lt;br&gt;
通常可以使用&lt;code&gt;string&lt;/code&gt;流 &lt;code&gt;istringstream &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当我们需要逐步构造输出 希望最后一起打印时 &lt;code&gt;ostringstream&lt;/code&gt;很有用  可以将其作为类似缓存用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ostringstream sout;
for(int i=0;i&amp;lt;10;i++){
	sout&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;str(i);
}
cout&amp;lt;&amp;lt;sout.str()&amp;lt;&amp;lt;endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;像流一样使用它 通过&lt;code&gt;.str()&lt;/code&gt;可以访问它的字符串&lt;/p&gt;
">[C++学习笔记] IO</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/xeyGHxclb/"" data-c="
          &lt;p&gt;类的基本思想是&lt;strong&gt;数据抽象&lt;/strong&gt;和&lt;strong&gt;封装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据抽象&lt;/strong&gt;是一种依赖于接口和实现分离的编程技术&lt;br&gt;
类的接口包括用户所能执行的操作 类的实现包括类的数据成员、实现接口的函数体以及定义类所需的各类私有函数&lt;/p&gt;
&lt;p&gt;封装实现了类的接口和实现的分离。封装后的类隐藏了实现的细节，用户只能使用接口而无法访问实现部分&lt;/p&gt;
&lt;h2 id=&#34;类的成员&#34;&gt;类的成员&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义在类内部的函数是隐式的内联函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;成员函数通过一个名为&lt;code&gt;this&lt;/code&gt;的隐式参数(类型为常量指针)来访问调用它的对象&lt;br&gt;
当调用一个成员函数时 用请求该函数的对象地址初始化&lt;code&gt;this&lt;/code&gt;&lt;br&gt;
eg. &lt;code&gt;total.get()&lt;/code&gt;等价于&lt;code&gt;sales_data:: get(&amp;amp;total)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;因此 我们可以直接在成员函数内部调用&lt;code&gt;this&lt;/code&gt; 并且也不能显示声明一个名为&lt;code&gt;this&lt;/code&gt;的形参&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int get() {
	retrun this-&amp;gt;num;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要定义一个常量对象使用的函数 则应该为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int get() const{
	return this-&amp;gt;num;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过后置的&lt;code&gt;const&lt;/code&gt;修改隐式参数&lt;code&gt;this&lt;/code&gt;的类型&lt;/p&gt;
&lt;p&gt;编译器处理类时 先编译类成员声明 再编译类成员函数体(如果有的话)&lt;br&gt;
因此 成员体函数可以随意使用类中的其他成员而无须在意出现次序&lt;/p&gt;
&lt;h2 id=&#34;构造函数&#34;&gt;构造函数&lt;/h2&gt;
&lt;p&gt;类的构造函数没有返回类型 也不能被声明成&lt;code&gt;const&lt;/code&gt;&lt;br&gt;
只有当没有显式地定义构造函数的时候 编译器才会隐式地定义一个合成的默认构造函数:&lt;br&gt;
这个函数对有初始值的成员使用初始值初始化,对未定义初始值的采用默认初始化&lt;/p&gt;
&lt;p&gt;如果我们定义了其他构造函数 那么也必须显式定义一个默认构造函数 在C++中可以用 =default 来执行默认操作&lt;br&gt;
eg. &lt;code&gt;Sales_data() = default&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;构造函数可以通过初始值列表为成员初始化&lt;br&gt;
其初始化顺序与这些成员在类中定义的顺序一致  与在初始化列表中的顺序无关&lt;br&gt;
这与通过构造函数赋值的区别在于 部分类型不能赋值 必须初始化 如引用 或者常量类型变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Class Sales_data{
	public: 
		Sales_data(int a , double p) ;
	private: 
		const int bookno; double &amp;amp;revenue;
};
Sales_data(int a , double p): bookno(a), revenue(p) { }
Sales_data(int a , double p){ 
	bookno = a; 
	revenue = p 
} //错误 引用和常量都必须在初始化时赋值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C++还允许委托构造函数 将初始值列表输入给另一个已定义的构造函数 先执行被委托的构造函数代码 再执行委托函数体内的代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Sales_data(int a , double p) ; 
Sales_data(): Sales_data(0, 0) { }
Sales_data(int a): Sales_data(a, 0) { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当构造函数只接受一个实参时 这个构造函数&lt;strong&gt;事实上定义了从该实参类型转换为此类类型的隐式转换机制&lt;/strong&gt; 也叫做转换构造函数&lt;br&gt;
注意 编译器&lt;strong&gt;只会自动执行一步类型转换&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Sales_data(string &amp;amp;s): bookno(s){} 
Sales_data:: combine(Sales_data &amp;amp;a, Sales_data&amp;amp; b){}

String str = &amp;quot;123&amp;quot;; 
Sales_data a;
a.combine(str); //成立 string对象会通过构造函数隐式转换成Sales_data类型
a.combine(&amp;quot;123&amp;quot;); //错误 字符串字面值首先需隐式转换为string对象 再转换为Sales_data类型 不止一步
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是 可以通过&lt;code&gt;explicit&lt;/code&gt;关键字抑制这种隐式转换 在开头添加了这个关键字的构造函数不会被用于隐式转换&lt;br&gt;
但同时也不能进行拷贝形式的初始化了 只能直接初始化&lt;br&gt;
不过我们仍然可以通过显示调用来强制类型转换&lt;/p&gt;
&lt;p&gt;如果没有定义类的拷贝 赋值和析构函数的话 编译器会默认合成&lt;br&gt;
编译器生成的函数将对类对象的每个成员都执行拷贝 赋值和销毁操作&lt;/p&gt;
&lt;h2 id=&#34;访问权限控制&#34;&gt;访问权限控制&lt;/h2&gt;
&lt;p&gt;通过访问说明符 &lt;code&gt;public&lt;/code&gt; 和 &lt;code&gt;private&lt;/code&gt; 可以加强封装性 访问说明符的有效范围直到出现下一个访问&lt;br&gt;
说明符或者类结束&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class&lt;/code&gt;和&lt;code&gt;struct&lt;/code&gt;关键字定义的&lt;strong&gt;唯一区别就是默认访问权限不同&lt;/strong&gt;&lt;br&gt;
若在未定义访问说明符之前定义成员 &lt;code&gt;struct&lt;/code&gt;默认是&lt;code&gt;public&lt;/code&gt; &lt;code&gt;class&lt;/code&gt;默认是&lt;code&gt;private&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;类可以通过在类内将其他类或函数使用&lt;code&gt;friend&lt;/code&gt;关键字声明为友元来允许其他类或者函数访问它的非公有成员&lt;br&gt;
友元的声明仅仅指定了访问的权限而非真正的函数声明 如果希望调用该函数 &lt;strong&gt;还需在友元声明之外在类外单独进行一次声明&lt;/strong&gt;&lt;br&gt;
友元函数的定义可以在类内(属于隐式内联函数) 也可以在类外&lt;br&gt;
但是&lt;strong&gt;即使是在类内定义了友元函数 仍然需要在类外声明后才能使用&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1687780959106.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果一个类指定了友元类 则有友元类的成员可以访问此类包括非公有成员在内的所有成员&lt;br&gt;
也可以单独指定某个类的成员为友元 如 &lt;code&gt;friend void windows_mgr:: clear(screen index);&lt;/code&gt;&lt;br&gt;
重载函数被声明成友元必须每个单独声明 否则只有被声明的那个版本为友元&lt;/p&gt;
&lt;p&gt;友元不具备传递性&lt;/p&gt;
&lt;p&gt;封装的优点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确保用户代码不会无意间破坏封装对象的状态&lt;/li&gt;
&lt;li&gt;被封装的类的具体实现细节可以随时改变而无需调整用户级别的代码&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;常量成员与静态成员&#34;&gt;常量成员与静态成员&lt;/h2&gt;
&lt;p&gt;可以通过&lt;code&gt;mutable&lt;/code&gt;关键字将一个成员声明为可变数据成员&lt;br&gt;
一个可变数据成员永远不会是&lt;code&gt;const&lt;/code&gt; 即使它是一个&lt;code&gt;const&lt;/code&gt;对象的成员&lt;br&gt;
并且即便是&lt;code&gt;const&lt;/code&gt;成员函数也可以改变一个可变成员的值&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;const&lt;/code&gt;成员函数如果以引用的方式返回&lt;code&gt;*this&lt;/code&gt; 那么返回类型是常量引用&lt;br&gt;
由于非常量类型的成员函数对于常量对象是不可用的 所以我们需要对成员函数声明&lt;code&gt;const&lt;/code&gt;重载函数来使得可适用&lt;/p&gt;
&lt;p&gt;当我们提供一个类内初始值时 必须以符号&lt;code&gt;=&lt;/code&gt;或者花括号&lt;code&gt;{ }&lt;/code&gt;表示&lt;/p&gt;
&lt;p&gt;类的非静态成员类型不能是类本身 因为只有类被定义以后才能知道所需的空间&lt;br&gt;
但可以是指向类的指针或者引用&lt;/p&gt;
&lt;p&gt;不过静态成员类型可以是类本身&lt;/p&gt;
&lt;p&gt;如果使用类中定义的别名作为成员函数的返回类型 在类外定义时必须使用类作用域说明 因为返回类型定义在函数之前&lt;br&gt;
但是函数中使用类中定义时 无需作用域符说明 因为函数已经被声明在作用域中了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;windows_mgr:: screenindex windows_mgr::addscreeen( ){ 
	screenindex a= 1; 
}

int windows_mgr:: addscreeen( ){ 
	screenindex a= 1; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在类中定义了与全局作用域同名的变量 那么在类的成员函数中将把外部全局作用域的变量隐藏&lt;/p&gt;
&lt;h2 id=&#34;聚合类&#34;&gt;聚合类&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;聚合类定义&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有成员都是public&lt;/li&gt;
&lt;li&gt;没有任何构造函数&lt;/li&gt;
&lt;li&gt;没有类内初始值&lt;/li&gt;
&lt;li&gt;没有基类或virtual函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法&lt;/p&gt;
&lt;p&gt;类的静态成员不与任何对象绑定 也不包含&lt;code&gt;this&lt;/code&gt;指针&lt;br&gt;
类的静态成员可以通过类作用域直接访问 也可以通过某个类的对象访问&lt;/p&gt;
&lt;p&gt;应该在类的外部定义和初始化每个静态成员 而不能在构造函数内初始化 除非是作为常量静态&lt;br&gt;
成员 在声明时直接用常量表达式初始化&lt;br&gt;
但即使一个常量静态成员在内部被初始化了 通常情况下也应该在类的外部定义一下该成员&lt;br&gt;
在类的外部定义静态成员时 不能重复static关键字 该关键字只能出现在类内的声明语句中&lt;/p&gt;
&lt;p&gt;静态成员可以是本身所属类的类型 也可以作为默认实参 而非静态两者都不行&lt;/p&gt;
&lt;p&gt;前向声明: 对尚未定义的名字的声明, 通常用于表示位于类定义之前的类声明&lt;/p&gt;
&lt;p&gt;不完全类型: 已经声明但尚未定义的类型 不完全类型不能用于声明变量或者类的非静态成员&lt;br&gt;
但可以用于定义指针和引用&lt;/p&gt;
">[C++学习笔记] 类</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/WGwH_yMC1/"" data-c="
          &lt;p&gt;HyperSCI学习混杂物的表征，用超图神经网络模块对高阶干扰进行建模，然后用学到的表征预测每个实例的潜在结果&lt;/p&gt;
&lt;h2 id=&#34;individual-treatment-effect-ite&#34;&gt;individual treatment effect (ITE)&lt;/h2&gt;
&lt;p&gt;对于超图H上的每个节点&lt;code&gt;i&lt;/code&gt;，个体治疗效果（&lt;code&gt;ITE&lt;/code&gt;）由对应于&lt;code&gt;ti=1&lt;/code&gt;和&lt;code&gt;ti=0&lt;/code&gt;的潜在结果之间的差定义。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ti&lt;/code&gt;表示节点&lt;code&gt;i&lt;/code&gt;分配的治疗方案 (二元变量0或1,代表采不采用), 即用保持环境不变情况下 采取或不采取治疗方案的效果之差代表&lt;code&gt;ITE&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;超图学习&#34;&gt;超图学习&lt;/h2&gt;
&lt;p&gt;通过多层感知器（MLP）模块将节点特征&lt;code&gt;xi&lt;/code&gt;编码到一个潜在空间，即&lt;code&gt;zi=MLP(xi)&lt;/code&gt;。这就产生了一组表征&lt;code&gt;Z&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;将混杂物表示（&lt;code&gt;Z&lt;/code&gt;）、治疗分配（&lt;code&gt;T&lt;/code&gt;）和超图（&lt;code&gt;H&lt;/code&gt;）上的关系信息作为输入，以捕捉每个个体的高阶干扰。&lt;/p&gt;
&lt;p&gt;更具体地说，我们通过超图模块学习一个转换函数&lt;code&gt;Ψ&lt;/code&gt;，以生成每个节点 &lt;code&gt;i&lt;/code&gt; 的干扰表示&lt;/p&gt;
&lt;p&gt;这个模块由超图卷积网络和超图注意机制实现。卷积层可以通过超边界传递干扰，利用超图关注机制来学习每个节点和包含该节点的相应超边缘的关注权重&lt;/p&gt;
&lt;p&gt;使用现实世界网络生成的半合成数据，仅保留不超过50个节点的超边，具有大尺寸节点的超边界通常意义不大（Austin R Benson, Rediet Abebe, Michael T Schaub, Ali Jadbabaie, and Jon Kleinberg. 2018. Simplicial closure and higher-order link prediction. Proceedings of the National Academy of Sciences 115, 48 (2018), E11221–E11230.）&lt;/p&gt;
">[论文阅读] Learning Causal Effects on Hypergraphs</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/PQL9jjfdw/"" data-c="
          &lt;h2 id=&#34;函数调用&#34;&gt;函数调用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;()&lt;/code&gt;是调用运算符&lt;/p&gt;
&lt;p&gt;函数调用完成两项工作:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用实参初始化对应形参 隐式地定义并初始化它的形参&lt;/li&gt;
&lt;li&gt;将控制权转移给被调函数 此时 主调函数被中断 被调函数开始执行&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;传参&#34;&gt;传参&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;int get()&lt;/code&gt; 和 &lt;code&gt;int get(void)&lt;/code&gt; 都可以表示无参数 后者为c风格&lt;/p&gt;
&lt;p&gt;诸如形参等&lt;strong&gt;只存在于块执行期间的对象&lt;/strong&gt;称之为&lt;strong&gt;自动对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;局部静态对象在第一次执行其定义语句时进行初始化 直至程序终止才被销毁&lt;/p&gt;
&lt;p&gt;C++中尽量使用引用传递来访问函数外部的对象 而不要用指针&lt;br&gt;
事实上指针作为形参仍旧是值传递而非引用传递&lt;/p&gt;
&lt;p&gt;传引用时 无需传地址 直接传对象就可 将自动转换成引用&lt;br&gt;
类似于引用定义时也是无需取地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void re(int &amp;amp;a){
    ......
} 
...
int j=0; 
re(j);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用引用传递可以避免拷贝耗时&lt;/p&gt;
&lt;p&gt;在无需修改值的时候 最好声明为常量引用形参&lt;br&gt;
否则可能会导致错误 因为非常量可以转常量 而常量不可转非常量&lt;/p&gt;
&lt;p&gt;可以通过引用形参的方式 使函数一次返回多个值&lt;br&gt;
如 &lt;code&gt;int(const string &amp;amp;s, int &amp;amp; num) &lt;/code&gt;可以通过&lt;code&gt;num&lt;/code&gt;额外返回一个值&lt;/p&gt;
&lt;p&gt;带参数的main函数 &lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt;&lt;br&gt;
&lt;code&gt;argc&lt;/code&gt;表示参数个数 &lt;code&gt;argv&lt;/code&gt;是参数字符串 其中&lt;code&gt;argv[0]&lt;/code&gt;表示程序名 从&lt;code&gt;argv[1]&lt;/code&gt;开始才是向命令行传递的参数&lt;/p&gt;
&lt;h2 id=&#34;可变参数&#34;&gt;可变参数&lt;/h2&gt;
&lt;p&gt;函数若要传递未知个数但类型一致的参数 可以使用&lt;code&gt;initializer_list&amp;lt;&amp;gt;&lt;/code&gt;&lt;br&gt;
但调用时需将所有参数用大括号&lt;code&gt;{}&lt;/code&gt; 括起来&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void error_m(int a, initializer_list&amp;lt;string&amp;gt; er) 
error_m( 1, { &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot; } ); //调用时 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;省略符&lt;code&gt;…&lt;/code&gt;仅用于访问某些特殊的c代码设置的, 使用了varargs的c标准库功能 通常不用于其他&lt;br&gt;
C++允许定义形参个数和类型不确定的函数，不确定的形参可以使用省略号&lt;code&gt;…&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用可变参数函数时注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;省略号必须在参数列表的末尾。&lt;/li&gt;
&lt;li&gt;运行时，才能确认参数的具体个数与类型。&lt;/li&gt;
&lt;li&gt;只能顺序访问可变参数，无法后退访问&lt;/li&gt;
&lt;li&gt;无法提供任何安全性保证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果使用省略号，传递可变数量的参数时需要使用&lt;code&gt;va_arg&lt;/code&gt;、&lt;code&gt;va_start&lt;/code&gt;、&lt;code&gt;va_end&lt;/code&gt; 和 &lt;code&gt;va_list&lt;/code&gt;等宏，定义在&lt;cstdarg&gt;中（c中定义在&amp;lt;stdarg.h&amp;gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;va_start(args,paramN)&lt;/code&gt; 令对可变函数参数的访问可行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数为va_list类型的变量&lt;/li&gt;
&lt;li&gt;第二个参数为&amp;quot;...&amp;quot;前最后一个参数&lt;/li&gt;
&lt;li&gt;将args初始化为指向可变参数列表第一个参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;va_arg(args,type)&lt;/code&gt; 访问下一个可变函数参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数为va_list类型的变量&lt;/li&gt;
&lt;li&gt;第二个参数是返回值的类型&lt;/li&gt;
&lt;li&gt;调用va_arg获取当前的参数，并自动更新指向下一个可变参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;va_end(args)&lt;/code&gt;  结束可变参数函数的遍历。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;释放va_arg变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdarg&amp;gt;
using namespace std;
 
//求和函数
int add(int firstParam, ...)
{
	va_list arg_ptr;
	int sum = 0;
	int nArgValue;
	sum += firstParam;
	va_start(arg_ptr, firstParam);
	do
	{
		nArgValue = va_arg(arg_ptr, int);
		sum += nArgValue;
	} while (nArgValue != 0);
	va_end(arg_ptr);
	return sum;
}
 
int main()
{
	cout &amp;lt;&amp;lt; add(1, 2, 3, 0) &amp;lt;&amp;lt; endl;       //运行结果：6
	system(&amp;quot;pause&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;返回值&#34;&gt;返回值&lt;/h2&gt;
&lt;p&gt;void函数会隐式地执行&lt;code&gt;return;&lt;/code&gt; 语句 也可以手动使用&lt;code&gt;return;&lt;/code&gt; 提前退出&lt;/p&gt;
&lt;p&gt;函数返回值是通过&lt;strong&gt;生成的临时变量储存值&lt;/strong&gt; 然后&lt;strong&gt;将该临时变量拷贝至返回点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数返回引用时和使用形参引用是一样的 返回的仅仅是对象的别名 不管是调用还是返回结果都不会拷贝对象&lt;/p&gt;
&lt;p&gt;函数返回值是个非常量引用时返回的是个左值 可以向其他左值一样使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;Char &amp;amp;get_fisrst(string &amp;amp;str){ 
    return str[0];
} 
get_fisrst(s) = &#39;a&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;main函数不能调用自己 不能递归调用&lt;/p&gt;
&lt;p&gt;声明一个返回数组指针的函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int (*func(int i))[10]{
    ......
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义了一个返回10个整数数组指针的函数&lt;/p&gt;
&lt;p&gt;另一种方法是&lt;strong&gt;使用尾置返回类型&lt;/strong&gt; 任何函数都可以使用&lt;br&gt;
但对于返回复杂类型的函数最有效 比如数组指针或数组引用&lt;br&gt;
方法：使用时用auto代替类型并在形参之后用-&amp;gt;跟着真正的类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;auto func(int i) -&amp;gt; int(*)[10] {
    ......
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这与上述定义是等价的 但更容易使用&lt;/p&gt;
&lt;p&gt;最后一种方法是 在已知返回指向哪个变量时 可以使用&lt;code&gt;decltype&lt;/code&gt;来声明&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int odd[ ] = {1,2,3}; 
Decltype(odd) *func(int i){ 
    return &amp;amp;odd;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;函数重载&#34;&gt;函数重载&lt;/h2&gt;
&lt;p&gt;如果同一作用域内的几个函数名字相同但形参列表不同 就称之为重载函数&lt;/p&gt;
&lt;p&gt;注意 &lt;strong&gt;形参若仅有常量非常量的区别被视为相同形参&lt;/strong&gt;&lt;br&gt;
因常量在拷贝时会失去顶层&lt;code&gt;const&lt;/code&gt;&lt;br&gt;
如 &lt;code&gt;int&lt;/code&gt; 和&lt;code&gt;const int&lt;/code&gt;, &lt;code&gt;int *&lt;/code&gt; 和 &lt;code&gt;int* const&lt;/code&gt;传参时是一样的&lt;/p&gt;
&lt;p&gt;但形参是某种类型的指针或引用时 可以区别指向常量和非常量对象的形参&lt;br&gt;
如&lt;code&gt;int &amp;amp;&lt;/code&gt;和&lt;code&gt;const int&amp;amp;&lt;/code&gt;, &lt;code&gt;int *&lt;/code&gt;和&lt;code&gt;const int *&lt;/code&gt;是不一样的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回类型不同而形参一致同样也不被允许重载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;main函数不可重载&lt;/p&gt;
&lt;p&gt;函数匹配是与函数重载对应的过过程, 也叫&lt;strong&gt;重载确定&lt;/strong&gt;, 通过形参确定调用的重载函数&lt;/p&gt;
&lt;p&gt;当调用重载函数时 没有完全匹配的最佳选择 却有多个可以通过对实参类型转换而满足形参的重载函数 则会产生&lt;strong&gt;二义性调用&lt;/strong&gt;的错误&lt;/p&gt;
&lt;p&gt;函数匹配：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一步是确定本次调用的重载函数集 , 这个集合中的函数称之为候选函数(满足同名且声明在调用点可见) ;&lt;/li&gt;
&lt;li&gt;第二步是根据提供的实参选出可行函数(形参的个数和对应类型都与提供的实参相符或能转换得到);&lt;/li&gt;
&lt;li&gt;第三步是从可行函数中寻找最佳匹配 实参类型与形参越接近 匹配越好 其原则是: 最佳匹配的每个实参匹配都不劣于其他可行函数的匹配 且 至少有一个实参匹配优于其他&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;f(int,int){ }
f(double,double){ } 
f(42,3.14);
// 第一个实参的最佳匹配是第一个函数 第二个实参的最佳匹配是第二个函数 
// 因此会产生二义性调用
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在局部作用域中声明一个重载函数后 将会隐藏所有外部的重载函数&lt;/p&gt;
&lt;p&gt;当一个形参具有默认值,其后的所有形参都必须有 也就是&lt;strong&gt;默认形参必须在非默认形参之后&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;声明函数定义默认形参后 不能重新定义函数来更改原有的默认形参&lt;br&gt;
但可以将原来的非默认形参定义为新的默认形参&lt;/p&gt;
&lt;p&gt;用作默认实参的名字在函数声明的作用域内解析 但不受内部局部变量的影响&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int a = 10;
int b = 2;
int func(int = a, int = b);
Void f2()
{ 
    int a = 1; //虽然通过定义局部变量隐藏了外部值 但并不影响函数调用的默认实参
    b = 3; //直接修改外部默认实参的值 有效 可以产生效果
    func(); 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过&lt;strong&gt;内联函数&lt;/strong&gt;避免函数调用的开销&lt;br&gt;
通过在返回类型前添加&lt;code&gt;inline&lt;/code&gt;关键字即可 其效果就是&lt;strong&gt;将该函数在调用点处直接展开(替换)&lt;/strong&gt;&lt;br&gt;
但是一般只用于优化规模小 流程直接 频繁调用的函数 递归函数和较大的函数就不适合使用内联了&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt; 函数被隐式地指定为内联函数&lt;br&gt;
&lt;code&gt;constexpr&lt;/code&gt; 函数中有且仅有一条return语句(不能有其他任何执行操作的语句) 并且返回值和所有的形参类型一定是字面值&lt;br&gt;
但通过传入非常量类型的实参 可以返回非常量的表达式( 因为内联展开的原因 )&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__func__&lt;/code&gt;是编译器定义的一个局部静态变量 用于存放当前函数的名字&lt;br&gt;
&lt;code&gt;__FILE__&lt;/code&gt;存放文件名的字符串字面值&lt;br&gt;
&lt;code&gt;__LINE__&lt;/code&gt;存放当前行号的整型字面值&lt;br&gt;
&lt;code&gt;__TIME__&lt;/code&gt;存放文件编译时刻的字符串字面值 (不是消耗的时间 而是编译时的那个时刻)&lt;br&gt;
&lt;code&gt;__DATE__&lt;/code&gt;存放文件编译日期的字符串字面值&lt;br&gt;
使用这些常量可以在错误消息中提供更多信息&lt;/p&gt;
&lt;p&gt;在使用函数名作为一个值时 自动转换成指针 取地址可有可无&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int (*pf)(int); 
int f(int a);
Pf = f; pf =&amp;amp;f; //这两者是等价的
Pf(2); //可以直接通过函数指针调用函数 无需解引用
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样 也可以直接将函数名作为形参使用 等价于指向函数的指针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int f(int); 
void f2(int , int pf(int)); 
void f2(int, int (*pf)(int));
f2(3, f);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以定义返回类型为函数指针 如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int(*f1)(int ,int) (int); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由内而外 自右而左的看 首先看到有形参列表 所以是函数&lt;br&gt;
接着看到*  所以是函数指针&lt;br&gt;
接着看到外侧的形参列表 说明是个返回函数指针的函数&lt;br&gt;
最后看到int 说明返回的是个返回整型的函数指针的函数&lt;/p&gt;
&lt;p&gt;为了方便起见 我们可以使用定义别名和尾置返回类型的方式来定义这种复杂函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//别名方式
using PF = int(*)(int,int);
PF f1(int);

//尾置返回方式
Auto f1(int) -&amp;gt; int (*)(int);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;decltype&lt;/code&gt;来获得函数指针时 必须加上一个&lt;code&gt;*&lt;/code&gt;来指出其指针的类型 &lt;code&gt;decltype(func)* f2= func;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;函数原型就是函数的声明&lt;/p&gt;
&lt;p&gt;分离式编译指把一个程序分割成多个独立的源文件的能力&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IO类型属于不能被拷贝的类型&lt;/strong&gt; 在作为函数参数时&lt;strong&gt;只能通过引用传递 而非值传递&lt;/strong&gt;&lt;br&gt;
并且 &lt;strong&gt;读取和写入的操作都会改变流的内容 因此只能使用非常量引用&lt;/strong&gt;&lt;/p&gt;
">[C++学习笔记] 函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/WkASMyqjA/"" data-c="
          &lt;p&gt;语句（statement）是C++程序（program）中的组成成分，函数主体（body）由 一系列语句组成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表达式跟一个分号就构成了表达式语句&lt;/strong&gt; 单独一个分号就是空语句&lt;/p&gt;
&lt;p&gt;C++支持的主要语句类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;expression statements:&lt;/code&gt; 表达式语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;compound statements&lt;/code&gt;: 复合语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;selection statements&lt;/code&gt;: 选择语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;iteration statements&lt;/code&gt;: 迭代语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;jump statements&lt;/code&gt;: 跳转语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;declaration statements&lt;/code&gt;: 声明语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;try blocks&lt;/code&gt;: 异常捕获块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;atomic and synchronized blocks&lt;/code&gt; (TM TS): 原子和同步块&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;C++默认是将&lt;code&gt;else&lt;/code&gt;语句与最近的未匹配的if语句匹配 以解决&lt;code&gt;else&lt;/code&gt;悬挂问题消除二义性&lt;br&gt;
如果想要强制按照我们的想法来匹配的话 可以通过&lt;code&gt;{}&lt;/code&gt;来限制作用域从而限制匹配&lt;/p&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt;语句中 &lt;code&gt;case&lt;/code&gt;标签必须是常量&lt;br&gt;
并且&lt;code&gt;case&lt;/code&gt;中一般有&lt;code&gt;break;&lt;/code&gt;语句&lt;br&gt;
因为一旦&lt;code&gt;case&lt;/code&gt;匹配成功将会无视后续的&lt;code&gt;case&lt;/code&gt;条件直接执行后面的所有代码&lt;/p&gt;
&lt;p&gt;Do while 语句中不能在条件部分定义变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;do{ 
    ....
} while(int a=get_v());  // 错误
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;error&lt;/code&gt;类的&lt;code&gt;what()&lt;/code&gt;成员返回初始化时的&lt;code&gt;string&lt;/code&gt;对象副本 即错误信息&lt;/p&gt;
">[C++学习笔记] 语句</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/P18BHY5ic/"" data-c="
          &lt;h2 id=&#34;优先级与结合律&#34;&gt;优先级与结合律&lt;/h2&gt;
&lt;p&gt;重载运算符时可以更改运算对象的类型 返回值类型等 但不能更改运算对象个数 运算优先级和结合律&lt;/p&gt;
&lt;p&gt;当一个对象被用作右值时 用的是对象的值(内容) 而被用作左值时 用的是对象的身份(即在内存中的位置)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优先级和结合律规定了运算对象的组合方式 但运算对象的求值顺序与优先级和结合律无关&lt;/strong&gt;&lt;br&gt;
例如，在一条形如&lt;code&gt;f()+g()*h()+j()&lt;/code&gt;的表达式中:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据优先级规定了&lt;code&gt;g()&lt;/code&gt;的返回值和&lt;code&gt;h()&lt;/code&gt;的返回值相乘&lt;/li&gt;
&lt;li&gt;根据结合律规定了&lt;code&gt;f()&lt;/code&gt;的返回值 先与&lt;code&gt;g()&lt;/code&gt;和&lt;code&gt;h()&lt;/code&gt;的乘积相加 所得结果再与&lt;code&gt;j()&lt;/code&gt;的返回值相加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但对于这些函数的调用顺序并没明确规定&lt;br&gt;
如果这三者影响同一对象 则会产生未定义的行为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int i=0; 
cout&amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; ++i &amp;lt;&amp;lt;endl; //未定义的行为 因为&amp;lt;&amp;lt;运算符未明确规定求值顺序
*begin = toupper(*begin++); //这也是未定义的 因为赋值运算=也未规定求值顺序
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以凡是未定义求值顺序的运算 都不能同时出现修改值和使用值&lt;br&gt;
有&lt;strong&gt;四种运算符明确规定了求值顺序&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&amp;amp;(逻辑与)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;||(逻辑或)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?:(条件运算符)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;,(逗号运算符)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们的&lt;strong&gt;求值顺序都是先左后右&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;和&lt;code&gt;||&lt;/code&gt;当且仅当左侧值无法确定表达式结果时才会求右侧值 这种策略称之为&lt;strong&gt;短路求值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(-m)/n&lt;/code&gt;与&lt;code&gt;m/(-n)&lt;/code&gt;都等价于&lt;code&gt;-(m/n)&lt;/code&gt;&lt;br&gt;
然而 &lt;code&gt;m%(-n)&lt;/code&gt;等价于 &lt;code&gt;m%n&lt;/code&gt;&lt;br&gt;
&lt;code&gt;(-m)%n&lt;/code&gt; 与 &lt;code&gt;(-m)%(-n)&lt;/code&gt; 都等价于 &lt;code&gt;-(m%n)&lt;/code&gt;&lt;br&gt;
即&lt;strong&gt;取模结果的符号只看分子的符号&lt;/strong&gt;(余数和被除数同号 这也符合我们的理解)&lt;/p&gt;
&lt;p&gt;对于赋值运算符而言 若右值与左值不同类型 则将右值转换成左值类型&lt;br&gt;
&lt;strong&gt;赋值运算符优先级较低 低于关系运算和算数运算符&lt;/strong&gt; 因此要注意使用时是否要添加括号&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;while(i = get_v() != 42) 
while((i = get_v()) != 42) 
//前者错误 事实上是先将函数返回值与42比较后的布尔值再赋值给i 因为赋值运算优先级低
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;赋值运算符满足右结合律 如 &lt;code&gt;int i, j; i = j = 0;&lt;/code&gt; 正确 满足右结合律&lt;br&gt;
但对于这种多重赋值语句中的每一个对象 它的类型必须与右侧对象保持一致或可类型转换得到&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;int i, *j; i = j = 0;&lt;/code&gt; 就是错误的多重赋值&lt;br&gt;
虽然&lt;code&gt;i&lt;/code&gt;和&lt;code&gt;j&lt;/code&gt;都可以接受&lt;code&gt;0&lt;/code&gt;作赋值&lt;br&gt;
但是&lt;code&gt;int&lt;/code&gt; 和&lt;code&gt;int *&lt;/code&gt;类型不一致 不能在同一条多重赋值语句中&lt;br&gt;
实际上 &lt;strong&gt;多重赋值相当于自右向左作赋值运算&lt;/strong&gt;  上面语句相当于&lt;code&gt;j=0; i=j;&lt;/code&gt; 故不成立&lt;/p&gt;
&lt;p&gt;复合运算符(如&lt;code&gt;+=&lt;/code&gt; &lt;code&gt;-=&lt;/code&gt; &lt;code&gt;*=&lt;/code&gt;等等)与普通运算符(&lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt;)的区别: 左侧对象求值次数少,普通两次,复合一次&lt;/p&gt;
&lt;p&gt;除非必须 尽量不使用后置版本的递增递减运算符&lt;br&gt;
因为后置版是将对象原始值的副本返回 需要额外的储存 而前置版本返回的是对象本身&lt;/p&gt;
&lt;p&gt;除非为了在一条表达式中 既修改变量又使用原始值的情况 才用后置版本&lt;br&gt;
例如 &lt;code&gt;cout&amp;lt;&amp;lt;*iter++;&lt;/code&gt;要比 &lt;code&gt;cout&amp;lt;&amp;lt;*iter; ++iter;&lt;/code&gt; 更简洁也更不易出错&lt;/p&gt;
&lt;p&gt;条件运算符的优先级也很低 所以需要通过加括号来保证完成效果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;cout&amp;lt;&amp;lt; ((grade &amp;lt; 60) ? &amp;quot;fail&amp;quot; : &amp;quot;pass&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用位运算符时会将小整数提升成较大整数类型 如&lt;code&gt;short&lt;/code&gt; &lt;code&gt;char&lt;/code&gt; 等会被转换成 &lt;code&gt;int&lt;/code&gt;&lt;br&gt;
在二进制中的表现就是高位添加24个0&lt;/p&gt;
&lt;p&gt;移位运算符(同时也是IO运算符) 满足左结合律&lt;br&gt;
优先级在中间位置 低于算术运算符 高于 关系运算 赋值运算和条件运算&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;cout&amp;lt;&amp;lt;10&amp;lt;42; //错误 试图比较`cout`对象与`42` 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为关系运算&lt;code&gt;&amp;lt;&lt;/code&gt;优先级低于移位运算&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;br&gt;
事实上是先输出了&lt;code&gt;10&lt;/code&gt;以后返回的&lt;code&gt;cout&lt;/code&gt;对象在比较&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sizeof&lt;/code&gt; 并不求值 因此可以对无效指针求也不会出错&lt;/p&gt;
&lt;p&gt;逗号运算符 先对逗号左边表达式求值后丢弃 其真正结果是右侧表达式结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int a = (1, 3); //a的值为3 注意这里加括号是因为逗号运算符的优先级低于赋值运算
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用运算符优先级:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;作用域符&amp;gt;成员运算符&amp;gt;后置递增递减=类型转换&amp;gt;前置递增递减=逻辑非=正负号&amp;gt;函数&amp;gt;算术运算&amp;gt;移位运算(IO运算)&amp;gt;关系运算&amp;gt;位运算&amp;gt;逻辑与或&amp;gt;条件&amp;gt;赋值&amp;gt;复合赋值&amp;gt;throw&amp;gt;逗号运算
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完整表:&lt;br&gt;
从上往下 优先级由高到低&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;运算符&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;::&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;作用域解析运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;函数调用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;[]&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数组下标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;成员选择&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;成员选择&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;++ --&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;前缀自增/自减&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;+ -&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;正负号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;! ~&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;逻辑非/按位取反&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;* / %&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;乘法/除法/取模&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;+ -&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;加法/减法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt;&amp;lt; &amp;gt;&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;左移/右移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt; &amp;lt;= &amp;gt; &amp;gt;=&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;关系运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;== !=&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;相等性运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;amp;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;按位与&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;^&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;按位异或&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;|&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;按位或&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;逻辑与&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;||&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;逻辑或&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;?:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;三目运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;= += -= *= /= %= &amp;amp;= ^= |= &amp;lt;&amp;lt;= &amp;gt;&amp;gt;=&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;赋值运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;,&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;逗号运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;类型转换&#34;&gt;类型转换&lt;/h2&gt;
&lt;h3 id=&#34;算数转换&#34;&gt;算数转换&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;算数转换步骤&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先 小整型转大整型 即能容纳它值的最小类型&lt;/li&gt;
&lt;li&gt;接着运算中尽可能以最高精度类型保存 即都转行成最高类型&lt;/li&gt;
&lt;li&gt;无符号和有符号进行计算时 若无符号类型不小于有符号 则转换成无符号 若小于 则依赖于机器决定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如，&lt;code&gt;3.13L +&#39;a&#39;&lt;/code&gt; 中&lt;code&gt;&#39;a&#39;&lt;/code&gt;先被提升成&lt;code&gt;int&lt;/code&gt; 然后该&lt;code&gt;int&lt;/code&gt;转成&lt;code&gt;long double&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;强制转换&#34;&gt;强制转换&lt;/h3&gt;
&lt;p&gt;强制转换分为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;static_cast&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_cast&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;static_cast&lt;/code&gt; 最通用的转换 可以转除了&lt;code&gt;const&lt;/code&gt;以外的类型转换&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;static_cast&amp;lt;double&amp;gt;(j);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;const_cast&lt;/code&gt; 只用于修改表达式的常量属性但不能修改类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;const char b; 
char c = const_cast&amp;lt;char&amp;gt; (b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;const_cast&lt;/code&gt;在重载函数时最有用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dynamic_cast&lt;/code&gt; 就是为解决虚基类到派生类的转换而设计的。在C++中，&lt;code&gt;dynamic_cast&lt;/code&gt;是一种用于在运行时进行类型转换的操作符。它&lt;strong&gt;用于将一个指向基类的指针或引用转换为指向派生类的指针或引用&lt;/strong&gt;。&lt;code&gt;dynamic_cast&lt;/code&gt;提供了一种安全的方式来进行类型转换，它会在运行时检查转换是否有效，如果转换不合法，则返回一个空指针（对于指针转换）或抛出一个&lt;code&gt;std::bad_cast&lt;/code&gt;异常（对于引用转换）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dynamic_cas&lt;/code&gt;t的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;dynamic_cast&amp;lt;new_type&amp;gt;(expression)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;new_type&lt;/code&gt;是目标类型，&lt;code&gt;expression&lt;/code&gt;是要转换的表达式。&lt;/p&gt;
&lt;p&gt;以下是&lt;code&gt;dynamic_cast&lt;/code&gt;的一些特点和用法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用于多态类型：&lt;code&gt;dynamic_cas&lt;/code&gt;t主要用于多态类型的转换，即基类指针或引用转换为派生类指针或引用。它只能用于具有虚函数的类层次结构中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全性检查：&lt;code&gt;dynamic_cast&lt;/code&gt;会在运行时检查转换是否合法。如果转换不合法，即基类指针或引用不指向派生类对象，&lt;code&gt;dynamic_cast&lt;/code&gt;会返回一个空指针（对于指针转换）或抛出一个std::bad_cast异常（对于引用转换）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;向下转型：&lt;code&gt;dynamic_cast&lt;/code&gt;可以将基类指针或引用向下转型为派生类指针或引用。这样可以访问派生类特有的成员函数和成员变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;向上转型：&lt;code&gt;dynamic_cast&lt;/code&gt;也可以将派生类指针或引用向上转型为基类指针或引用。这样可以将派生类对象当作基类对象来使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用于类层次结构的判断：&lt;code&gt;dynamic_cast&lt;/code&gt;还可以用于判断两个类对象之间的关系。如果转换成功，表示两个类对象之间存在继承关系；如果转换失败，表示两个类对象之间不存在继承关系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;dynamic_cast&lt;/code&gt;只能用于具有多态性的类层次结构，即基类必须至少有一个虚函数。此外，&lt;code&gt;dynamic_cast&lt;/code&gt;的性能相对较低，因为它需要在运行时进行类型检查。因此，在使用&lt;code&gt;dynamic_cast&lt;/code&gt;时应该谨慎使用，尽量避免频繁的类型转换操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt; 运算符并不会改变括号中运算对象的值，而是对该对象从位模式上进行重新解释:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不进行类型检查：&lt;code&gt;reinterpret_cast&lt;/code&gt;不进行任何类型检查或转换，它只是将一个指针或引用的二进制表示重新解释为另一种类型的指针或引用。因此，使用&lt;code&gt;reinterpret_cast&lt;/code&gt;需要非常小心，确保转换是安全的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用于底层操作：&lt;code&gt;reinterpret_cast&lt;/code&gt;主要用于进行底层操作，例如将一个指针转换为一个整数，或者将一个整数转换为一个指针。这些操作通常需要对内存布局进行精确控制，因此需要使用&lt;code&gt;reinterpret_cast&lt;/code&gt;来进行类型转换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用于类型擦除：&lt;code&gt;reinterpret_cast&lt;/code&gt;还可以用于类型擦除，即将一个具有模板参数的类型转换为一个没有模板参数的类型。这样可以在运行时动态地创建一个模板类的实例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;形如&lt;code&gt;int(a)&lt;/code&gt; &lt;code&gt;(int) a&lt;/code&gt;等为旧式的强制类型转换&lt;/p&gt;
">[C++学习笔记] 表达式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/ZtT7bURs/"" data-c="
          &lt;h2 id=&#34;字符数组&#34;&gt;字符数组&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Getline()&lt;/code&gt;函数读一行 直到读入换行符为止&lt;br&gt;
但是读入换行符并不存入 读入的换行符被丢弃 得到的string不包含换行符&lt;/p&gt;
&lt;p&gt;&lt;code&gt;endl&lt;/code&gt;是&lt;strong&gt;操作符&lt;/strong&gt; 作用是&lt;strong&gt;结束当前行并刷新显示缓冲区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string.size() &lt;/code&gt;返回的长度是无符号数 与&lt;code&gt;int&lt;/code&gt;混用时可能会产生错误&lt;/p&gt;
&lt;p&gt;当使用 &lt;code&gt;+&lt;/code&gt; 号来进行字符串操作时 保证两个操作数中至少有一个是&lt;code&gt;string&lt;/code&gt;才行&lt;br&gt;
不能直接将两个字面值字符串进行相加&lt;br&gt;
例如&lt;code&gt;&amp;quot;hello&amp;quot; + &amp;quot;word&amp;quot;&lt;/code&gt;是错的 因为重载的是&lt;code&gt;string&lt;/code&gt;类定义的运算符&lt;code&gt;+&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;连续输入时可以存在相邻都是字面值&lt;br&gt;
例如 &lt;code&gt;string s1;string s2 = s1 + &amp;quot;he&amp;quot;+&amp;quot;llo&amp;quot;; &lt;/code&gt;&lt;br&gt;
因为根据自左向右的计算规则 仍旧保证了有一个类型为&lt;code&gt;string&lt;/code&gt;&lt;br&gt;
但反过来 &lt;code&gt;string s3 = &amp;quot;he&amp;quot;+&amp;quot;llo&amp;quot;+s1 ; &lt;/code&gt;则不成立&lt;/p&gt;
&lt;p&gt;c中标准库xxx.h文件在c++中为cxxx 尽量避免使用xxx.h的形式 因为cxxx的名字都包含在std中&lt;/p&gt;
&lt;p&gt;C++迭代器 &lt;code&gt;for(迭代变量: 序列)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;string s(&amp;quot;abcd&amp;quot;); 
for(auto i : s) cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但如果想要改变&lt;code&gt;string&lt;/code&gt;中字符的值 必须将迭代变量定义为引用类型 &lt;code&gt;for(auto &amp;amp;i : s) i = &#39;e&#39;;&lt;/code&gt;&lt;br&gt;
当然也可以使用传统的下标索引法&lt;/p&gt;
&lt;h2 id=&#34;容器&#34;&gt;容器&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt; 也被称为容器 表示对象的集合 其中所有对象的类型都相同&lt;br&gt;
&lt;code&gt;vector&lt;/code&gt;是一种类模板 &lt;strong&gt;利用模板创建类或者函数的过程称之为实例化&lt;/strong&gt;&lt;br&gt;
类模板必须包含其中元素的类型:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;vector&amp;lt;int&amp;gt; v; 
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; a(10);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建&lt;code&gt;vector&lt;/code&gt;时 可不指定数目创建 也可用&lt;code&gt;()&lt;/code&gt;指定元素数量&lt;br&gt;
考虑到vector能高效添加元素 一般不指定元素数目 除非是需要创建所有值都相同的&lt;code&gt;vector&lt;/code&gt; 否则反而会降低效率&lt;/p&gt;
&lt;p&gt;利用&lt;code&gt;vector&lt;/code&gt;的成成员函数&lt;code&gt;push_back()&lt;/code&gt;来向&lt;code&gt;vector&lt;/code&gt;尾部添加元素 &lt;code&gt;v.push_back(1);&lt;/code&gt;&lt;br&gt;
&lt;code&gt;vector&lt;/code&gt;其他操作类似于&lt;code&gt;string&lt;/code&gt; 比如 迭代遍历 改变值的操作可以用for遍历 也可以用下标索引,&lt;br&gt;
获取大小也是使用&lt;code&gt;.size()&lt;/code&gt;成员函数&lt;/p&gt;
&lt;p&gt;另一种更加通用的遍历容器中元素或&lt;code&gt;string&lt;/code&gt;中字符的方法是&lt;strong&gt;迭代器&lt;/strong&gt;&lt;br&gt;
所有标准库容器都支持迭代器 但只有少数几种支持下标&lt;br&gt;
凡是支持迭代的类型都可以返回迭代器成员(如&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;,分别表示指向第一个元素和尾元素的下一位置的迭代器成员)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto b=v.begin(), e=v.end();&lt;/code&gt; 一般而言使用auto定义迭代器类型 因为我们不关注其真正类型&lt;br&gt;
&lt;code&gt;end&lt;/code&gt;是尾后迭代器,表示已经处理完了所有元素 若容器为空 &lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;返回的是一样的&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;++&lt;/code&gt;/&lt;code&gt;--&lt;/code&gt;来令迭代器指向下/上一个元素&lt;br&gt;
通过&lt;code&gt;begin = begin + n&lt;/code&gt;来指向后n个字符&lt;br&gt;
通过&lt;code&gt;*begin&lt;/code&gt;解引用来获取迭代器所指向元素的引用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;for(auto it = s.begin(); it!=s.end() &amp;amp;&amp;amp; ! Isspace(*it); ++it) 
    *it= toupper(*it);
// 依次处理s的字符直至处理完全部字符或遇到空白 实现将string中第一个单词大写的功能
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C++在for循环中更常用&lt;code&gt;!=&lt;/code&gt;运算符而不是&lt;code&gt;&amp;lt;&lt;/code&gt;运算符，因为&lt;code&gt;!=&lt;/code&gt;支持的类型更多,很多类型未定义&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;cbegin&lt;/code&gt;和&lt;code&gt;cend&lt;/code&gt;表示常量类型的迭代器&lt;/p&gt;
&lt;p&gt;箭头运算符等价于先解引用再使用&lt;code&gt;.&lt;/code&gt;运算 例如&lt;code&gt;it-&amp;gt;mem&lt;/code&gt;等价于&lt;code&gt;(*it).mem&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;括号不可少&lt;/strong&gt; 因为点运算符&lt;code&gt;.&lt;/code&gt; 优先级高于解引用运算符&lt;code&gt;*&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 当循环中可能改变容器(如&lt;code&gt;vector&lt;/code&gt;)容量的时候 不能使用for循环语句 因为for循环中不能改变所遍历序列的大小 同理 也不能使用迭代器&lt;/p&gt;
&lt;p&gt;数组与&lt;code&gt;vector&lt;/code&gt;的区别在于&lt;strong&gt;数组的大小确定不变&lt;/strong&gt;并且&lt;strong&gt;不能用赋值方法拷贝另一个数组&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;Int a[]= {1,2,3}; 
int b[]=a; 
b=a; //后两种都是错的 不能使用数组给数组初始化或赋值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引用不是对象，因此，不存在引用数组 只有数组的引用&lt;/p&gt;
&lt;p&gt;数组定义要由内而外看 例如 parray 首先自内而外地看 是一个指针 然后发现是个10个元素的数组 并且类型为int&lt;br&gt;
同理 arrRef 是一个引用 然后看到是一个10个元素的数组引用 类型为int&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1687751775782.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int *(&amp;amp;array) [10] =ptrs;&lt;/code&gt; &lt;code&gt;array&lt;/code&gt;是一个包含十个指针的数组的引用&lt;br&gt;
由内而外看 &lt;code&gt;array&lt;/code&gt;是一个引用 然后看到是一个10个元素的数组 类型为&lt;code&gt;int *&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;全局变量未被初始化时自动初始化为默认值(一般为0或空) 局部变量未被初始化时处于未定义&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;auto&lt;/code&gt;推断数组时得到的是指针类型 而使用的decltype推断时返回的是数组类型&lt;/p&gt;
&lt;p&gt;指针也是一种迭代器&lt;br&gt;
如果要在数组中使用迭代器，不是通过成员函数&lt;br&gt;
因为数组不是类 而是使用数组本身作为参数调用库函数 得到返回的指针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int a[] = {1,2,3}; 
int *beg=begin(a); 
int *ed = end(a);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组的下标运算等价于指针加对应数值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int a[] = {1,2,3}; 
int *p= &amp;amp;a[1]; 
p[1]=1; //等价于 a[2] =1, p[n] 等价于 *(p+n)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;c风格字符串必须以&#39;\0&#39;结尾 使用其函数也必须保证传入的字符串符合此要求(如&lt;code&gt;strlen&lt;/code&gt;等)&lt;br&gt;
C++中&lt;code&gt;string&lt;/code&gt;对象可以通过&lt;code&gt;c_str()&lt;/code&gt;返回符合c格式的字符指针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;string s=&amp;quot;1&amp;quot;; 
const char * str=s.c_str();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不能使用数组和&lt;code&gt;vector&lt;/code&gt;来初始化数组 但反过来可以使用数组来初始化&lt;code&gt;vector&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int arr[] = {0,1,2}; 
vector&amp;lt;int&amp;gt; iv(begin(arr), end(arr)); 
vector&amp;lt;int&amp;gt; ivv(arr+1, arr+3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;严格来说 C++没有多维数组 只有数组的数组&lt;br&gt;
&lt;code&gt;int a[3][4] &lt;/code&gt;事实上定义的是一个大小为3的数组  数组中的每一个元素都是大小为4的数组&lt;/p&gt;
&lt;p&gt;数组初始化时若只指定了一部分值 那么剩下的将被默认初始化&lt;br&gt;
&lt;code&gt;int a [10]={0}; int a[2][2]={0};&lt;/code&gt; 事实上将所有元素都初始化为 0 了&lt;/p&gt;
&lt;p&gt;使用for循环遍历时 除了最内层元素 都应该使用引用来遍历 否则对于多维数组会被识别为指&lt;br&gt;
针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;for(auto &amp;amp;i: s){ 
    for(auto &amp;amp; j: i){ 
        do something;
    } 
}

//如果不想修改数组内的值的话
for(const auto &amp;amp;i: s){ 
    for(auto j: i) { 
        do something;
    } 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其次 使用引用遍历可以避免拷贝元素 尤其是元素较大时可以提高效率 比如&lt;code&gt;string&lt;/code&gt;对象的&lt;code&gt;vector&lt;/code&gt;&lt;/p&gt;
">[C++学习笔记] 数组</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/_ZtT7bURs/"" data-c="
          &lt;h2 id=&#34;字符数组&#34;&gt;字符数组&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Getline()&lt;/code&gt;函数读一行 直到读入换行符为止&lt;br&gt;
但是读入换行符并不存入 读入的换行符被丢弃 得到的string不包含换行符&lt;/p&gt;
&lt;p&gt;&lt;code&gt;endl&lt;/code&gt;是&lt;strong&gt;操作符&lt;/strong&gt; 作用是&lt;strong&gt;结束当前行并刷新显示缓冲区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string.size() &lt;/code&gt;返回的长度是无符号数 与&lt;code&gt;int&lt;/code&gt;混用时可能会产生错误&lt;/p&gt;
&lt;p&gt;当使用 &lt;code&gt;+&lt;/code&gt; 号来进行字符串操作时 保证两个操作数中至少有一个是&lt;code&gt;string&lt;/code&gt;才行&lt;br&gt;
不能直接将两个字面值字符串进行相加&lt;br&gt;
例如&lt;code&gt;&amp;quot;hello&amp;quot; + &amp;quot;word&amp;quot;&lt;/code&gt;是错的 因为重载的是&lt;code&gt;string&lt;/code&gt;类定义的运算符&lt;code&gt;+&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;连续输入时可以存在相邻都是字面值&lt;br&gt;
例如 &lt;code&gt;string s1;string s2 = s1 + &amp;quot;he&amp;quot;+&amp;quot;llo&amp;quot;; &lt;/code&gt;&lt;br&gt;
因为根据自左向右的计算规则 仍旧保证了有一个类型为&lt;code&gt;string&lt;/code&gt;&lt;br&gt;
但反过来 &lt;code&gt;string s3 = &amp;quot;he&amp;quot;+&amp;quot;llo&amp;quot;+s1 ; &lt;/code&gt;则不成立&lt;/p&gt;
&lt;p&gt;c中标准库xxx.h文件在c++中为cxxx 尽量避免使用xxx.h的形式 因为cxxx的名字都包含在std中&lt;/p&gt;
&lt;p&gt;C++迭代器 &lt;code&gt;for(迭代变量: 序列)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;string s(&amp;quot;abcd&amp;quot;); 
for(auto i : s) cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但如果想要改变&lt;code&gt;string&lt;/code&gt;中字符的值 必须将迭代变量定义为引用类型 &lt;code&gt;for(auto &amp;amp;i : s) i = &#39;e&#39;;&lt;/code&gt;&lt;br&gt;
当然也可以使用传统的下标索引法&lt;/p&gt;
&lt;h2 id=&#34;容器&#34;&gt;容器&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt; 也被称为容器 表示对象的集合 其中所有对象的类型都相同&lt;br&gt;
&lt;code&gt;vector&lt;/code&gt;是一种类模板 &lt;strong&gt;利用模板创建类或者函数的过程称之为实例化&lt;/strong&gt;&lt;br&gt;
类模板必须包含其中元素的类型:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;vector&amp;lt;int&amp;gt; v; 
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; a(10);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建&lt;code&gt;vector&lt;/code&gt;时 可不指定数目创建 也可用&lt;code&gt;()&lt;/code&gt;指定元素数量&lt;br&gt;
考虑到vector能高效添加元素 一般不指定元素数目 除非是需要创建所有值都相同的&lt;code&gt;vector&lt;/code&gt; 否则反而会降低效率&lt;/p&gt;
&lt;p&gt;利用&lt;code&gt;vector&lt;/code&gt;的成成员函数&lt;code&gt;push_back()&lt;/code&gt;来向&lt;code&gt;vector&lt;/code&gt;尾部添加元素 &lt;code&gt;v.push_back(1);&lt;/code&gt;&lt;br&gt;
&lt;code&gt;vector&lt;/code&gt;其他操作类似于&lt;code&gt;string&lt;/code&gt; 比如 迭代遍历 改变值的操作可以用for遍历 也可以用下标索引,&lt;br&gt;
获取大小也是使用&lt;code&gt;.size()&lt;/code&gt;成员函数&lt;/p&gt;
&lt;p&gt;另一种更加通用的遍历容器中元素或&lt;code&gt;string&lt;/code&gt;中字符的方法是**迭代器 **&lt;br&gt;
所有标准库容器都支持迭代器 但只有少数几种支持下标&lt;br&gt;
凡是支持迭代的类型都可以返回迭代器成员(如&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;,分别表示指向第一个元素和尾元素的下一位置的迭代器成员)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto b=v.begin(), e=v.end();&lt;/code&gt; 一般而言使用auto定义迭代器类型 因为我们不关注其真正类型&lt;br&gt;
&lt;code&gt;end&lt;/code&gt;是尾后迭代器,表示已经处理完了所有元素 若容器为空 &lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;返回的是一样的&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;++&lt;/code&gt;/&lt;code&gt;--&lt;/code&gt;来令迭代器指向下/上一个元素&lt;br&gt;
通过&lt;code&gt;begin = begin + n&lt;/code&gt;来指向后n个字符&lt;br&gt;
通过&lt;code&gt;*begin&lt;/code&gt;解引用来获取迭代器所指向元素的引用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;for(auto it = s.begin(); it!=s.end() &amp;amp;&amp;amp; ! Isspace(*it); ++it) 
    *it= toupper(*it);
// 依次处理s的字符直至处理完全部字符或遇到空白 实现将string中第一个单词大写的功能
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C++在for循环中更常用&lt;code&gt;!=&lt;/code&gt;运算符而不是&lt;code&gt;&amp;lt;&lt;/code&gt;运算符，因为&lt;code&gt;!=&lt;/code&gt;支持的类型更多,很多类型未定义&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;cbegin&lt;/code&gt;和&lt;code&gt;cend&lt;/code&gt;表示常量类型的迭代器&lt;/p&gt;
&lt;p&gt;箭头运算符等价于先解引用再使用&lt;code&gt;.&lt;/code&gt;运算 例如&lt;code&gt;it-&amp;gt;mem&lt;/code&gt;等价于&lt;code&gt;(*it).mem&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;括号不可少&lt;/strong&gt; 因为点运算符&lt;code&gt;.&lt;/code&gt; 优先级高于解引用运算符&lt;code&gt;*&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 当循环中可能改变容器(如&lt;code&gt;vector&lt;/code&gt;)容量的时候 不能使用for循环语句 因为for循环中不能改变所遍历序列的大小 同理 也不能使用迭代器&lt;/p&gt;
&lt;p&gt;数组与&lt;code&gt;vector&lt;/code&gt;的区别在于&lt;strong&gt;数组的大小确定不变&lt;/strong&gt;并且&lt;strong&gt;不能用赋值方法拷贝另一个数组&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;Int a[]= {1,2,3}; 
int b[]=a; 
b=a; //后两种都是错的 不能使用数组给数组初始化或赋值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引用不是对象，因此，不存在引用数组 只有数组的引用&lt;/p&gt;
&lt;p&gt;数组定义要由内而外看 例如 parray 首先自内而外地看 是一个指针 然后发现是个10个元素的数组 并且类型为int&lt;br&gt;
同理 arrRef 是一个引用 然后看到是一个10个元素的数组引用 类型为int&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1687751775782.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int *(&amp;amp;array) [10] =ptrs;&lt;/code&gt; &lt;code&gt;array&lt;/code&gt;是一个包含十个指针的数组的引用&lt;br&gt;
由内而外看 &lt;code&gt;array&lt;/code&gt;是一个引用 然后看到是一个10个元素的数组 类型为&lt;code&gt;int *&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;全局变量未被初始化时自动初始化为默认值(一般为0或空) 局部变量未被初始化时处于未定义&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;auto&lt;/code&gt;推断数组时得到的是指针类型 而使用的decltype推断时返回的是数组类型&lt;/p&gt;
&lt;p&gt;指针也是一种迭代器&lt;br&gt;
如果要在数组中使用迭代器，不是通过成员函数&lt;br&gt;
因为数组不是类 而是使用数组本身作为参数调用库函数 得到返回的指针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int a[] = {1,2,3}; 
int *beg=begin(a); 
int *ed = end(a);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组的下标运算等价于指针加对应数值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int a[] = {1,2,3}; 
int *p= &amp;amp;a[1]; 
p[1]=1; //等价于 a[2] =1, p[n] 等价于 *(p+n)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;c风格字符串必须以&#39;\0&#39;结尾 使用其函数也必须保证传入的字符串符合此要求(如&lt;code&gt;strlen&lt;/code&gt;等)&lt;br&gt;
C++中&lt;code&gt;string&lt;/code&gt;对象可以通过&lt;code&gt;c_str()&lt;/code&gt;返回符合c格式的字符指针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;string s=&amp;quot;1&amp;quot;; 
const char * str=s.c_str();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不能使用数组和&lt;code&gt;vector&lt;/code&gt;来初始化数组 但反过来可以使用数组来初始化&lt;code&gt;vector&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int arr[] = {0,1,2}; 
vector&amp;lt;int&amp;gt; iv(begin(arr), end(arr)); 
vector&amp;lt;int&amp;gt; ivv(arr+1, arr+3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;严格来说 C++没有多维数组 只有数组的数组&lt;br&gt;
&lt;code&gt;int a[3][4] &lt;/code&gt;事实上定义的是一个大小为3的数组  数组中的每一个元素都是大小为4的数组&lt;/p&gt;
&lt;p&gt;数组初始化时若只指定了一部分值 那么剩下的将被默认初始化&lt;br&gt;
&lt;code&gt;int a [10]={0}; int a[2][2]={0};&lt;/code&gt; 事实上将所有元素都初始化为 0 了&lt;/p&gt;
&lt;p&gt;使用for循环遍历时 除了最内层元素 都应该使用引用来遍历 否则对于多维数组会被识别为指&lt;br&gt;
针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;for(auto &amp;amp;i: s){ 
    for(auto &amp;amp; j: i){ 
        do something;
    } 
}

//如果不想修改数组内的值的话
for(const auto &amp;amp;i: s){ 
    for(auto j: i) { 
        do something;
    } 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其次 使用引用遍历可以避免拷贝元素 尤其是元素较大时可以提高效率 比如&lt;code&gt;string&lt;/code&gt;对象的&lt;code&gt;vector&lt;/code&gt;&lt;/p&gt;
">[C++学习笔记] 数组</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/Ufy_Y9MLE/"" data-c="
          &lt;h2 id=&#34;1-计算机内部数据表示&#34;&gt;1. 计算机内部数据表示&lt;/h2&gt;
&lt;p&gt;计算机中二进制数据表示 第一位是符号位 后面表示数值 负数就是第一位是1 后面取补值&lt;br&gt;
补码就是反码加1 反码就是除了符号位其他每位取反&lt;/p&gt;
&lt;p&gt;例如8位的数据表示范围为 -2&lt;sup&gt;7&lt;/sup&gt; ~ 2&lt;sup&gt;7&lt;/sup&gt; - 1&lt;br&gt;
－1 = 11111111&lt;/p&gt;
&lt;p&gt;整数类型的数据范围&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;数据类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;范围&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-2&lt;sup&gt;31&lt;/sup&gt; ~ 2&lt;sup&gt;31&lt;/sup&gt; - 1，即 -2147483648~2147483647&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10位数，21亿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;long long&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-2&lt;sup&gt;63&lt;/sup&gt; ~ 2&lt;sup&gt;63&lt;/sup&gt; - 1，即 922*10&lt;sup&gt;16&lt;/sup&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;19位数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;unsigned long long&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0 ~ 2&lt;sup&gt;64&lt;/sup&gt;，即 1844*10&lt;sup&gt;16&lt;/sup&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;20位数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;不要混用无符号和有符号的数 无符号整数与整数直接运算可能会出错&lt;br&gt;
因为会将整数自动转换为无符号整数 如果整数为负则转换成其对应补码的正整数形式&lt;br&gt;
并且即使是两个无符号整数, 运算时也应该注意运算结果是否可能会溢出&lt;/p&gt;
&lt;h2 id=&#34;2-字符类型&#34;&gt;2. 字符类型&lt;/h2&gt;
&lt;p&gt;对于字符数组而言 编译器自动会在字符串结尾加个&#39;\0&#39;表示结束 因此字符串实际长度比内容长度多1&lt;/p&gt;
&lt;p&gt;如果两个字符串紧邻且仅由空格 缩进和换行符分割 那么它们其实是一个字符串&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;Cout&amp;lt;&amp;lt;&amp;quot;aaa&amp;quot; &amp;quot;bbb&amp;quot;&amp;lt;&amp;lt;endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过添加前缀和后缀来改变数据的默认类型:eg. u8&amp;quot;hi&amp;quot;(utf-8 字符串), 42ULL(无符号longlong 整数 42)&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1687747268014.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;String a(b)&lt;/code&gt; 表示创建一个字符串a复制b的值，拷贝初始化&lt;br&gt;
&lt;code&gt;int a{ld}&lt;/code&gt; 列表初始化 C++11新特性 在初始化丢失信息时报错&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cout&amp;lt;&amp;lt;::a&lt;/code&gt;  通过作用域运算符可以在定义了同名局部变量时使用全局变量a&lt;/p&gt;
&lt;h2 id=&#34;3-引用与指针&#34;&gt;3. 引用与指针&lt;/h2&gt;
&lt;p&gt;引用不是指针 引用必须初始化且初始化后不可更改 引用即别名 &lt;code&gt;int &amp;amp;a=b;&lt;/code&gt;&lt;br&gt;
不能定义引用的引用 因为引用不是一个对象 只是一个链接&lt;br&gt;
引用绑定的必须是变量(对象) 不能是一个字面值 &lt;code&gt;int &amp;amp;a=0&lt;/code&gt;是错误的&lt;br&gt;
引用绑定的变量必须严格符合它的类型 (&lt;code&gt;int&amp;amp;&lt;/code&gt;只能绑&lt;code&gt;int&lt;/code&gt;变量)&lt;/p&gt;
&lt;p&gt;指针与引用的区别:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;指针本身就是一个对象, 可以对指针赋值和拷贝,可以先后指向不同的对象;而引用不是对象,一旦绑定也不能改变&lt;/li&gt;
&lt;li&gt;指针无需在定义时就初始化,和其他内置类型一样,未被初始化时获得一个不确定的值&lt;br&gt;
不能定义指向引用的指针 因为引用不是对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是可以定义指向指针的指针 因为指针本身是对象 &lt;code&gt;int **p&lt;/code&gt;&lt;br&gt;
也可以定义指向指针的引用 &lt;code&gt;int *&amp;amp;r=p; &lt;/code&gt;注意是&lt;code&gt;int *&lt;/code&gt;的指针所以引用是&lt;code&gt;int *&amp;amp;&lt;/code&gt;&lt;br&gt;
定义时 自右向左判断类型 离的最近的符号有着最直接的影响 &lt;code&gt;int *&amp;amp;&lt;/code&gt;就代表是个&lt;code&gt;int *&lt;/code&gt;的引用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void*&lt;/code&gt;指针可以存放任何类型的数据地址 但不能通过解引用来操作其指向的对象 因为类型不明确 仅仅只是作为内存地址保存 可以用于传参和比较地址&lt;/p&gt;
&lt;p&gt;变量的定义包括一个基本数据类型和一组声明符, 基本数据类型只有一个, 但声明符可以有多个&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt; int i=1024, *p=&amp;amp;I, &amp;amp;r=I;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同时通过多个声明符声明了三个不同类型的变量 有着相同的基本数据类型  但声明符不同&lt;br&gt;
将指针形式写成&lt;code&gt;int* p&lt;/code&gt;也可以，与&lt;code&gt;int *p&lt;/code&gt;是一样的&lt;/p&gt;
&lt;h2 id=&#34;4-常量类型&#34;&gt;4. 常量类型&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;变量的意义: 使用变量方便我们自己改变 但又防止程序不小心改变&lt;br&gt;
&lt;code&gt;cosnt&lt;/code&gt;变量必须在定义时初始化&lt;br&gt;
默认&lt;code&gt;const&lt;/code&gt;变量仅对当前文件生效 想在多个文件中使用的话必须使用&lt;code&gt;extern&lt;/code&gt;关键字&lt;/p&gt;
&lt;p&gt;指向常量的引用必须也是常量引用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;const int a=0; const int &amp;amp;b =a;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但常量引用可以绑定非常量的数据类型甚至是字面值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int i=42; 
const int &amp;amp; r1 =i; 
const int &amp;amp;r2=42;
const int &amp;amp;r3=r1 *2;
int &amp;amp; r4 = r1 * 2; //不行 r4是个非常量引用 而r1 *2 得到的是计算结果 是一个临时值 不允许改变
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常量引用只是禁止了通过常量引用去改变绑定的值，但只要绑定的值本身不是常量，仍然可以改变&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int i=12; int &amp;amp;r1=i;
const int &amp;amp;r2 = i; 
r1=0; //可以修改i的值,但r2=0不行,不能通过常量引用修改
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;修饰指针有三种情况&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;修饰指针 --- 常量指针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;修饰常量 --- 指针常量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;即修饰指针，又修饰常量&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int main() {
    int a = 10;
    int b = 10;
    //const修饰的是指针，指针指向可以改，指针指向的值不可以更改
    const int * p1 = &amp;amp;a; 
    p1 = &amp;amp;b; //正确
    //*p1 = 100; 报错
    //const修饰的是常量，指针指向不可以改，指针指向的值可以更改
    int * const p2 = &amp;amp;a;
    //p2 = &amp;amp;b; //错误
    *p2 = 100; //正确
    //const既修饰指针又修饰常量
    const int * const p3 = &amp;amp;a;
    //p3 = &amp;amp;b; //错误
    //*p3 = 100; //错误
    system(&amp;quot;pause&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;判断方法即看&lt;code&gt;const&lt;/code&gt;紧跟的是什么 紧跟的是指针则指针不可更改 紧跟的是指向的变量类型 则指向的变量不可更改&lt;br&gt;
看&lt;code&gt;const&lt;/code&gt;右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量&lt;/p&gt;
&lt;p&gt;想要存放常量的地址必须使用常量指针&lt;br&gt;
但和常量引用类似 常量指针也不一定要指向常量 只是禁止通过指针来改变指向的对象&lt;/p&gt;
&lt;p&gt;和一般的常量相同 对指针常量进行定义时必须初始化且值(即指向的对象地址)不可改变&lt;br&gt;
非常量可以转换为常量 但反之不行 所以可以用常量指针保存非常量的地址 反之不行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常量表达式(constexpr)是指值不会改变且在编译过程就能得到值的表达式&lt;/strong&gt; 由数据类型和初始值共同决定:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;const int s = 20; //是
Const int a = s+1; //是
Int b= 22; //不是, 其数据类型不是常量
Const int c = get_v(); //不是 其值要在运行时才能得到
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于实际中几乎不可能判断是不是常量表达式 因此可以通过声明&lt;code&gt;constexpr&lt;/code&gt;类型来定义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;constexpr int sz = get_v(); // 必须get_v()是一个constexpr函数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是由于常量表达式必须在编译时得到 因此必须是很简单的类型 比如字面值类型(自定义类 库函数的不行)&lt;br&gt;
注意&lt;code&gt;constexpr&lt;/code&gt;定义的指针等价于指针常量 &lt;code&gt;constexpr int * a&lt;/code&gt; 等价于 &lt;code&gt;int * const a&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-类型的特殊使用&#34;&gt;5. 类型的特殊使用&lt;/h2&gt;
&lt;p&gt;使用变量类型的别名:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Typedef&lt;/strong&gt; : &lt;code&gt;typedef double wage, *p; &lt;/code&gt;  &lt;code&gt;wage&lt;/code&gt;是&lt;code&gt;double&lt;/code&gt;的别名, &lt;code&gt;p&lt;/code&gt;是&lt;code&gt;double *&lt;/code&gt;的别名&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Using(别名声称)&lt;/strong&gt;: &lt;code&gt;using wage = double;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是使用指针别名时需要注意 如上&lt;code&gt;p&lt;/code&gt;是&lt;code&gt;double *&lt;/code&gt;的别名,则&lt;code&gt;const p&lt;/code&gt;定义的是一个指针常量, &lt;code&gt;const&lt;/code&gt;修饰的是&lt;code&gt;p&lt;/code&gt;的整体类型&lt;br&gt;
不能简单地将原名替换回来再看 是错误的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;类型 是让编译器根据值自己推断类型 &lt;code&gt;auto a = b + c;&lt;/code&gt;&lt;br&gt;
使用&lt;code&gt;auto&lt;/code&gt;在一行中声明多个时 必须保证都是同一个数据类型 但声明符可以不同&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;auto i=0, *p =&amp;amp;i; //正确 整型与整型指针 类型相同 声明符不同
auto a=0, b=&#39;a&#39;; //错误 类型不一致
const int c = 0; 
int d=0;
auto e=c, f=d; // 错误 cosnt int 与 int类型不一致
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;decltype&lt;/code&gt;关键字用于选择并返回操作数的类型&lt;/strong&gt;&lt;br&gt;
这个过程中&lt;strong&gt;编译器分析表达式得到类型却不实际调用表达式计算&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;decltype(f()) sum =x; 
const int i = 0; 
decltype(i) y=0; // y的类型是 const int
int a=0, *p =&amp;amp;a, &amp;amp;r = a;
decltype(r) b = a; 
decltype(r+0) c; 
decltype(*p) d;
decltype((a)) f =a;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;b&lt;/code&gt;的类型是&lt;code&gt;int &amp;amp;&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;的类型是&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;的类是&lt;code&gt;int &amp;amp;&lt;/code&gt;, 因为解引用得到的其实就是指针指向对象的引用&lt;br&gt;
&lt;code&gt;f&lt;/code&gt;的类型是&lt;code&gt;int &amp;amp;&lt;/code&gt;, 因为加上括号的变量被视为特殊的表达式, 其类型为对应引用&lt;/p&gt;
&lt;p&gt;迭代器类型类似于指针 使用值时也需解引用&lt;/p&gt;
">[C++学习笔记] 数据类型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/1N8AHbdaD/"" data-c="
          &lt;h2 id=&#34;超图生成&#34;&gt;超图生成&lt;/h2&gt;
&lt;p&gt;基于距离(聚类 最近k邻居) 基于表示(特征重建) 基于属性(共享属性信息构造) 基于网络(社交小组)&lt;br&gt;
如果相关性是潜在的和模糊的，则可以使用基于距离的方法和基于表示的方法从观测数据隐式生成超&lt;br&gt;
图。我们还可以使用数据的固有属性或网络信息构建显式超图。&lt;br&gt;
基于距离的方法在运行时间方面更有效，更适合在线场景，而基于表示的方法消耗更多时间，但对噪&lt;br&gt;
声数据更鲁棒。&lt;/p&gt;
&lt;h2 id=&#34;超图学习&#34;&gt;超图学习&lt;/h2&gt;
&lt;h3 id=&#34;标签预测&#34;&gt;标签预测&lt;/h3&gt;
&lt;p&gt;传导式 (在超图构造和学习过程中考虑了所有的训练数据和测试数据)&lt;br&gt;
归纳式 (离线训练 基本思想是学习从特征空间到标签空间的投影矩阵)&lt;/p&gt;
&lt;h3 id=&#34;动态超图结构学习&#34;&gt;动态超图结构学习&lt;/h3&gt;
&lt;p&gt;在学习过程中动态调整超图组件，包括超边权重、顶点权重和关联矩阵，以使数据关联建模更加精确&lt;/p&gt;
&lt;p&gt;固定超图结构方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超边权重学习&lt;/li&gt;
&lt;li&gt;节点权重学习&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;超图结构学习&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点: 在学习过程中动态更新超图结构, 将特征空间和标签空间相关联&lt;/li&gt;
&lt;li&gt;缺点:非凸模型和高计算成本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;多模态数据的超图学习&#34;&gt;多模态数据的超图学习&lt;/h3&gt;
&lt;p&gt;传导式 ：对于每个模态生成一个超图 超图Gi的最优权重αi与顶点标签向量联合学习&lt;br&gt;
归纳式 ：离线训练时每个模态一个超图 每个模态学习一个从特征空间到标签空间的投影矩阵Mi 学习时与投影矩阵Mi联合学习每个模态的权重αi&lt;/p&gt;
&lt;h2 id=&#34;基于张量的动态超图学习-这篇文章提出的算法-t-dhl&#34;&gt;基于张量的动态超图学习 (这篇文章提出的算法 t-DHL)&lt;/h2&gt;
&lt;p&gt;动态超图学习问题面临的挑战主要有三方面的限制:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;固定的超边数量和顺序&lt;/li&gt;
&lt;li&gt;非凸优化模型(存在收敛问题)&lt;/li&gt;
&lt;li&gt;计算成本高(关联矩阵的高表示复杂性使得计算梯度和优化目标函数的成本很高)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;张量表示可以描述所有阶的超边，是超图结构的完整表示, 因此优化张量表示时，不仅可以改变权重，还可以改变超边的数量和顺序&lt;/p&gt;
&lt;p&gt;将超边关系转换为向量表示 即用&lt;code&gt;2^N-1&lt;/code&gt;个向量代表每个排列组合下的节点间是否存在超边&lt;/p&gt;
&lt;p&gt;Eg. 7个向量依次表示 节点&lt;code&gt;v1&lt;/code&gt;自身, 节点&lt;code&gt;v2&lt;/code&gt;自身, 节点&lt;code&gt;v3&lt;/code&gt;自身, 节点&lt;code&gt;v1&lt;/code&gt;,&lt;code&gt;v2&lt;/code&gt;, 节点&lt;code&gt;v1&lt;/code&gt;,&lt;code&gt;v3&lt;/code&gt;, 节点&lt;code&gt;v2&lt;/code&gt;,&lt;code&gt;v3&lt;/code&gt;, 节点&lt;code&gt;v1&lt;/code&gt;,&lt;code&gt;v2&lt;/code&gt;,&lt;code&gt;v3&lt;/code&gt;是否构成边&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688466021351.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;2^N-1&lt;/code&gt;个向量空间太大, 进行采样降低, 方法: 将一个大图分解成多个小图, 对于每个节点, 以&lt;code&gt;k&lt;/code&gt;个最近邻域节点构造小图, 每个小图的节点数目不超过&lt;code&gt;ln N&lt;/code&gt;, 这样总的空间消耗变成&lt;code&gt;NlnN&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;HGNN 中，引入了谱卷积层来处理表示学习的高阶数据相关性。&lt;/p&gt;
&lt;p&gt;然而，这个框架只使用了一个静态的初始构建超图结构DHGNN，基于HGNN加入了动态更新超图结构, 其中超图重建模块和超图卷积模块交替堆叠, 每次卷积运算后都会重新生成一个新的超图，在这种更新策略下，超图结构的变化是不连续和不可微的，可能导致不收敛&lt;/p&gt;
&lt;h2 id=&#34;基于超图学习方法的应用&#34;&gt;基于超图学习方法的应用&lt;/h2&gt;
&lt;p&gt;应用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三维物体分类：通过多模态传导式超图学习&lt;/li&gt;
&lt;li&gt;情感分析：多模态归纳超图学习方法&lt;/li&gt;
&lt;li&gt;动作识别：优势 建模不同动作样本之间的高阶相关性&lt;/li&gt;
&lt;li&gt;人脸识别等聚类问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要将超图学习应用于特定的分类或聚类任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步是用超图结构对问题建模（例如，定义超图顶点所指的对象）。&lt;/li&gt;
&lt;li&gt;第二步是基于对象的特征、属性或先前相关性构建超图。&lt;/li&gt;
&lt;li&gt;最后一步是使用适当的超图学习方法对该超图进行学习。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;thu-hyperg的开源python库&#34;&gt;THU HyperG的开源Python库&lt;/h2&gt;
&lt;p&gt;https://github.com/iMoonLab/THU-HyperG&lt;/p&gt;
&lt;p&gt;提供了各种超图学习方法的实现，它允许用户将超图学习应用于分类和聚类任务&lt;/p&gt;
&lt;p&gt;对于超图生成，THU HyperG支持各种超图生成算法，包括基于距离的、基于表示的、基于属性的和基于网络的方法。&lt;/p&gt;
&lt;p&gt;对于超图学习，在THU HyperG中实现了包括传导性超图学习、归纳超图学习、超图交叉扩散、基于张量的超图学习和超图结构更新方法等方法。&lt;/p&gt;
">[论文阅读] Hypergraph Learning: Methods and Practices</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/ftHFFDCnU/"" data-c="
          &lt;h2 id=&#34;introduction&#34;&gt;introduction&lt;/h2&gt;
&lt;p&gt;Location-Based Social Network (LBSN) 包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;异构边 (签入超边 check-in hyperedge, 包括用户 行为 时间 空间四个数据域)&lt;/li&gt;
&lt;li&gt;同构边 (友谊边 friendships edge, 两个用户之间的友谊关系)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Point of Interest (POI)  代表兴趣地点&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688470242344.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;friendship prediction 基于现有的社交网络预测两个用户之间的潜在友谊&lt;br&gt;
location prediction 根据用户的历史移动轨迹预测用户在特定环境下的位置&lt;br&gt;
n-uniform hypergraph 所有超边都包含固定数量的n个节点&lt;/p&gt;
&lt;h2 id=&#34;lbsn2vec-基于图采样的嵌入方法&#34;&gt;LBSN2Vec++ (基于图采样的嵌入方法)&lt;/h2&gt;
&lt;p&gt;首先使用随机游走和停留方案从LBSN异构超图中联合抽取友谊边和签入超边，然后从这些超边中学习节点嵌入。&lt;/p&gt;
&lt;h3 id=&#34;random-walk-with-stay&#34;&gt;Random Walk with Stay&lt;/h3&gt;
&lt;p&gt;基于用户节点在社交领域的友谊对其执行经典的随机漫步，而对于每个遇到的用户节点，它停留在用户节点上，从相应的用户中抽取一组超边（签入）。&lt;/p&gt;
&lt;p&gt;节点嵌入学习过程在这两种边缘之间交替进行（即友谊和签入）。&lt;/p&gt;
&lt;p&gt;在每个用户节点上生成长度为&lt;code&gt;l&lt;/code&gt;的&lt;code&gt;r&lt;/code&gt;次行走。&lt;/p&gt;
&lt;p&gt;在游走过程中,对于每个用户节点&lt;code&gt;ui&lt;/code&gt;, 选择它的&lt;code&gt;2k&lt;/code&gt;个上下文（每侧有&lt;code&gt;k&lt;/code&gt;个上下文节点），从而产生&lt;code&gt;2k&lt;/code&gt;对用户节点。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1688470255899.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;图2显示了一个上下文窗口大小为2的示例。随后，使用随机抽样和替换策略为每个用户节点抽样相同数量（&lt;code&gt;2k&lt;/code&gt;）的签入，以确保每个用户抽样的签入和友谊数量完全相同。&lt;/p&gt;
&lt;p&gt;从每个签入&lt;code&gt;(u，c，t，l)&lt;/code&gt;中学习概率为&lt;code&gt;α&lt;/code&gt;，从每个用户节点对&lt;code&gt;(ui，uj)&lt;/code&gt;的概率为&lt;code&gt;1− α&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;总之，对于随机行走中的每个节点&lt;code&gt;vi&lt;/code&gt;，预期的学习边总数为&lt;code&gt;2k&lt;/code&gt;，包括预期的签入边&lt;code&gt;2kα &lt;/code&gt;个和预期的&lt;code&gt;2k（1− α）&lt;/code&gt; 个用户节点对。&lt;/p&gt;
&lt;h3 id=&#34;超边学习&#34;&gt;超边学习&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wjcsw.github.io/post-images/1688470261142.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;节点嵌入利用最佳拟合线概念 即最小化数据点与拟合线的垂直距离之和 如图(a)&lt;/p&gt;
&lt;p&gt;从形式上讲，一组节点嵌入的最佳拟合线是使每个节点嵌入和最佳拟合线之间的余弦距离之和最小的向量 可通过线性最小二乘法计算 如图(b)&lt;/p&gt;
&lt;p&gt;通过迭代最大化超边中的每个节点嵌入与最佳拟合线嵌入之间的余弦相似性来优化n方向节点邻近性&lt;/p&gt;
&lt;p&gt;采用负采样技术来最大化每个负采样节点vN与最佳拟合线向量之间的余弦距离&lt;/p&gt;
&lt;p&gt;总的目标函数(最大化)&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688470266809.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;当从一个特定的超边学习时，只需要更新&lt;code&gt;~vi&lt;/code&gt;和&lt;code&gt;~vN&lt;/code&gt;，因为最佳拟合线向量&lt;code&gt;~vb&lt;/code&gt;是固定的&lt;/p&gt;
&lt;p&gt;在学习过程中, 对于每个签入超边, 首先分别通过两个投影矩阵将相应的用户节点和POI节点转换为活动域中的节点&lt;/p&gt;
&lt;p&gt;然后同时保持活动节点、转换后的用户节点与POI节点的三重邻近性(即最大化这个三元组中与最佳拟合的余弦相似度)。&lt;/p&gt;
&lt;h3 id=&#34;实验部分&#34;&gt;实验部分&lt;/h3&gt;
&lt;p&gt;数据集&lt;br&gt;
&lt;img src=&#34;https://wjcsw.github.io/post-images/1688470276882.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;游走参数 （l=80，r=10，k=10） 以0.1的步长调整&lt;code&gt;[0，1]&lt;/code&gt;内的参数&lt;code&gt;α&lt;/code&gt;，以平衡社交和流动性对所学嵌入的影响&lt;/p&gt;
&lt;p&gt;节点嵌入的尺寸&lt;code&gt;d&lt;/code&gt;设置为128，负样本数&lt;code&gt;γ&lt;/code&gt;设置为10&lt;/p&gt;
&lt;p&gt;展望: 分析其他类型的用户移动数据（如交通轨迹和细粒度手机轨迹）时探索图形嵌入的思想。&lt;/p&gt;
&lt;p&gt;代码: https://github.com/eXascaleInfolab/LBSN2Vec&lt;/p&gt;
">[论文阅读] LBSN2Vec++: Heterogeneous Hypergraph Embedding for Location-Based Social Networks</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://wjcsw.github.io/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>



<script src="/media/js/mouse/love.js"></script>





</html>